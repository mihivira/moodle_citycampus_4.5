<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Mycoursestatus block
 *
 * @package    block_mycoursestatus
 * @copyright  2014 Lavanya Lav
 * @license    https://github.com/lavanyamanne2/moodle-block_mycoursestatus
 */

require_once('../../config.php');
global $CFG, $DB, $PAGE, $COURSE, $USER;
require_once($CFG->dirroot.'/blocks/mycoursestatus/classes/module.php');
$PAGE->requires->css('/blocks/mycoursestatus/styles.css');
require_once(dirname(__FILE__).'/config/tcpdf_config.php');

$courseid = required_param('id', PARAM_INT);
$PAGE->set_url(new moodle_url('/blocks/mycoursestatus/report.php', array('id' => $courseid)));

// Basic access checks.
if (!$course = $DB->get_record('course', array('id' => $courseid))) {
    print_error('nocourseid');
}
require_login($courseid);

$context = context_course::instance($courseid);
require_capability('gradereport/user:view', $context);

if (isguestuser()) {
    // Force them to see system default, no editing allowed.
    $userid = null;
    $USER->editing = $edit = 0;
    $context = context_system::instance();
    // A:get_context_instance(CONTEXT_SYSTEM) turns into context_system::instance().
    $PAGE->set_blocks_editing_capability('moodle/my:configsyspages');
    $header = $course->fullname;
} else {
    // We are trying to view or edit our own My Moodle page i.e., admin part.
    $userid = $USER->id;
    $context = get_context_instance(CONTEXT_USER, $USER->id);
    $PAGE->set_blocks_editing_capability('moodle/my:manageblocks');
    $header = $course->fullname;
}
class TCPDF {

    // Private properties.

    /**
     * Current TCPDF version.
     * @private
     */
    private $tcpdfversion = '5.9.172';

    // Protected properties.

    /**
     * Current page number.
     * @protected
     */
    protected $page;

    /**
     * Current object number.
     * @protected
     */
    protected $n;

    /**
     * Array of object offsets.
     * @protected
     */
    protected $offsets = array();

    /**
     * Array of object IDs for each page.
     * @protected
     */
    protected $pageobjects = array();

    /**
     * Buffer holding in-memory PDF.
     * @protected
     */
    protected $buffer;

    /**
     * Array containing pages.
     * @protected
     */
    protected $pages = array();

    /**
     * Current document state.
     * @protected
     */
    protected $state;

    /**
     * Compression flag.
     * @protected
     */
    protected $compress;

    /**
     * Current page orientation (P = Portrait, L = Landscape).
     * @protected
     */
    protected $curcrientation;

    /**
     * Page dimensions.
     * @protected
     */
    protected $pagedim = array();

    /**
     * scale factor (number of points in user unit).
     * @protected
     */
    protected $k;

    /**
     * Width of page format in points.
     * @protected
     */
    protected $fwpt;

    /**
     * Height of page format in points.
     * @protected
     */
    protected $fhpt;

    /**
     * Current width of page in points.
     * @protected
     */
    protected $wpt;

    /**
     * Current height of page in points.
     * @protected
     */
    protected $hpt;

    /**
     * Current width of page in user unit.
     * @protected
     */
    protected $w;

    /**
     * Current height of page in user unit.
     * @protected
     */
    protected $h;

    /**
     * Left margin.
     * @protected
     */
    protected $lmargin;

    /**
     * Top margin.
     * @protected
     */
    protected $tmargin;

    /**
     * Right margin.
     * @protected
     */
    protected $rmargin;

    /**
     * Page break margin.
     * @protected
     */
    protected $bmargin;

    /**
     * Array of cell internal paddings ('T' => top, 'R' => right, 'B' => bottom, 'L' => left).
     * @protected
     */
    protected $cellpadding = array('T' => 0, 'R' => 0, 'B' => 0, 'L' => 0);

    /**
     * Array of cell margins ('T' => top, 'R' => right, 'B' => bottom, 'L' => left).
     * @protected
     */
    protected $cellmargin = array('T' => 0, 'R' => 0, 'B' => 0, 'L' => 0);

    /**
     * Current horizontal position in user unit for cell positioning.
     * @protected
     */
    protected $x;

    /**
     * Current vertical position in user unit for cell positioning.
     * @protected
     */
    protected $y;

    /**
     * Height of last cell printed.
     * @protected
     */
    protected $lasth;

    /**
     * line width in user unit.
     * @protected
     */
    protected $linewidth;

    /**
     * Array of standard font names.
     * @protected
     */
    protected $corefonts;

    /**
     * Array of used fonts.
     * @protected
     */
    protected $fonts = array();

    /**
     * Array of font files.
     * @protected
     */
    protected $fontfiles = array();

    /**
     * Array of encoding differences.
     * @protected
     */
    protected $diffs = array();

    /**
     * Array of used images.
     * @protected
     */
    protected $images = array();

    /**
     * Array of annotations in pages.
     * @protected
     */
    protected $pageannots = array();

    /**
     * Array of internal links.
     * @protected
     */
    protected $links = array();

    /**
     * Current font family.
     * @protected
     */
    protected $fontfamily;

    /**
     * Current font style.
     * @protected
     */
    protected $fontstyle;

    /**
     * Current font ascent (distance between font top and baseline).
     * @protected
     */
    protected $fontascent;

    /**
     * Current font descent (distance between font bottom and baseline).
     * @protected
     */
    protected $fontdescent;

    /**
     * Underlining flag.
     * @protected
     */
    protected $underline;

    /**
     * Overlining flag.
     * @protected
     */
    protected $overline;

    /**
     * Current font info.
     * @protected
     */
    protected $currentfont;

    /**
     * Current font size in points.
     * @protected
     */
    protected $fontsizept;

    /**
     * Current font size in user unit.
     * @protected
     */
    protected $fontsize;

    /**
     * Commands for drawing color.
     * @protected
     */
    protected $drawcolor;

    /**
     * Commands for filling color.
     * @protected
     */
    protected $fillcolor;

    /**
     * Commands for text color.
     * @protected
     */
    protected $textcolor;

    /**
     * Indicates whether fill and text colors are different.
     * @protected
     */
    protected $colorflag;

    /**
     * Automatic page breaking.
     * @protected
     */
    protected $autopagebreak;

    /**
     * Threshold used to trigger page breaks.
     * @protected
     */
    protected $pagebreaktrigger;

    /**
     * Flag set when processing page header.
     * @protected
     */
    protected $inheader = false;

    /**
     * Flag set when processing page footer.
     * @protected
     */
    protected $infooter = false;

    /**
     * Zoom display mode.
     * @protected
     */
    protected $zoommode;

    /**
     * Layout display mode.
     * @protected
     */
    protected $layoutmode;

    /**
     * If true set the document information dictionary in Unicode.
     * @protected
     */
    protected $docinfounicode = true;

    /**
     * Document title.
     * @protected
     */
    protected $title = '';

    /**
     * Document subject.
     * @protected
     */
    protected $subject = '';

    /**
     * Document author.
     * @protected
     */
    protected $author = '';

    /**
     * Document keywords.
     * @protected
     */
    protected $keywords = '';

    /**
     * Document creator.
     * @protected
     */
    protected $creator = '';

    /**
     * Starting page number.
     * @protected
     */
    protected $startingpagenumber = 1;

    /**
     * String alias for total number of pages.
     * @protected
     */
    protected $aliastotpages = '{:ptp:}';

    /**
     * String alias for page number.
     * @protected
     */
    protected $aliasnumpage = '{:pnp:}';

    /**
     * String alias for total number of pages in a single group.
     * @protected
     */
    protected $aliasgrouptotpages = '{:ptg:}';

    /**
     * String alias for group page number.
     * @protected
     */
    protected $aliasgroupnumpage = '{:png:}';

    /**
     * String alias for right shift compensation used to correctly align page numbers on the right.
     * @protected
     */
    protected $aliasrightshift = '{rsc:';

    /**
     * The right-bottom (or left-bottom for RTL) corner X coordinate of last inserted image.
     * @protected
     */
    protected $imgrbx;

    /**
     * The right-bottom corner Y coordinate of last inserted image.
     * @protected
     */
    protected $imgrby;

    /**
     * Adjusting factor to convert pixels to user units.
     * @protected
     */
    protected $imgscale = 1;

    /**
     * Boolean flag set to true when the input text is unicode (require unicode fonts).
     * @protected
     */
    protected $isunicode = false;

    /**
     * Object containing unicode data.
     * @protected
     */
    protected $unicode;

    /**
     * Object containing font encoding maps.
     * @protected
     */
    protected $encmaps;

    /**
     * PDF version.
     * @protected
     */
    protected $pdfversion = '1.7';

    /**
     * ID of the stored default header template (-1 = not set).
     * @protected
     */
    protected $headerxobjid = -1;

    /**
     * If true reset the header Xobject template at each page
     * @protected
     */
    protected $headerxobjautoreset = false;

    /**
     * Minimum distance between header and top page margin.
     * @protected
     */
    protected $headermargin;

    /**
     * Minimum distance between footer and bottom page margin.
     * @protected
     */
    protected $footermargin;

    /**
     * Original left margin value.
     * @protected
     */
    protected $originallmargin;

    /**
     * Original right margin value.
     * @protected
     */
    protected $originalrmargin;

    /**
     * Default font used on page header.
     * @protected
     */
    protected $headerfont;

    /**
     * Default font used on page footer.
     * @protected
     */
    protected $footerfont;

    /**
     * Language templates.
     * @protected
     */
    protected $l;

    /**
     * Barcode to print on page footer (only if set).
     * @protected
     */
    protected $barcode = false;

    /**
     * Boolean flag to print/hide page header.
     * @protected
     */
    protected $printheader = true;

    /**
     * Boolean flag to print/hide page footer.
     * @protected
     */
    protected $printfooter = true;

    /**
     * header image logo.
     * @protected
     */
    protected $headerlogo = '';

    /**
     * Width of header image logo in user units.
     * @protected
     */
    protected $headerlogowidth = 30;

    /**
     * Title to be printed on default page header.
     * @protected
     */
    protected $headertitle = '';

    /**
     * String to pring on page header after title.
     * @protected
     */
    protected $headerstring = '';

    /**
     * Default number of columns for html table.
     * @protected
     */
    protected $defaulttablecolumns = 4;

    // Variables for html parser.

    /**
     * HTML PARSER: array to store current link and rendering styles.
     * @protected
     */
    protected $href = array();

    /**
     * List of available fonts on filesystem.
     * @protected
     */
    protected $fontlist = array();

    /**
     * Current foreground color.
     * @protected
     */
    protected $fgcolor;

    /**
     * HTML PARSER: array of boolean values, true in case of ordered list (OL), false otherwise.
     * @protected
     */
    protected $listordered = array();

    /**
     * HTML PARSER: array count list items on nested lists.
     * @protected
     */
    protected $listcount = array();

    /**
     * HTML PARSER: current list nesting level.
     * @protected
     */
    protected $listnum = 0;

    /**
     * HTML PARSER: indent amount for lists.
     * @protected
     */
    protected $listindent = 0;

    /**
     * HTML PARSER: current list indententation level.
     * @protected
     */
    protected $listindentlevel = 0;

    /**
     * Current background color.
     * @protected
     */
    protected $bgcolor;

    /**
     * Temporary font size in points.
     * @protected
     */
    protected $tempfontsize = 10;

    /**
     * Spacer string for LI tags.
     * @protected
     */
    protected $lispacer = '';

    /**
     * Default encoding.
     * @protected
     */
    protected $encoding = 'UTF-8';

    /**
     * PHP internal encoding.
     * @protected
     */
    protected $internalencoding;

    /**
     * Boolean flag to indicate if the document language is Right-To-Left.
     * @protected
     */
    protected $rtl = false;

    /**
     * Boolean flag used to force RTL or LTR string direction.
     * @protected
     */
    protected $tmprtl = false;

    // Variables used for document encryption.

    /**
     * IBoolean flag indicating whether document is protected.
     * @protected
     */
    protected $encrypted;

    /**
     * Array containing encryption settings.
     * @protected
     */
    protected $encryptdata = array();

    /**
     * Last rc4 key encrypted (cached for optimisation).
     * @protected
     */
    protected $lastenckey;

    /**
     * Last rc4 computed key.
     * @protected
     */
    protected $lastenckeyc;

    /**
     * Encryption padding string.
     * @protected
     */
    protected $encpadding = "\x28\xBF\x4E\x5E\x4E\x75\x8A\x41\x64\x00\x4E\x56\xFF\xFA\x01\x08\x2E\x2E\x00\xB6\xD0\
                              x68\x3E\x80\x2F\x0C\xA9\xFE\x64\x53\x69\x7A";

    /**
     * File ID (used on document trailer).
     * @protected
     */
    protected $fileid;

    // Bookmark.

    /**
     * Outlines for bookmark.
     * @protected
     */
    protected $outlines = array();

    /**
     * Outline root for bookmark.
     * @protected
     */
    protected $outlineroot;

    // Javascript and form.

    /**
     * Javascript code.
     * @protected
     */
    protected $javascript = '';

    /**
     * Javascript counter.
     * @protected
     */
    protected $njs;

    /**
     * line trough state
     * @protected
     */
    protected $linethrough;

    /**
     * Array with additional document-wide usage rights for the document.
     * @protected
     */
    protected $ur = array();

    /**
     * DPI (Dot Per Inch) Document Resolution (do not change).
     * @protected
     */
    protected $dpi = 72;

    /**
     * Array of page numbers were a new page group was started (the page numbers are the keys of the array).
     * @protected
     */
    protected $newpagegroup = array();

    /**
     * Array that contains the number of pages in each page group.
     * @protected
     */
    protected $pagegroups = array();

    /**
     * Current page group number.
     * @protected
     */
    protected $currpagegroup = 0;

    /**
     * Array of transparency objects and parameters.
     * @protected
     */
    protected $extgstates;

    /**
     * Set the default JPEG compression quality (1-100).
     * @protected
     */
    protected $jpegquality;

    /**
     * Default cell height ratio.
     * @protected
     */
    protected $cellheightratio = K_CELL_HEIGHT_RATIO;

    /**
     * PDF viewer preferences.
     * @protected
     */
    protected $viewerpreferences;

    /**
     * A name object specifying how the document should be displayed when opened.
     * @protected
     */
    protected $pagemode;

    /**
     * Array for storing gradient information.
     * @protected
     */
    protected $gradients = array();

    /**
     * Array used to store positions inside the pages buffer (keys are the page numbers).
     * @protected
     */
    protected $intmrk = array();

    /**
     * Array used to store positions inside the pages buffer (keys are the page numbers).
     * @protected
     */
    protected $bordermrk = array();

    /**
     * Array used to store page positions to track empty pages (keys are the page numbers).
     * @protected
     */
    protected $emptypagemrk = array();

    /**
     * Array used to store content positions inside the pages buffer (keys are the page numbers).
     * @protected
     */
    protected $cntmrk = array();

    /**
     * Array used to store footer positions of each page.
     * @protected
     */
    protected $footerpos = array();

    /**
     * Array used to store footer length of each page.
     * @protected
     */
    protected $footerlen = array();

    /**
     * Boolean flag to indicate if a new line is created.
     * @protected
     */
    protected $newline = true;

    /**
     * End position of the latest inserted line.
     * @protected
     */
    protected $endlinex = 0;

    /**
     * PDF string for width value of the last line.
     * @protected
     */
    protected $linestylewidth = '';

    /**
     * PDF string for CAP value of the last line.
     * @protected
     */
    protected $linestylecap = '0 J';

    /**
     * PDF string for join value of the last line.
     * @protected
     */
    protected $linestylejoin = '0 j';

    /**
     * PDF string for dash value of the last line.
     * @protected
     */
    protected $linestyledash = '[] 0 d';

    /**
     * Boolean flag to indicate if marked-content sequence is open.
     * @protected
     */
    protected $openmarkedcontent = false;

    /**
     * Count the latest inserted vertical spaces on HTML.
     * @protected
     */
    protected $htmlvspace = 0;

    /**
     * Array of Spot colors.
     * @protected
     */
    protected $spotcolors = array();

    /**
     * Symbol used for HTML unordered list items.
     * @protected
     */
    protected $lisymbol = '';

    /**
     * String used to mark the beginning and end of EPS image blocks.
     * @protected
     */
    protected $epsmarker = 'x#!#EPS#!#x';

    /**
     * Array of transformation matrix.
     * @protected
     */
    protected $transfmatrix = array();

    /**
     * Current key for transformation matrix.
     * @protected
     */
    protected $transfmatrixkey = 0;

    /**
     * Booklet mode for double-sided pages.
     * @protected
     */
    protected $booklet = false;

    /**
     * Epsilon value used for float calculations.
     * @protected
     */
    protected $feps = 0.005;

    /**
     * Array used for custom vertical spaces for HTML tags.
     * @protected
     */
    protected $tagvspaces = array();

    /**
     * HTML PARSER: custom indent amount for lists. Negative value means disabled.
     * @protected
     */
    protected $customlistindent = -1;

    /**
     * Boolean flag to indicate if the border of the cell sides that cross the page should be removed.
     * @protected
     */
    protected $opencell = true;

    /**
     * Array of files to embedd.
     * @protected
     */
    protected $embeddedfiles = array();

    /**
     * Boolean flag to indicate if we are inside a PRE tag.
     * @protected
     */
    protected $premode = false;

    /**
     * Array used to store positions of graphics transformation blocks inside the page buffer.
     * keys are the page numbers
     * @protected
     */
    protected $transfmrk = array();

    /**
     * Default color for html links.
     * @protected
     */
    protected $htmllinkcolorarray = array(0, 0, 255);

    /**
     * Default font style to add to html links.
     * @protected
     */
    protected $htmllinkfontstyle = 'U';

    /**
     * Counts the number of pages.
     * @protected
     */
    protected $numpages = 0;

    /**
     * Array containing page lengths in bytes.
     * @protected
     */
    protected $pagelen = array();

    /**
     * Counts the number of pages.
     * @protected
     */
    protected $numimages = 0;

    /**
     * Store the image keys.
     * @protected
     */
    protected $imagekeys = array();

    /**
     * Length of the buffer in bytes.
     * @protected
     */
    protected $bufferlen = 0;

    /**
     * If true enables disk caching.
     * @protected
     */
    protected $diskcache = false;

    /**
     * Counts the number of fonts.
     * @protected
     */
    protected $numfonts = 0;

    /**
     * Store the font keys.
     * @protected
     */
    protected $fontkeys = array();

    /**
     * Store the font object IDs.
     * @protected
     */
    protected $fontobjids = array();

    /**
     * Store the fage status (true when opened, false when closed).
     * @protected
     */
    protected $pageopen = array();

    /**
     * Default monospace font.
     * @protected
     */
    protected $defaultmonospacedfont = 'courier';

    /**
     * Cloned copy of the current class object.
     * @protected
     */
    protected $objcopy;

    /**
     * Array used to store the lengths of cache files.
     * @protected
     */
    protected $cachefilelength = array();

    /**
     * Table header content to be repeated on each new page.
     * @protected
     */
    protected $thead = '';

    /**
     * Margins used for table header.
     * @protected
     */
    protected $theadmargins = array();

    /**
     * Cache array for utf8stringtoarray() method.
     * @protected
     */
    protected $cacheutf8stringtoarray = array();

    /**
     * Maximum size of cache array used for utf8stringtoarray() method.
     * @protected
     */
    protected $cachemaxsizeutf8stringtoarray = 8;

    /**
     * Current size of cache array used for utf8stringtoarray() method.
     * @protected
     */
    protected $cachesizeutf8stringtoarray = 0;

    /**
     * Boolean flag to enable document digital signature.
     * @protected
     */
    protected $sign = false;

    /**
     * Digital signature data.
     * @protected
     */
    protected $signaturedata = array();

    /**
     * Digital signature max length.
     * @protected
     */
    protected $signaturemaxlength = 11742;

    /**
     * Data for digital signature appearance.
     * @protected
     */
    protected $signatureappearance = array('page' => 1, 'rect' => '0 0 0 0');

    /**
     * Array of empty digital signature appearances.
     * @protected
     */
    protected $emptysignatureappearance = array();

    /**
     * Regular expression used to find blank characters (required for word-wrapping).
     * @protected
     */
    protected $respaces = '/[^\S\xa0]/';

    /**
     * Array of $respaces parts.
     * @protected
     */
    protected $respace = array('p' => '[^\S\xa0]', 'm' => '');

    /**
     * Digital signature object ID.
     * @protected
     */
    protected $sigobjid = 0;

    /**
     * ByteRange placemark used during digital signature process.
     * @protected
     */
    protected $byterangestring = '/ByteRange[0 ********** ********** **********]';

    /**
     * Placemark used during digital signature process.
     * @protected
     */
    protected $sigannotref = '***SIGANNREF*** 0 R';

    /**
     * ID of page objects.
     * @protected
     */
    protected $pageobjid = array();

    /**
     * List of form annotations IDs.
     * @protected
     */
    protected $formobjid = array();

    /**
     * Deafult Javascript field properties. Possible values are described on official Javascript for Acrobat API
       reference. annotation options can be directly specified using the 'aopt' entry.
     * @protected
     */
    protected $defaultformprop = array('lineWidth' => 1, 'borderStyle' => 'solid', 'fillColor' => array(255, 255, 255),
                                       'strokeColor' => array(128, 128, 128));

    /**
     * Javascript objects array.
     * @protected
     */
    protected $jsobjects = array();

    /**
     * Current form action (used during XHTML rendering).
     * @protected
     */
    protected $formaction = '';

    /**
     * Current form encryption type (used during XHTML rendering).
     * @protected
     */
    protected $formenctype = 'application/x-www-form-urlencoded';

    /**
     * Current method to submit forms.
     * @protected
     */
    protected $formmode = 'post';

    /**
     * List of fonts used on form fields (fontname => fontkey).
     * @protected
     */
    protected $annotationfonts = array();

    /**
     * List of radio buttons parent objects.
     * @protected
     */
    protected $radiobuttongroups = array();

    /**
     * List of radio group objects IDs.
     * @protected
     */
    protected $radiogroups = array();

    /**
     * text indentation value (used for text-indent CSS attribute).
     * @protected
     */
    protected $textindent = 0;

    /**
     * Store page number when starttransaction() is called.
     * @protected
     */
    protected $starttransactionpage = 0;

    /**
     * Store Y position when starttransaction() is called.
     * @protected
     */
    protected $starttransactiony = 0;

    /**
     * True when we are printing the thead section on a new page.
     * @protected
     */
    protected $inthead = false;

    /**
     * Array of column measures (width, space, starting Y position).
     * @protected
     */
    protected $columns = array();

    /**
     * Number of colums.
     * @protected
     */
    protected $numcolumns = 1;

    /**
     * Current column number.
     * @protected
     */
    protected $currentcolumn = 0;

    /**
     * Starting page for columns.
     * @protected
     */
    protected $columnstartpage = 0;

    /**
     * Maximum page and column selected.
     * @protected
     * @since 5.8.000 (2010-08-11)
     */
    protected $maxselcol = array('page' => 0, 'column' => 0);

    /**
     * Array of: X difference between table cell x start and starting page margin, cellspacing, cellpadding.
     * @protected
     */
    protected $colxshift = array('x' => 0, 's' => array('H' => 0, 'V' => 0), 'p' => array('L' => 0, 'T' => 0,
                                 'R' => 0, 'B' => 0));

    /**
     * text rendering mode: 0 = Fill text; 1 = Stroke text; 2 = Fill, then stroke text; 3 = Neither fill nor
       stroke text (invisible); 4 = Fill text and add to path for clipping; 5 = Stroke text and add to path for
       clipping; 6 = Fill, then stroke text and add to path for clipping; 7 = Add text to path for clipping.
     * @protected
     */
    protected $textrendermode = 0;

    /**
     * text stroke width in doc units.
     * @protected
     */
    protected $textstrokewidth = 0;

    /**
     * Current stroke color.
     * @protected
     */
    protected $strokecolor;

    /**
     * Default unit of measure for document.
     * @protected
     */
    protected $pdfunit = 'mm';

    /**
     * Boolean flag true when we are on TOC (Table Of Content) page.
     * @protected
     */
    protected $tocpage = false;

    /**
     * Boolean flag: if true convert vector images (SVG, EPS) to raster image using GD or ImageMagick library.
     * @protected
     */
    protected $rasterizevectorimages = false;

    /**
     * Boolean flag: if true enables font subsetting by default.
     * @protected
     */
    protected $fontsubsetting = true;

    /**
     * Array of default graphic settings.
     * @protected
     */
    protected $defaultgraphicvars = array();

    /**
     * Array of XObjects.
     * @protected
     */
    protected $xobjects = array();

    /**
     * Boolean value true when we are inside an XObject.
     * @protected
     */
    protected $inxobj = false;

    /**
     * Current XObject ID.
     * @protected
     */
    protected $xobjid = '';

    /**
     * Percentage of character stretching.
     * @protected
     */
    protected $fontstretching = 100;

    /**
     * Increases or decreases the space between characters in a text by the specified amount (tracking).
     * @protected
     */
    protected $fontspacing = 0;

    /**
     * Array of no-write regions.
     * ('page' => page number or empy for current page, 'xt' => X top, 'yt' => Y top, 'xb' => X bottom,
        'yb' => Y bottom, 'side' => page side 'L' = left or 'R' = right)
     * @protected
     */
    protected $pageregions = array();

    /**
     * Array containing HTML color names and values.
     * @protected
     */
    protected $webcolor = array();

    /**
     * Array containing spot color names and values.
     * @protected
     */
    protected $spotcolor = array();

    /**
     * Array of PDF layers data.
     * @protected
     */
    protected $pdflayers = array();

    /**
     * A dictionary of names and corresponding destinations (Dests key on document Catalog).
     * @protected
     */
    protected $dests = array();

    /**
     * Object ID for Named Destinations
     * @protected
     */
    protected $ndests;

    /**
     * Directory used for the last SVG image.
     * @protected
     */
    protected $svgdir = '';

    /**
     *  Deafult unit of measure for SVG.
     * @protected
     */
    protected $svgunit = 'px';

    /**
     * Array of SVG gradients.
     * @protected
     */
    protected $svggradients = array();

    /**
     * ID of last SVG gradient.
     * @protected
     */
    protected $svggradientid = 0;

    /**
     * Boolean value true when in SVG defs group.
     * @protected
     */
    protected $svgdefsmode = false;

    /**
     * Array of SVG defs.
     * @protected
     */
    protected $svgdefs = array();

    /**
     * Boolean value true when in SVG clipPath tag.
     * @protected
     */
    protected $svgclipmode = false;

    /**
     * Array of SVG clipPath commands.
     * @protected
     */
    protected $svgclippaths = array();

    /**
     * Array of SVG clipPath tranformation matrix.
     * @protected
     */
    protected $svgcliptm = array();

    /**
     * ID of last SVG clipPath.
     * @protected
     */
    protected $svgclipid = 0;

    /**
     * SVG text.
     * @protected
     */
    protected $svgtext = '';

    /**
     * SVG text properties.
     * @protected
     */
    protected $svgtextmode = array();

    /**
     * Array of hinheritable SVG properties.
     * @protected
     */
    protected $svginheritprop = array('clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters',
    'color-profile', 'color-rendering', 'cursor', 'direction', 'fill', 'fill-opacity', 'fill-rule', 'font',
    'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight',
    'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'image-rendering', 'kerning', 'letter-spacing',
    'marker', 'marker-end', 'marker-mid', 'marker-start', 'pointer-events', 'shape-rendering', 'stroke', 'stroke-dasharray',
    'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width',
    'text-anchor', 'text-rendering', 'visibility', 'word-spacing', 'writing-mode');

    /**
     * Array of SVG properties.
     * @protected
     */
    protected $svgstyles = array(array(
        'alignment-baseline' => 'auto',
        'baseline-shift' => 'baseline',
        'clip' => 'auto',
        'clip-path' => 'none',
        'clip-rule' => 'nonzero',
        'color' => 'black',
        'color-interpolation' => 'sRGB',
        'color-interpolation-filters' => 'linearRGB',
        'color-profile' => 'auto',
        'color-rendering' => 'auto',
        'cursor' => 'auto',
        'direction' => 'ltr',
        'display' => 'inline',
        'dominant-baseline' => 'auto',
        'enable-background' => 'accumulate',
        'fill' => 'black',
        'fill-opacity' => 1,
        'fill-rule' => 'nonzero',
        'filter' => 'none',
        'flood-color' => 'black',
        'flood-opacity' => 1,
        'font' => '',
        'font-family' => 'helvetica',
        'font-size' => 'medium',
        'font-size-adjust' => 'none',
        'font-stretch' => 'normal',
        'font-style' => 'normal',
        'font-variant' => 'normal',
        'font-weight' => 'normal',
        'glyph-orientation-horizontal' => '0deg',
        'glyph-orientation-vertical' => 'auto',
        'image-rendering' => 'auto',
        'kerning' => 'auto',
        'letter-spacing' => 'normal',
        'lighting-color' => 'white',
        'marker' => '',
        'marker-end' => 'none',
        'marker-mid' => 'none',
        'marker-start' => 'none',
        'mask' => 'none',
        'opacity' => 1,
        'overflow' => 'auto',
        'pointer-events' => 'visiblePainted',
        'shape-rendering' => 'auto',
        'stop-color' => 'black',
        'stop-opacity' => 1,
        'stroke' => 'none',
        'stroke-dasharray' => 'none',
        'stroke-dashoffset' => 0,
        'stroke-linecap' => 'butt',
        'stroke-linejoin' => 'miter',
        'stroke-miterlimit' => 4,
        'stroke-opacity' => 1,
        'stroke-width' => 1,
        'text-anchor' => 'start',
        'text-decoration' => 'none',
        'text-rendering' => 'auto',
        'unicode-bidi' => 'normal',
        'visibility' => 'visible',
        'word-spacing' => 'normal',
        'writing-mode' => 'lr-tb',
        'text-color' => 'black',
        'transfmatrix' => array(1, 0, 0, 1, 0, 0)
        ));

    /**
     * If true force sRGB color profile for all document.
     * @protected
     */
    protected $forcesrgb = false;

    /**
     * If true set the document to PDF/A mode.
     * @protected
     */
    protected $pdfamode = false;

    /**
     * Document creation date-time
     * @protected
     */
    protected $doccreationtimestamp;

    /**
     * Document modification date-time
     * @protected
     */
    protected $docmodificationtimestamp;

    /**
     * Custom XMP data.
     * @protected
     */
    protected $customxmp = '';

    /**
     * Overprint mode array.
     * (Check the "Entries in a Graphics State Parameter Dictionary" on PDF 32000-1:2008).
     */
    protected $overprint = array('OP' => false, 'op' => false, 'OPM' => 0);

    /**
     * Alpha mode array.
     * (Check the "Entries in a Graphics State Parameter Dictionary" on PDF 32000-1:2008).
     */
    protected $alpha = array('CA' => 1, 'ca' => 1, 'BM' => '/Normal', 'AIS' => false);

    /**
     * Define the page boundaries boxes to be set on document.
     */
    protected $pageboxes = array('MediaBox', 'CropBox', 'BleedBox', 'TrimBox', 'ArtBox');

    /**
     * Set the document producer metadata.
     */
    protected $pdfproducer;

    /**
     * If true print TCPDF meta link.
     */
    protected $tcpdflink = true;

    /**
     * Cache array for computed GD gamma values.
     */
    protected $gdgammacache = array();

    // METHODS.

    /**
     * This is the class constructor.
     */
    public function __construct($orientation = 'P', $unit = 'mm', $format = 'A4', $unicode = true, $encoding = 'UTF-8',
                                $diskcache = false, $pdfa = false) {
        // Set internal character encoding to ASCII.
        if (function_exists('mb_internalencoding') AND mb_internalencoding()) {
            $this->internalencoding = mb_internalencoding();
            mb_internalencoding('ASCII');
        }
        // Get array of HTML colors.
        require(dirname(__FILE__).'/htmlcolors.php');
        $this->webcolor = $webcolor;
        // Get array of custom spot colors.
        if (file_exists(dirname(__FILE__).'/spotcolors.php')) {
            require(dirname(__FILE__).'/spotcolors.php');
            $this->spotcolor = $spotcolor;
        } else {
            $this->spotcolor = array();
        }
        require_once(dirname(__FILE__).'/unicode_data.php');
        $this->unicode = new TCPDF_UNICODE_DATA();
        require_once(dirname(__FILE__).'/encodings_maps.php');
        $this->encmaps = new TCPDF_ENCODING_MAPS();
        $this->fontobjids = array();
        $this->pageobjid = array();
        $this->formobjid = array();
        // Set pdf/a mode.
        $this->pdfamode = $pdfa;
        $this->forcesrgb = false;
        // Set disk caching.
        $this->diskcache = $diskcache ? true : false;
        // Set language direction.
        $this->rtl = false;
        $this->tmprtl = false;
        // Some checks.
        $this->_dochecks();
        // Initialization of properties.
        $this->isunicode = $unicode;
        $this->page = 0;
        $this->transfmrk[0] = array();
        $this->pagedim = array();
        $this->n = 2;
        $this->buffer = '';
        $this->pages = array();
        $this->state = 0;
        $this->fonts = array();
        $this->fontfiles = array();
        $this->diffs = array();
        $this->images = array();
        $this->links = array();
        $this->gradients = array();
        $this->infooter = false;
        $this->lasth = 0;
        $this->fontfamily = defined('PDF_FONT_NAME_MAIN') ? PDF_FONT_NAME_MAIN : 'helvetica';
        $this->fontstyle = '';
        $this->fontsizept = 12;
        $this->underline = false;
        $this->overline = false;
        $this->linethrough = false;
        $this->drawcolor = '0 G';
        $this->fillcolor = '0 g';
        $this->textcolor = '0 g';
        $this->colorflag = false;
        $this->pdflayers = array();
        // Encryption values.
        $this->encrypted = false;
        $this->lastenckey = '';
        // Standard Unicode fonts.
        $this->corefonts = array(
            'courier' => 'Courier',
            'courierB' => 'Courier-Bold',
            'courierI' => 'Courier-Oblique',
            'courierBI' => 'Courier-BoldOblique',
            'helvetica' => 'Helvetica',
            'helveticaB' => 'Helvetica-Bold',
            'helveticaI' => 'Helvetica-Oblique',
            'helveticaBI' => 'Helvetica-BoldOblique',
            'times' => 'Times-Roman',
            'timesB' => 'Times-Bold',
            'timesI' => 'Times-Italic',
            'timesBI' => 'Times-BoldItalic',
            'symbol' => 'Symbol',
            'zapfdingbats' => 'ZapfDingbats'
        );
        // Set scale factor.
        $this->setpageunit($unit);
        // Set page format and orientation.
        $this->setpageformat($format, $orientation);
        // Page margins (1 cm).
        $margin = 28.35 / $this->k;
        $this->setmargins($margin, $margin);
        // Internal cell padding.
        $cpadding = $margin / 10;
        $this->setcellpaddings($cpadding, 0, $cpadding, 0);
        // Cell margins.
        $this->setcellmargins(0, 0, 0, 0);
        // Line width (0.2 mm).
        $this->linewidth = 0.57 / $this->k;
        $this->linestylewidth = sprintf('%F w', ($this->linewidth * $this->k));
        $this->linestylecap = '0 J';
        $this->linestylejoin = '0 j';
        $this->linestyledash = '[] 0 d';
        // Automatic page break.
        $this->setautopagebreak(true, (2 * $margin));
        // Full width display mode.
        $this->setdisplaymode('fullwidth');
        // Compression.
        $this->setcompression();
        // Set default PDF version number.
        $this->setpdfversion();
        $this->pdfproducer = "\x54\x43\x50\x44\x46\x20".$this->tcpdfversion."\x20\x28\x68\x74\x74\x70\x3a\x2f\x2f\
                               x77\x77\x77\x2e\x74\x63\x70\x64\x66\x2e\x6f\x72\x67\x29";
        $this->tcpdflink = true;
        $this->encoding = $encoding;
        $this->href = array();
        $this->getfontslist();
        $this->fgcolor = array('R' => 0, 'G' => 0, 'B' => 0);
        $this->strokecolor = array('R' => 0, 'G' => 0, 'B' => 0);
        $this->bgcolor = array('R' => 255, 'G' => 255, 'B' => 255);
        $this->extgstates = array();
        // User's rights.
        $this->sign = false;
        $this->ur['enabled'] = false;
        $this->ur['document'] = '/FullSave';
        $this->ur['annots'] = '/Create/Delete/Modify/Copy/Import/Export';
        $this->ur['form'] = '/Add/Delete/FillIn/Import/Export/SubmitStandalone/SpawnTemplate';
        $this->ur['signature'] = '/Modify';
        $this->ur['ef'] = '/Create/Delete/Modify/Import';
        $this->ur['formex'] = '';
        $this->signatureappearance = array('page' => 1, 'rect' => '0 0 0 0');
        $this->emptysignatureappearance = array();
        // Set default JPEG quality.
        $this->jpegquality = 75;
        // Initialize some settings.
        $this->utf8bidi(array(''), '');
        // Set default font.
        $this->setfont($this->fontfamily, $this->fontstyle, $this->fontsizept);
        // Check if PCRE Unicode support is enabled.
        if ($this->isunicode AND (@preg_match('/\pL/u', 'a') == 1)) {
            $this->setspacesre('/[^\S\P{Z}\xa0]/u');
        } else {
            // PCRE unicode support is turned OFF.
            $this->setspacesre('/[^\S\xa0]/');
        }
        $this->defaultformprop = array('lineWidth' => 1, 'borderStyle' => 'solid', 'fillColor' => array(255, 255, 255),
                                         'strokeColor' => array(128, 128, 128));
        // Set file ID for trailer.
        $serformat = (is_array($format) ? serialize($format) : $format);
        $this->fileid = md5($this->getrandomseed('TCPDF'.$orientation.$unit.$serformat.$encoding));
        // Set document creation and modification timestamp.
        $this->doccreationtimestamp = time();
        $this->docmodificationtimestamp = $this->doccreationtimestamp;
        // Get default graphic vars.
        $this->defaultgraphicvars = $this->getgraphicvars();
        $this->headerxobjautoreset = false;
        $this->customxmp = '';
    }

    /**
     * Default destructor.
     */
    public function __destruct() {
        // Restore internal encoding.
        if (isset($this->internalencoding) AND !empty($this->internalencoding)) {
            mb_internalencoding($this->internalencoding);
        }
        // Unset all class variables.
        $this->_destroy(true);
    }

    /**
     * Return the current TCPDF version.
     * @return TCPDF version string
     * @public
     */
    public function gettcpdfversion() {
        return $this->tcpdfversion;
    }

    /**
     * Set the units of measure for the document.
     */
    public function setpageunit($unit) {
        $unit = strtolower($unit);
        // Set scale factor.
        switch ($unit) {
            // Points.
            case 'px':
            case 'pt': {
                $this->k = 1;
                break;
            }
            // Millimeters.
            case 'mm': {
                $this->k = $this->dpi / 25.4;
                break;
            }
            // Centimeters.
            case 'cm': {
                $this->k = $this->dpi / 2.54;
                break;
            }
            // Inches.
            case 'in': {
                $this->k = $this->dpi;
                break;
            }
            // Unsupported unit.
            default : {
                $this->errord('Incorrect unit: '.$unit);
                break;
            }
        }
        $this->pdfunit = $unit;
        if (isset($this->curcrientation)) {
            $this->setpageorientation($this->curcrientation);
        }
    }

    /**
     * Get page dimensions from format name.
     */
    public function getpagesizefromformat($format) {
        // Paper cordinates are calculated in this way: (inches * 72) where (1 inch = 25.4 mm).
        switch (strtoupper($format)) {
            // ISO 216 A Series + 2 SIS 014711 extensions.
            case 'A0' :
            {
                $pf = array( 2383.937, 3370.394);
                break;
            }
            case 'A1' :
            {
                $pf = array( 1683.780, 2383.937);
                break;
            }
            case 'A2' :
            {
                $pf = array( 1190.551, 1683.780);
                break;
            }
            case 'A3' :
            {
                $pf = array( 841.890, 1190.551);
                break;
            }
            case 'A4' :
            {
                $pf = array( 595.276, 841.890);
                break;
            }
            case 'A5' :
            {
                $pf = array( 419.528, 595.276);
                break;
            }
            case 'A6' :
            {
                $pf = array( 297.638, 419.528);
                break;
            }
            case 'A7' :
            {
                $pf = array( 209.764, 297.638);
                break;
            }
            case 'A8' :
            {
                $pf = array( 147.402, 209.764);
                break;
            }
            case 'A9' :
            {
                $pf = array( 104.882, 147.402);
                break;
            }
            case 'A10':
            {
                $pf = array( 73.701, 104.882);
                break;
            }
            case 'A11':
            {
                $pf = array( 51.024, 73.701);
                break;
            }
            case 'A12':
            {
                $pf = array( 36.850, 51.024);
                break;
            }
            // ISO 216 B Series + 2 SIS 014711 extensions.
            case 'B0' :
            {
                $pf = array( 2834.646, 4008.189);
                break;
            }
            case 'B1' :
            {
                $pf = array( 2004.094, 2834.646);
                break;
            }
            case 'B2' :
            {
                $pf = array( 1417.323, 2004.094);
                break;
            }
            case 'B3' :
            {
                $pf = array( 1000.630, 1417.323);
                break;
            }
            case 'B4' :
            {
                $pf = array( 708.661, 1000.630);
                break;
            }
            case 'B5' :
            {
                $pf = array( 498.898, 708.661);
                break;
            }
            case 'B6' :
            {
                $pf = array( 354.331, 498.898);
                break;
            }
            case 'B7' :
            {
                $pf = array( 249.449, 354.331);
                break;
            }
            case 'B8' :
            {
                $pf = array( 175.748, 249.449);
                break;
            }
            case 'B9' :
            {
                $pf = array( 124.724, 175.748);
                break;
            }
            case 'B10':
            {
                $pf = array( 87.874, 124.724);
                break;
            }
            case 'B11':
            {
                $pf = array( 62.362, 87.874);
                break;
            }
            case 'B12':
            {
                $pf = array( 42.520, 62.362);
                break;
            }
            // ISO 216 C Series + 2 SIS 014711 extensions + 2 EXTENSION.
            case 'C0' :
            {
                $pf = array( 2599.370, 3676.535);
                break;
            }
            case 'C1' :
            {
                $pf = array( 1836.850, 2599.370);
                break;
            }
            case 'C2' :
            {
                $pf = array( 1298.268, 1836.850);
                break;
            }
            case 'C3' :
            {
                $pf = array( 918.425, 1298.268);
                break;
            }
            case 'C4' :
            {
                $pf = array( 649.134, 918.425);
                break;
            }
            case 'C5' :
            {
                $pf = array( 459.213, 649.134);
                break;
            }
            case 'C6' :
            {
                $pf = array( 323.150, 459.213);
                break;
            }
            case 'C7' :
            {
                $pf = array( 229.606, 323.150);
                break;
            }
            case 'C8' :
            {
                $pf = array( 161.575, 229.606);
                break;
            }
            case 'C9' :
            {
                $pf = array( 113.386, 161.575);
                break;
            }
            case 'C10':
            {
                $pf = array( 79.370, 113.386);
                break;
            }
            case 'C11':
            {
                $pf = array( 56.693, 79.370);
                break;
            }
            case 'C12':
            {
                $pf = array( 39.685, 56.693);
                break;
            }
            case 'C76':
            {
                $pf = array( 229.606, 459.213);
                break;
            }
            case 'DL' :
            {
                $pf = array( 311.811, 623.622);
                break;
            }
            // SIS 014711 E Series.
            case 'E0' :
            {
                $pf = array( 2491.654, 3517.795);
                break;
            }
            case 'E1' :
            {
                $pf = array( 1757.480, 2491.654);
                break;
            }
            case 'E2' :
            {
                $pf = array( 1247.244, 1757.480);
                break;
            }
            case 'E3' :
            {
                $pf = array( 878.740, 1247.244);
                break;
            }
            case 'E4' :
            {
                $pf = array( 623.622, 878.740);
                break;
            }
            case 'E5' :
            {
                $pf = array( 439.370, 623.622);
                break;
            }
            case 'E6' :
            {
                $pf = array( 311.811, 439.370);
                break;
            }
            case 'E7' :
            {
                $pf = array( 221.102, 311.811);
                break;
            }
            case 'E8' :
            {
                $pf = array( 155.906, 221.102);
                break;
            }
            case 'E9' :
            {
                $pf = array( 110.551, 155.906);
                break;
            }
            case 'E10':
            {
                $pf = array( 76.535, 110.551);
                break;
            }
            case 'E11':
            {
                $pf = array( 53.858, 76.535);
                break;
            }
            case 'E12':
            {
                $pf = array( 36.850, 53.858);
                break;
            }
            // SIS 014711 G Series.
            case 'G0' :
            {
                $pf = array( 2715.591, 3838.110);
                break;
            }
            case 'G1' :
            {
                $pf = array( 1919.055, 2715.591);
                break;
            }
            case 'G2' :
            {
                $pf = array( 1357.795, 1919.055);
                break;
            }
            case 'G3' :
            {
                $pf = array( 958.110, 1357.795);
                break;
            }
            case 'G4' :
            {
                $pf = array( 677.480, 958.110);
                break;
            }
            case 'G5' :
            {
                $pf = array( 479.055, 677.480);
                break;
            }
            case 'G6' :
            {
                $pf = array( 337.323, 479.055);
                break;
            }
            case 'G7' :
            {
                $pf = array( 238.110, 337.323);
                break;
            }
            case 'G8' :
            {
                $pf = array( 167.244, 238.110);
                break;
            }
            case 'G9' :
            {
                $pf = array( 119.055, 167.244);
                break;
            }
            case 'G10':
            {
                $pf = array( 82.205, 119.055);
                break;
            }
            case 'G11':
            {
                $pf = array( 59.528, 82.205);
                break;
            }
            case 'G12':
            {
                $pf = array( 39.685, 59.528);
                break;
            }
            // ISO Press.
            case 'RA0':
            {
                $pf = array( 2437.795, 3458.268);
                break;
            }
            case 'RA1':
            {
                $pf = array( 1729.134, 2437.795);
                break;
            }
            case 'RA2':
            {
                $pf = array( 1218.898, 1729.134);
                break;
            }
            case 'RA3':
            {
                $pf = array( 864.567, 1218.898);
                break;
            }
            case 'RA4':
            {
                $pf = array( 609.449, 864.567);
                break;
            }
            case 'SRA0':
            {
                $pf = array( 2551.181, 3628.346);
                break;
            }
            case 'SRA1':
            {
                $pf = array( 1814.173, 2551.181);
                break;
            }
            case 'SRA2':
            {
                $pf = array( 1275.591, 1814.173);
                break;
            }
            case 'SRA3':
            {
                $pf = array( 907.087, 1275.591);
                break;
            }
            case 'SRA4':
            {
                $pf = array( 637.795, 907.087);
                break;
            }
            // German  DIN 476.
            case '4A0':
            {
                $pf = array( 4767.874, 6740.787);
                break;
            }
            case '2A0':
            {
                $pf = array( 3370.394, 4767.874);
                break;
            }
            // Variations on the ISO Standard.
            case 'A2_EXTRA' :
            {
                $pf = array( 1261.417, 1754.646);
                break;
            }
            case 'A3+' :
            {
                $pf = array( 932.598, 1369.134);
                break;
            }
            case 'A3_EXTRA' :
            {
                $pf = array( 912.756, 1261.417);
                break;
            }
            case 'A3_SUPER' :
            {
                $pf = array( 864.567, 1440.000);
                break;
            }
            case 'SUPER_A3' :
            {
                $pf = array( 864.567, 1380.472);
                break;
            }
            case 'A4_EXTRA' :
            {
                $pf = array( 666.142, 912.756);
                break;
            }
            case 'A4_SUPER' :
            {
                $pf = array( 649.134, 912.756);
                break;
            }
            case 'SUPER_A4' :
            {
                $pf = array( 643.465, 1009.134);
                break;
            }
            case 'A4_LONG' :
            {
                $pf = array( 595.276, 986.457);
                break;
            }
            case 'F4' :
            {
                $pf = array( 595.276, 935.433);
                break;
            }
            case 'SO_B5_EXTRA':
            {
                $pf = array( 572.598, 782.362);
                break;
            }
            case 'A5_EXTRA' :
            {
                $pf = array( 490.394, 666.142);
                break;
            }
            // ANSI Series.
            case 'ANSI_E':
            {
                $pf = array( 2448.000, 3168.000);
                break;
            }
            case 'ANSI_D':
            {
                $pf = array( 1584.000, 2448.000);
                break;
            }
            case 'ANSI_C':
            {
                $pf = array( 1224.000, 1584.000);
                break;
            }
            case 'ANSI_B':
            {
                $pf = array( 792.000, 1224.000);
                break;
            }
            case 'ANSI_A':
            {
                $pf = array( 612.000, 792.000);
                break;
            }
            // Traditional 'Loose' North American Paper Sizes.
            case 'USLEDGER':
            case 'LEDGER' :
            {
                $pf = array( 1224.000, 792.000);
                break;
            }
            case 'ORGANIZERK':
            case 'BIBLE':
            case 'USTABLOID':
            case 'TABLOID':
            {
                $pf = array( 792.000, 1224.000);
                break;
            }
            case 'ORGANIZERM':
            case 'USLETTER':
            case 'LETTER' :
            {
                $pf = array( 612.000, 792.000);
                break;
            }
            case 'USLEGAL':
            case 'LEGAL' :
            {
                $pf = array( 612.000, 1008.000);
                break;
            }
            case 'GOVERNMENTLETTER':
            case 'GLETTER':
            {
                $pf = array( 576.000, 756.000);
                break;
            }
            case 'JUNIORLEGAL':
            case 'JLEGAL' :
            {
                $pf = array( 576.000, 360.000);
                break;
            }
            // Other North American Paper Sizes.
            case 'QUADDEMY':
            {
                $pf = array( 2520.000, 3240.000);
                break;
            }
            case 'SUPER_B':
            {
                $pf = array( 936.000, 1368.000);
                break;
            }
            case 'QUARTO':
            {
                $pf = array( 648.000, 792.000);
                break;
            }
            case 'GOVERNMENTLEGAL':
            case 'FOLIO':
            {
                $pf = array( 612.000, 936.000);
                break;
            }
            case 'MONARCH':
            case 'EXECUTIVE':
            {
                $pf = array( 522.000, 756.000);
                break;
            }
            case 'ORGANIZERL':
            case 'STATEMENT':
            case 'MEMO':
            {
                $pf = array( 396.000, 612.000);
                break;
            }
            case 'FOOLSCAP':
            {
                $pf = array( 595.440, 936.000);
                break;
            }
            case 'COMPACT':
            {
                $pf = array( 306.000, 486.000);
                break;
            }
            case 'ORGANIZERJ':
            {
                $pf = array( 198.000, 360.000);
                break;
            }
            // Canadian standard CAN 2-9.60M.
            case 'P1':
            {
                $pf = array( 1587.402, 2437.795);
                break;
            }
            case 'P2':
            {
                $pf = array( 1218.898, 1587.402);
                break;
            }
            case 'P3':
            {
                $pf = array( 793.701, 1218.898);
                break;
            }
            case 'P4':
            {
                $pf = array( 609.449, 793.701);
                break;
            }
            case 'P5':
            {
                $pf = array( 396.850, 609.449);
                break;
            }
            case 'P6':
            {
                $pf = array( 303.307, 396.850);
                break;
            }
            // North American Architectural Sizes.
            case 'ARCH_E' :
            {
                $pf = array( 2592.000, 3456.000);
                break;
            }
            case 'ARCH_E1':
            {
                $pf = array( 2160.000, 3024.000);
                break;
            }
            case 'ARCH_D' :
            {
                $pf = array( 1728.000, 2592.000);
                break;
            }
            case 'BROADSHEET':
            case 'ARCH_C' :
            {
                $pf = array( 1296.000, 1728.000);
                break;
            }
            case 'ARCH_B' :
            {
                $pf = array( 864.000, 1296.000);
                break;
            }
            case 'ARCH_A' :
            {
                $pf = array( 648.000, 864.000);
                break;
            }
            // North American Envelope Sizes.
            // Announcement Envelopes.
            case 'ANNENV_A2' :
            {
                $pf = array( 314.640, 414.000);
                break;
            }
            case 'ANNENV_A6' :
            {
                $pf = array( 342.000, 468.000);
                break;
            }
            case 'ANNENV_A7' :
            {
                $pf = array( 378.000, 522.000);
                break;
            }
            case 'ANNENV_A8' :
            {
                $pf = array( 396.000, 584.640);
                break;
            }
            case 'ANNENV_A10' :
            {
                $pf = array( 450.000, 692.640);
                break;
            }
            case 'ANNENV_SLIM':
            {
                $pf = array( 278.640, 638.640);
                break;
            }
            // Commercial Envelopes.
            case 'COMMENV_N6_1/4':
            {
                $pf = array( 252.000, 432.000);
                break;
            }
            case 'COMMENV_N6_3/4':
            {
                $pf = array( 260.640, 468.000);
                break;
            }
            case 'COMMENV_N8' :
            {
                $pf = array( 278.640, 540.000);
                break;
            }
            case 'COMMENV_N9' :
            {
                $pf = array( 278.640, 638.640);
                break;
            }
            case 'COMMENV_N10' :
            {
                $pf = array( 296.640, 684.000);
                break;
            }
            case 'COMMENV_N11' :
            {
                $pf = array( 324.000, 746.640);
                break;
            }
            case 'COMMENV_N12' :
            {
                $pf = array( 342.000, 792.000);
                break;
            }
            case 'COMMENV_N14' :
            {
                $pf = array( 360.000, 828.000);
                break;
            }
            // Catalogue Envelopes.
            case 'CATENV_N1' :
            {
                $pf = array( 432.000, 648.000);
                break;
            }
            case 'CATENV_N1_3/4' :
            {
                $pf = array( 468.000, 684.000);
                break;
            }
            case 'CATENV_N2' :
            {
                $pf = array( 468.000, 720.000);
                break;
            }
            case 'CATENV_N3' :
            {
                $pf = array( 504.000, 720.000);
                break;
            }
            case 'CATENV_N6' :
            {
                $pf = array( 540.000, 756.000);
                break;
            }
            case 'CATENV_N7' :
            {
                $pf = array( 576.000, 792.000);
                break;
            }
            case 'CATENV_N8' :
            {
                $pf = array( 594.000, 810.000);
                break;
            }
            case 'CATENV_N9_1/2' :
            {
                $pf = array( 612.000, 756.000);
                break;
            }
            case 'CATENV_N9_3/4' :
            {
                $pf = array( 630.000, 810.000);
                break;
            }
            case 'CATENV_N10_1/2':
            {
                $pf = array( 648.000, 864.000);
                break;
            }
            case 'CATENV_N12_1/2':
            {
                $pf = array( 684.000, 900.000);
                break;
            }
            case 'CATENV_N13_1/2':
            {
                $pf = array( 720.000, 936.000);
                break;
            }
            case 'CATENV_N14_1/4':
            {
                $pf = array( 810.000, 882.000);
                break;
            }
            case 'CATENV_N14_1/2':
            {
                $pf = array( 828.000, 1044.000);
                break;
            }
            // Japanese (JIS P 0138-61) Standard B-Series.
            case 'JIS_B0' :
            {
                $pf = array( 2919.685, 4127.244);
                break;
            }
            case 'JIS_B1' :
            {
                $pf = array( 2063.622, 2919.685);
                break;
            }
            case 'JIS_B2' :
            {
                $pf = array( 1459.843, 2063.622);
                break;
            }
            case 'JIS_B3' :
            {
                $pf = array( 1031.811, 1459.843);
                break;
            }
            case 'JIS_B4' :
            {
                $pf = array( 728.504, 1031.811);
                break;
            }
            case 'JIS_B5' :
            {
                $pf = array( 515.906, 728.504);
                break;
            }
            case 'JIS_B6' :
            {
                $pf = array( 362.835, 515.906);
                break;
            }
            case 'JIS_B7' :
            {
                $pf = array( 257.953, 362.835);
                break;
            }
            case 'JIS_B8' :
            {
                $pf = array( 181.417, 257.953);
                break;
            }
            case 'JIS_B9' :
            {
                $pf = array( 127.559, 181.417);
                break;
            }
            case 'JIS_B10':
            {
                $pf = array( 90.709, 127.559);
                break;
            }
            case 'JIS_B11':
            {
                $pf = array( 62.362, 90.709);
                break;
            }
            case 'JIS_B12':
            {
                $pf = array( 45.354, 62.362);
                break;
            }
            // PA Series.
            case 'PA0' :
            {
                $pf = array( 2381.102, 3174.803);
                break;
            }
            case 'PA1' :
            {
                $pf = array( 1587.402, 2381.102);
                break;
            }
            case 'PA2' :
            {
                $pf = array( 1190.551, 1587.402);
                break;
            }
            case 'PA3' :
            {
                $pf = array( 793.701, 1190.551);
                break;
            }
            case 'PA4' :
            {
                $pf = array( 595.276, 793.701);
                break;
            }
            case 'PA5' :
            {
                $pf = array( 396.850, 595.276);
                break;
            }
            case 'PA6' :
            {
                $pf = array( 297.638, 396.850);
                break;
            }
            case 'PA7' :
            {
                $pf = array( 198.425, 297.638);
                break;
            }
            case 'PA8' :
            {
                $pf = array( 147.402, 198.425);
                break;
            }
            case 'PA9' :
            {
                $pf = array( 99.213, 147.402);
                break;
            }
            case 'PA10':
            {
                $pf = array( 73.701, 99.213);
                break;
            }
            // Standard Photographic Print Sizes.
            case 'PASSPORT_PHOTO':
            {
                $pf = array( 99.213, 127.559);
                break;
            }
            case 'E' :
            {
                $pf = array( 233.858, 340.157);
                break;
            }
            case 'L':
            case '3R' :
            {
                $pf = array( 252.283, 360.000);
                break;
            }
            case 'KG':
            case '4R' :
            {
                $pf = array( 289.134, 430.866);
                break;
            }
            case '4D' :
            {
                $pf = array( 340.157, 430.866);
                break;
            }
            case '2L':
            case '5R' :
            {
                $pf = array( 360.000, 504.567);
                break;
            }
            case '8P':
            case '6R' :
            {
                $pf = array( 430.866, 575.433);
                break;
            }
            case '6P':
            case '8R' :
            {
                $pf = array( 575.433, 720.000);
                break;
            }
            case '6PW':
            case 'S8R' :
            {
                $pf = array( 575.433, 864.567);
                break;
            }
            case '4P':
            case '10R' :
            {
                $pf = array( 720.000, 864.567);
                break;
            }
            case '4PW':
            case 'S10R':
            {
                $pf = array( 720.000, 1080.000);
                break;
            }
            case '11R' :
            {
                $pf = array( 790.866, 1009.134);
                break;
            }
            case 'S11R' :
            {
                $pf = array( 790.866, 1224.567);
                break;
            }
            case '12R' :
            {
                $pf = array( 864.567, 1080.000);
                break;
            }
            case 'S12R':
            {
                $pf = array( 864.567, 1292.598);
                break;
            }
            // Common Newspaper Sizes.
            case 'NEWSPAPER_BROADSHEET':
            {
                $pf = array( 2125.984, 1700.787);
                break;
            }
            case 'NEWSPAPER_BERLINER' :
            {
                $pf = array( 1332.283, 892.913);
                break;
            }
            case 'NEWSPAPER_TABLOID':
            case 'NEWSPAPER_COMPACT' :
            {
                $pf = array( 1218.898, 793.701);
                break;
            }
            // Business Cards.
            case 'CREDIT_CARD':
            case 'BUSINESS_CARD':
            case 'BUSINESS_CARD_ISO7810':
            {
                $pf = array( 153.014, 242.646);
                break;
            }
            case 'BUSINESS_CARD_ISO216' :
            {
                $pf = array( 147.402, 209.764);
                break;
            }
            case 'BUSINESS_CARD_IT':
            case 'BUSINESS_CARD_UK':
            case 'BUSINESS_CARD_FR':
            case 'BUSINESS_CARD_DE':
            case 'BUSINESS_CARD_ES':
            {
                $pf = array( 155.906, 240.945);
                break;
            }
            case 'BUSINESS_CARD_CA':
            case 'BUSINESS_CARD_US':
            {
                $pf = array( 144.567, 252.283);
                break;
            }
            case 'BUSINESS_CARD_JP' :
            {
                $pf = array( 155.906, 257.953);
                break;
            }
            case 'BUSINESS_CARD_HK' :
            {
                $pf = array( 153.071, 255.118);
                break;
            }
            case 'BUSINESS_CARD_AU':
            case 'BUSINESS_CARD_DK':
            case 'BUSINESS_CARD_SE' :
            {
                $pf = array( 155.906, 255.118);
                break;
            }
            case 'BUSINESS_CARD_RU':
            case 'BUSINESS_CARD_CZ':
            case 'BUSINESS_CARD_FI':
            case 'BUSINESS_CARD_HU':
            case 'BUSINESS_CARD_IL' :
            {
                $pf = array( 141.732, 255.118);
                break;
            }
            // Billboards.
            case '4SHEET' :
            {
                $pf = array( 2880.000, 4320.000);
                break;
            }
            case '6SHEET' :
            {
                $pf = array( 3401.575, 5102.362);
                break;
            }
            case '12SHEET' :
            {
                $pf = array( 8640.000, 4320.000);
                break;
            }
            case '16SHEET' :
            {
                $pf = array( 5760.000, 8640.000);
                break;
            }
            case '32SHEET':
            {
                $pf = array(11520.000, 8640.000);
                break;
            }
            case '48SHEET' :
            {
                $pf = array(17280.000, 8640.000);
                break;
            }
            case '64SHEET' :
            {
                $pf = array(23040.000, 8640.000);
                break;
            }
            case '96SHEET' :
            {
                $pf = array(34560.000, 8640.000);
                break;
            }
            // Old European Sizes.
            // Old Imperial English Sizes.
            case 'EN_EMPEROR' :
            {
                $pf = array( 3456.000, 5184.000);
                break;
            }
            case 'EN_ANTIQUARIAN' :
            {
                $pf = array( 2232.000, 3816.000);
                break;
            }
            case 'EN_GRAND_EAGLE' :
            {
                $pf = array( 2070.000, 3024.000);
                break;
            }
            case 'EN_DOUBLE_ELEPHANT' :
            {
                $pf = array( 1926.000, 2880.000);
                break;
            }
            case 'EN_ATLAS' :
            {
                $pf = array( 1872.000, 2448.000);
                break;
            }
            case 'EN_COLOMBIER' :
            {
                $pf = array( 1692.000, 2484.000);
                break;
            }
            case 'EN_ELEPHANT' :
            {
                $pf = array( 1656.000, 2016.000);
                break;
            }
            case 'EN_DOUBLE_DEMY' :
            {
                $pf = array( 1620.000, 2556.000);
                break;
            }
            case 'EN_IMPERIAL' :
            {
                $pf = array( 1584.000, 2160.000);
                break;
            }
            case 'EN_PRINCESS' :
            {
                $pf = array( 1548.000, 2016.000);
                break;
            }
            case 'EN_CARTRIDGE' :
            {
                $pf = array( 1512.000, 1872.000);
                break;
            }
            case 'EN_DOUBLE_LARGE_POST':
            {
                $pf = array( 1512.000, 2376.000);
                break;
            }
            case 'EN_ROYAL' :
            {
                $pf = array( 1440.000, 1800.000);
                break;
            }
            case 'EN_SHEET':
            case 'EN_HALF_POST':
            {
                $pf = array( 1404.000, 1692.000);
                break;
            }
            case 'EN_SUPER_ROYAL' :
            {
                $pf = array( 1368.000, 1944.000);
                break;
            }
            case 'EN_DOUBLE_POST' :
            {
                $pf = array( 1368.000, 2196.000);
                break;
            }
            case 'EN_MEDIUM' :
            {
                $pf = array( 1260.000, 1656.000);
                break;
            }
            case 'EN_DEMY' :
            {
                $pf = array( 1260.000, 1620.000);
                break;
            }
            case 'EN_LARGE_POST' :
            {
                $pf = array( 1188.000, 1512.000);
                break;
            }
            case 'EN_COPY_DRAUGHT' :
            {
                $pf = array( 1152.000, 1440.000);
                break;
            }
            case 'EN_POST' :
            {
                $pf = array( 1116.000, 1386.000);
                break;
            }
            case 'EN_CROWN' :
            {
                $pf = array( 1080.000, 1440.000);
                break;
            }
            case 'EN_PINCHED_POST' :
            {
                $pf = array( 1062.000, 1332.000);
                break;
            }
            case 'EN_BRIEF' :
            {
                $pf = array( 972.000, 1152.000);
                break;
            }
            case 'EN_FOOLSCAP' :
            {
                $pf = array( 972.000, 1224.000);
                break;
            }
            case 'EN_SMALL_FOOLSCAP' :
            {
                $pf = array( 954.000, 1188.000);
                break;
            }
            case 'EN_POTT' :
            {
                $pf = array( 900.000, 1080.000);
                break;
            }
            // Old Imperial Belgian Sizes.
            case 'BE_GRAND_AIGLE' :
            {
                $pf = array( 1984.252, 2948.031);
                break;
            }
            case 'BE_COLOMBIER' :
            {
                $pf = array( 1757.480, 2409.449);
                break;
            }
            case 'BE_DOUBLE_CARRE':
            {
                $pf = array( 1757.480, 2607.874);
                break;
            }
            case 'BE_ELEPHANT' :
            {
                $pf = array( 1746.142, 2182.677);
                break;
            }
            case 'BE_PETIT_AIGLE' :
            {
                $pf = array( 1700.787, 2381.102);
                break;
            }
            case 'BE_GRAND_JESUS' :
            {
                $pf = array( 1559.055, 2069.291);
                break;
            }
            case 'BE_JESUS' :
            {
                $pf = array( 1530.709, 2069.291);
                break;
            }
            case 'BE_RAISIN' :
            {
                $pf = array( 1417.323, 1842.520);
                break;
            }
            case 'BE_GRAND_MEDIAN':
            {
                $pf = array( 1303.937, 1714.961);
                break;
            }
            case 'BE_DOUBLE_POSTE':
            {
                $pf = array( 1233.071, 1601.575);
                break;
            }
            case 'BE_COQUILLE' :
            {
                $pf = array( 1218.898, 1587.402);
                break;
            }
            case 'BE_PETIT_MEDIAN' :
            {
                $pf = array( 1176.378, 1502.362);
                break;
            }
            case 'BE_RUCHE' :
            {
                $pf = array( 1020.472, 1303.937);
                break;
            }
            case 'BE_PROPATRIA' :
            {
                $pf = array( 977.953, 1218.898);
                break;
            }
            case 'BE_LYS' :
            {
                $pf = array( 898.583, 1125.354);
                break;
            }
            case 'BE_POT' :
            {
                $pf = array( 870.236, 1088.504);
                break;
            }
            case 'BE_ROSETTE' :
            {
                $pf = array( 765.354, 983.622);
                break;
            }
            // Old Imperial French Sizes.
            case 'FR_UNIVERS' :
            {
                $pf = array( 2834.646, 3685.039);
                break;
            }
            case 'FR_DOUBLE_COLOMBIER' :
            {
                $pf = array( 2551.181, 3571.654);
                break;
            }
            case 'FR_GRANDE_MONDE' :
            {
                $pf = array( 2551.181, 3571.654);
                break;
            }
            case 'FR_DOUBLE_SOLEIL' :
            {
                $pf = array( 2267.717, 3401.575);
                break;
            }
            case 'FR_DOUBLE_JESUS' :
            {
                $pf = array( 2154.331, 3174.803);
                break;
            }
            case 'FR_GRAND_AIGLE' :
            {
                $pf = array( 2125.984, 3004.724);
                break;
            }
            case 'FR_PETIT_AIGLE' :
            {
                $pf = array( 1984.252, 2664.567);
                break;
            }
            case 'FR_DOUBLE_RAISIN' :
            {
                $pf = array( 1842.520, 2834.646);
                break;
            }
            case 'FR_JOURNAL' :
            {
                $pf = array( 1842.520, 2664.567);
                break;
            }
            case 'FR_COLOMBIER_AFFICHE':
            {
                $pf = array( 1785.827, 2551.181);
                break;
            }
            case 'FR_DOUBLE_CAVALIER' :
            {
                $pf = array( 1757.480, 2607.874);
                break;
            }
            case 'FR_CLOCHE' :
            {
                $pf = array( 1700.787, 2267.717);
                break;
            }
            case 'FR_SOLEIL' :
            {
                $pf = array( 1700.787, 2267.717);
                break;
            }
            case 'FR_DOUBLE_CARRE' :
            {
                $pf = array( 1587.402, 2551.181);
                break;
            }
            case 'FR_DOUBLE_COQUILLE' :
            {
                $pf = array( 1587.402, 2494.488);
                break;
            }
            case 'FR_JESUS' :
            {
                $pf = array( 1587.402, 2154.331);
                break;
            }
            case 'FR_RAISIN' :
            {
                $pf = array( 1417.323, 1842.520);
                break;
            }
            case 'FR_CAVALIER' :
            {
                $pf = array( 1303.937, 1757.480);
                break;
            }
            case 'FR_DOUBLE_COURONNE' :
            {
                $pf = array( 1303.937, 2040.945);
                break;
            }
            case 'FR_CARRE' :
            {
                $pf = array( 1275.591, 1587.402);
                break;
            }
            case 'FR_COQUILLE' :
            {
                $pf = array( 1247.244, 1587.402);
                break;
            }
            case 'FR_DOUBLE_TELLIERE' :
            {
                $pf = array( 1247.244, 1927.559);
                break;
            }
            case 'FR_DOUBLE_CLOCHE' :
            {
                $pf = array( 1133.858, 1700.787);
                break;
            }
            case 'FR_DOUBLE_POT' :
            {
                $pf = array( 1133.858, 1757.480);
                break;
            }
            case 'FR_ECU' :
            {
                $pf = array( 1133.858, 1474.016);
                break;
            }
            case 'FR_COURONNE' :
            {
                $pf = array( 1020.472, 1303.937);
                break;
            }
            case 'FR_TELLIERE' :
            {
                $pf = array( 963.780, 1247.244);
                break;
            }
            case 'FR_POT' :
            {
                $pf = array( 878.740, 1133.858);
                break;
            }
            // DEFAULT ISO A4.
            default:
            {
                $pf = array( 595.276, 841.890);
                break;
            }
        }
        return $pf;
    }

    /**
     * Change the format of the current page.
     */
    protected function setpageformat($format, $orientation='P') {
        if (!empty($format) AND isset($this->pagedim[$this->page])) {
            // Remove inherited values.
            unset($this->pagedim[$this->page]);
        }
        if (is_string($format)) {
            // Get page measures from format name.
            $pf = $this->getpagesizefromformat($format);
            $this->fwpt = $pf[0];
            $this->fhpt = $pf[1];
        } else {
            // The boundaries of the physical medium on which the page shall be displayed or printed.
            if (isset($format['MediaBox'])) {
                $this->setpageboxes($this->page, 'MediaBox', $format['MediaBox']['llx'], $format['MediaBox']['lly'],
                                    $format['MediaBox']['urx'], $format['MediaBox']['ury'], false);
                $this->fwpt = (($format['MediaBox']['urx'] - $format['MediaBox']['llx']) * $this->k);
                $this->fhpt = (($format['MediaBox']['ury'] - $format['MediaBox']['lly']) * $this->k);
            } else {
                if (isset($format[0]) AND is_numeric($format[0]) AND isset($format[1]) AND is_numeric($format[1])) {
                    $pf = array(($format[0] * $this->k), ($format[1] * $this->k));
                } else {
                    if (!isset($format['format'])) {
                        // Default value.
                        $format['format'] = 'A4';
                    }
                    $pf = $this->getpagesizefromformat($format['format']);
                }
                $this->fwpt = $pf[0];
                $this->fhpt = $pf[1];
                $this->setpageboxes($this->page, 'MediaBox', 0, 0, $this->fwpt, $this->fhpt, true);
            }
            // The visible region of default user space.
            if (isset($format['CropBox'])) {
                $this->setpageboxes($this->page, 'CropBox', $format['CropBox']['llx'], $format['CropBox']['lly'],
                $format['CropBox']['urx'], $format['CropBox']['ury'], false);
            }
            // The region to which the contents of the page shall be clipped when output in a production environment.
            if (isset($format['BleedBox'])) {
                $this->setpageboxes($this->page, 'BleedBox', $format['BleedBox']['llx'], $format['BleedBox']['lly'],
                $format['BleedBox']['urx'], $format['BleedBox']['ury'], false);
            }
            // The intended dimensions of the finished page after trimming.
            if (isset($format['TrimBox'])) {
                $this->setpageboxes($this->page, 'TrimBox', $format['TrimBox']['llx'], $format['TrimBox']['lly'],
                $format['TrimBox']['urx'], $format['TrimBox']['ury'], false);
            }
            // The page's meaningful content (including potential white space).
            if (isset($format['ArtBox'])) {
                $this->setpageboxes($this->page, 'ArtBox', $format['ArtBox']['llx'], $format['ArtBox']['lly'],
                $format['ArtBox']['urx'], $format['ArtBox']['ury'], false);
            }
            // Specify the colours and other visual characteristics that should be used in displaying guidelines on
            // the screen for the various page boundaries.
            if (isset($format['BoxColorInfo'])) {
                $this->pagedim[$this->page]['BoxColorInfo'] = $format['BoxColorInfo'];
            }
            if (isset($format['rotate']) AND (($format['rotate'] % 90) == 0)) {
                // The number of degrees by which the page shall be rotated clockwise when displayed or printed.
                // The value shall be a multiple of 90.
                $this->pagedim[$this->page]['rotate'] = intval($format['rotate']);
            }
            if (isset($format['PZ'])) {
                // The page's preferred zoom (magnification) factor.
                $this->pagedim[$this->page]['PZ'] = floatval($format['PZ']);
            }
            if (isset($format['trans'])) {
                // The style and duration of the visual transition to use when moving from another page to the
                // given page during a presentation.
                if (isset($format['trans']['Dur'])) {
                    // The page's display duration.
                    $this->pagedim[$this->page]['trans']['Dur'] = floatval($format['trans']['Dur']);
                }
                $stansitionstyles = array('Split', 'Blinds', 'Box', 'Wipe', 'Dissolve', 'Glitter', 'R', 'Fly',
                'Push', 'Cover', 'Uncover', 'Fade');
                if (isset($format['trans']['S']) AND in_array($format['trans']['S'], $stansitionstyles)) {
                    // The transition style that shall be used when moving to this page from another during a presentation.
                    $this->pagedim[$this->page]['trans']['S'] = $format['trans']['S'];
                    $valideffect = array('Split', 'Blinds');
                    $validvals = array('H', 'V');
                    if (isset($format['trans']['Dm']) AND in_array($format['trans']['S'], $valideffect) AND
                        in_array($format['trans']['Dm'], $validvals)) {
                        $this->pagedim[$this->page]['trans']['Dm'] = $format['trans']['Dm'];
                    }
                    $valideffect = array('Split', 'Box', 'Fly');
                    $validvals = array('I', 'O');
                    if (isset($format['trans']['M']) AND in_array($format['trans']['S'], $valideffect) AND
                        in_array($format['trans']['M'], $validvals)) {
                        $this->pagedim[$this->page]['trans']['M'] = $format['trans']['M'];
                    }
                    $valideffect = array('Wipe', 'Glitter', 'Fly', 'Cover', 'Uncover', 'Push');
                    if (isset($format['trans']['Di']) AND in_array($format['trans']['S'], $valideffect)) {
                        if (((($format['trans']['Di'] == 90) OR ($format['trans']['Di'] == 180)) AND
                              ($format['trans']['S'] == 'Wipe'))
                            OR (($format['trans']['Di'] == 315) AND ($format['trans']['S'] == 'Glitter'))
                            OR (($format['trans']['Di'] == 0) OR ($format['trans']['Di'] == 270))) {
                            $this->pagedim[$this->page]['trans']['Di'] = intval($format['trans']['Di']);
                        }
                    }
                    if (isset($format['trans']['SS']) AND ($format['trans']['S'] == 'Fly')) {
                        $this->pagedim[$this->page]['trans']['SS'] = floatval($format['trans']['SS']);
                    }
                    if (isset($format['trans']['B']) AND ($format['trans']['B'] === true) AND
                    ($format['trans']['S'] == 'Fly')) {
                        $this->pagedim[$this->page]['trans']['B'] = 'true';
                    }
                } else {
                    $this->pagedim[$this->page]['trans']['S'] = 'R';
                }
                if (isset($format['trans']['D'])) {
                    // The duration of the transition effect, in seconds.
                    $this->pagedim[$this->page]['trans']['D'] = floatval($format['trans']['D']);
                } else {
                    $this->pagedim[$this->page]['trans']['D'] = 1;
                }
            }
        }
        $this->setpageorientation($orientation);
    }

    /**
     * Set page boundaries.
     */
    public function setpageboxes($page, $type, $llx, $lly, $urx, $ury, $points=false) {
        if (!isset($this->pagedim[$page])) {
            // Initialize array.
            $this->pagedim[$page] = array();
        }
        $pageboxes = array('MediaBox', 'CropBox', 'BleedBox', 'TrimBox', 'ArtBox');
        if (!in_array($type, $pageboxes)) {
            return;
        }
        if ($points) {
            $k = 1;
        } else {
            $k = $this->k;
        }
        $this->pagedim[$page][$type]['llx'] = ($llx * $k);
        $this->pagedim[$page][$type]['lly'] = ($lly * $k);
        $this->pagedim[$page][$type]['urx'] = ($urx * $k);
        $this->pagedim[$page][$type]['ury'] = ($ury * $k);
    }

    /**
     * Swap X and Y coordinates of page boxes (change page boxes orientation).
     * @param $page (int) page number
     * @protected
     * @since 5.0.010 (2010-05-17)
     */
    protected function swappageboxcoordinates($page) {
        $pageboxes = array('MediaBox', 'CropBox', 'BleedBox', 'TrimBox', 'ArtBox');
        foreach ($pageboxes as $type) {
            // Swap X and Y coordinates.
            if (isset($this->pagedim[$page][$type])) {
                $tmp = $this->pagedim[$page][$type]['llx'];
                $this->pagedim[$page][$type]['llx'] = $this->pagedim[$page][$type]['lly'];
                $this->pagedim[$page][$type]['lly'] = $tmp;
                $tmp = $this->pagedim[$page][$type]['urx'];
                $this->pagedim[$page][$type]['urx'] = $this->pagedim[$page][$type]['ury'];
                $this->pagedim[$page][$type]['ury'] = $tmp;
            }
        }
    }

    /**
     * Set page orientation.
     */
    public function setpageorientation($orientation, $autopagebreak='', $bottommargin='') {
        if (!isset($this->pagedim[$this->page]['MediaBox'])) {
            // The boundaries of the physical medium on which the page shall be displayed or printed.
            $this->setpageboxes($this->page, 'MediaBox', 0, 0, $this->fwpt, $this->fhpt, true);
        }
        if (!isset($this->pagedim[$this->page]['CropBox'])) {
            // The visible region of default user space.
            $this->setpageboxes($this->page, 'CropBox', $this->pagedim[$this->page]['MediaBox']['llx'],
            $this->pagedim[$this->page]['MediaBox']['lly'], $this->pagedim[$this->page]['MediaBox']['urx'],
            $this->pagedim[$this->page]['MediaBox']['ury'], true);
        }
        if (!isset($this->pagedim[$this->page]['BleedBox'])) {
            // The region to which the contents of the page shall be clipped when output in a production environment.
            $this->setpageboxes($this->page, 'BleedBox', $this->pagedim[$this->page]['CropBox']['llx'],
            $this->pagedim[$this->page]['CropBox']['lly'], $this->pagedim[$this->page]['CropBox']['urx'],
            $this->pagedim[$this->page]['CropBox']['ury'], true);
        }
        if (!isset($this->pagedim[$this->page]['TrimBox'])) {
            // The intended dimensions of the finished page after trimming.
            $this->setpageboxes($this->page, 'TrimBox', $this->pagedim[$this->page]['CropBox']['llx'],
            $this->pagedim[$this->page]['CropBox']['lly'], $this->pagedim[$this->page]['CropBox']['urx'],
            $this->pagedim[$this->page]['CropBox']['ury'], true);
        }
        if (!isset($this->pagedim[$this->page]['ArtBox'])) {
            // The page's meaningful content (including potential white space).
            $this->setpageboxes($this->page, 'ArtBox', $this->pagedim[$this->page]['CropBox']['llx'],
            $this->pagedim[$this->page]['CropBox']['lly'], $this->pagedim[$this->page]['CropBox']['urx'],
            $this->pagedim[$this->page]['CropBox']['ury'], true);
        }
        if (!isset($this->pagedim[$this->page]['rotate'])) {
            // The number of degrees by which the page shall be rotated clockwise when displayed or printed.
            // The value shall be a multiple of 90.
            $this->pagedim[$this->page]['rotate'] = 0;
        }
        if (!isset($this->pagedim[$this->page]['PZ'])) {
            // The page's preferred zoom (magnification) factor.
            $this->pagedim[$this->page]['PZ'] = 1;
        }
        if ($this->fwpt > $this->fhpt) {
            // Landscape.
            $defaultorientation = 'L';
        } else {
            // Portrait.
            $defaultorientation = 'P';
        }
        $validorientations = array('P', 'L');
        if (empty($orientation)) {
            $orientation = $defaultorientation;
        } else {
            $orientation = strtoupper($orientation{0});
        }
        if (in_array($orientation, $validorientations) AND ($orientation != $defaultorientation)) {
            $this->curcrientation = $orientation;
            $this->wpt = $this->fhpt;
            $this->hpt = $this->fwpt;
        } else {
            $this->curcrientation = $defaultorientation;
            $this->wpt = $this->fwpt;
            $this->hpt = $this->fhpt;
        }
        if ((abs($this->pagedim[$this->page]['MediaBox']['urx'] - $this->hpt) < $this->feps) AND
            (abs($this->pagedim[$this->page]['MediaBox']['ury'] - $this->wpt) < $this->feps)) {
            // Swap X and Y coordinates (change page orientation).
            $this->swappageboxcoordinates($this->page);
        }
        $this->w = $this->wpt / $this->k;
        $this->h = $this->hpt / $this->k;
        if ($this->empty_string($autopagebreak)) {
            if (isset($this->autopagebreak)) {
                $autopagebreak = $this->autopagebreak;
            } else {
                $autopagebreak = true;
            }
        }
        if ($this->empty_string($bottommargin)) {
            if (isset($this->bmargin)) {
                $bottommargin = $this->bmargin;
            } else {
                // Default value = 2 cm.
                $bottommargin = 2 * 28.35 / $this->k;
            }
        }
        $this->setautopagebreak($autopagebreak, $bottommargin);
        // Store page dimensions.
        $this->pagedim[$this->page]['w'] = $this->wpt;
        $this->pagedim[$this->page]['h'] = $this->hpt;
        $this->pagedim[$this->page]['wk'] = $this->w;
        $this->pagedim[$this->page]['hk'] = $this->h;
        $this->pagedim[$this->page]['tm'] = $this->tmargin;
        $this->pagedim[$this->page]['bm'] = $bottommargin;
        $this->pagedim[$this->page]['lm'] = $this->lmargin;
        $this->pagedim[$this->page]['rm'] = $this->rmargin;
        $this->pagedim[$this->page]['pb'] = $autopagebreak;
        $this->pagedim[$this->page]['or'] = $this->curcrientation;
        $this->pagedim[$this->page]['olm'] = $this->originallmargin;
        $this->pagedim[$this->page]['orm'] = $this->originalrmargin;
    }

    /**
     * Set regular expression to detect withespaces or word separators.
     * The pattern delimiter must be the forward-slash character "/".
     */
    public function setspacesre($re='/[^\S\xa0]/') {
        $this->respaces = $re;
        $reparts = explode('/', $re);
        // Get pattern parts.
        $this->respace = array();
        if (isset($reparts[1]) AND !empty($reparts[1])) {
            $this->respace['p'] = $reparts[1];
        } else {
            $this->respace['p'] = '[\s]';
        }
        // Set pattern modifiers.
        if (isset($reparts[2]) AND !empty($reparts[2])) {
            $this->respace['m'] = $reparts[2];
        } else {
            $this->respace['m'] = '';
        }
    }

    /**
     * Enable or disable Right-To-Left language mode
     * @public
     * @since 2.0.000 (2008-01-03)
     */
    public function setrtl($enable, $resetx=true) {
        $enable = $enable ? true : false;
        $resetx = ($resetx AND ($enable != $this->rtl));
        $this->rtl = $enable;
        $this->tmprtl = false;
        if ($resetx) {
            $this->ln(0);
        }
    }

    /**
     * Return the RTL status
     * @return boolean
     */
    public function getrtl() {
        return $this->rtl;
    }

    /**
     * Force temporary RTL language direction
     */
    public function settemprtl($mode) {
        $newmode = false;
        switch (strtoupper($mode)) {
            case 'LTR':
            case 'L': {
                if ($this->rtl) {
                    $newmode = 'L';
                }
                break;
            }
            case 'RTL':
            case 'R': {
                if (!$this->rtl) {
                    $newmode = 'R';
                }
                break;
            }
            case false:
            default: {
                $newmode = false;
                break;
            }
        }
        $this->tmprtl = $newmode;
    }

    /**
     * Return the current temporary RTL status
     * @return boolean
     * @public
     * @since 4.8.014 (2009-11-04)
     */
    public function isrtltextdir() {
        return ($this->rtl OR ($this->tmprtl == 'R'));
    }

    /**
     * Set the last cell height.
     * @param $h (float) cell height.
     */
    public function setlasth($h) {
        $this->lasth = $h;
    }

    /**
     * Reset the last cell height.
     * @public
     */
    public function resetlasth() {
        $this->lasth = ($this->fontsize * $this->cellheightratio) + $this->cellpadding['T'] +
                        $this->cellpadding['B'];
    }

    /**
     * Get the last cell height.
     * @return last cell height
     * @public
     */
    public function getlasth() {
        return $this->lasth;
    }

    /**
     * Set the adjusting factor to convert pixels to user units.
     * @since 1.5.2
     */
    public function setimagescale($scale) {
        $this->imgscale = $scale;
    }

    /**
     * Returns the adjusting factor to convert pixels to user units.
     * @return float adjusting factor to convert pixels to user units.
     * @public
     * @since 1.5.2
     */
    public function getimagescale() {
        return $this->imgscale;
    }

    /**
     * Returns an array of page dimensions:
     */
    public function getpagedimensions($pagenum='') {
        if (empty($pagenum)) {
            $pagenum = $this->page;
        }
        return $this->pagedim[$pagenum];
    }

    /**
     * Returns the page width in units.
     * @param $pagenum (int) page number (empty = current page)
     * @return int page width.
     * @public
     * @since 1.5.2
     * @see getpagedimensions()
     */
    public function getpagewidth($pagenum='') {
        if (empty($pagenum)) {
            return $this->w;
        }
        return $this->pagedim[$pagenum]['w'];
    }

    /**
     * Returns the page height in units.
     * @param $pagenum (int) page number (empty = current page)
     * @return int page height.
     *
     * @public
     * @since 1.5.2
     * @see getpagedimensions()
     */
    public function getpageheight($pagenum='') {
        if (empty($pagenum)) {
            return $this->h;
        }
        return $this->pagedim[$pagenum]['h'];
    }

    /**
     * Returns the page break margin.
     * @param $pagenum (int) page number (empty = current page)
     * @return int page break margin.
     * @public
     * @since 1.5.2
     * @see getpagedimensions()
     */
    public function getbreakmargin($pagenum='') {
        if (empty($pagenum)) {
            return $this->bmargin;
        }
        return $this->pagedim[$pagenum]['bm'];
    }

    /**
     * Returns the scale factor (number of points in user unit).
     * @return int scale factor.
     * @public
     * @since 1.5.2
     */
    public function getscalefactor() {
        return $this->k;
    }

    /**
     * Defines the left, top and right margins.
     * @param $left (float) Left margin.
     * @param $top (float) Top margin.
     * @param $right (float) Right margin. Default value is the left one.
     * @param $keepmargins (boolean) if true overwrites the default page margins
     * @public
     * @since 1.0
     * @see setleftmargin(), settopmargin(), setrightmargin(), setautopagebreak()
     */
    public function setmargins($left, $top, $right=-1, $keepmargins=false) {
        // Set left, top and right margins.
        $this->lmargin = $left;
        $this->tmargin = $top;
        if ($right == -1) {
            $right = $left;
        }
        $this->rmargin = $right;
        if ($keepmargins) {
            // Overwrite original values.
            $this->originallmargin = $this->lmargin;
            $this->originalrmargin = $this->rmargin;
        }
    }

    /**
     * Defines the left margin. The method can be called before creating the first page.
       If the current abscissa gets out of page, it is brought back to the margin.
     * @param $margin (float) The margin.
     * @public
     * @since 1.4
     * @see settopmargin(), setrightmargin(), setautopagebreak(), setmargins()
     */
    public function setleftmargin($margin) {
        // Set left margin.
        $this->lmargin = $margin;
        if (($this->page > 0) AND ($this->x < $margin)) {
            $this->x = $margin;
        }
    }

    /**
     * Defines the top margin. The method can be called before creating the first page.
     * @param $margin (float) The margin.
     * @public
     * @since 1.5
     * @see setleftmargin(), setrightmargin(), setautopagebreak(), setmargins()
     */
    public function settopmargin($margin) {
        // Set top margin.
        $this->tmargin = $margin;
        if (($this->page > 0) AND ($this->y < $margin)) {
            $this->y = $margin;
        }
    }

    /**
     * Defines the right margin. The method can be called before creating the first page.
     * @param $margin (float) The margin.
     * @public
     * @since 1.5
     * @see setleftmargin(), settopmargin(), setautopagebreak(), setmargins()
     */
    public function setrightmargin($margin) {
        $this->rmargin = $margin;
        if (($this->page > 0) AND ($this->x > ($this->w - $margin))) {
            $this->x = $this->w - $margin;
        }
    }

    /**
     * Set the same internal cell padding for top, right, bottom, left-
     * @param $pad (float) internal padding.
     * @public
     * @since 2.1.000 (2008-01-09)
     * @see getcellpaddings(), setcellpaddings()
     */
    public function setcellpadding($pad) {
        if ($pad >= 0) {
            $this->cellpadding['L'] = $pad;
            $this->cellpadding['T'] = $pad;
            $this->cellpadding['R'] = $pad;
            $this->cellpadding['B'] = $pad;
        }
    }

    /**
     * Set the internal cell paddings.
     * @param $left (float) left padding
     * @param $top (float) top padding
     * @param $right (float) right padding
     * @param $bottom (float) bottom padding
     * @public
     * @since 5.9.000 (2010-10-03)
     * @see getcellpaddings(), setcellpadding()
     */
    public function setcellpaddings($left='', $top='', $right='', $bottom='') {
        if (($left !== '') AND ($left >= 0)) {
            $this->cellpadding['L'] = $left;
        }
        if (($top !== '') AND ($top >= 0)) {
            $this->cellpadding['T'] = $top;
        }
        if (($right !== '') AND ($right >= 0)) {
            $this->cellpadding['R'] = $right;
        }
        if (($bottom !== '') AND ($bottom >= 0)) {
            $this->cellpadding['B'] = $bottom;
        }
    }

    /**
     * Get the internal cell padding array.
     * @return array of padding values
     * @public
     * @since 5.9.000 (2010-10-03)
     * @see setcellpaddings(), setcellpadding()
     */
    public function getcellpaddings() {
        return $this->cellpadding;
    }

    /**
     * Set the internal cell margins.
     * @param $left (float) left margin
     * @param $top (float) top margin
     * @param $right (float) right margin
     * @param $bottom (float) bottom margin
     * @public
     * @since 5.9.000 (2010-10-03)
     * @see getcellmargins()
     */
    public function setcellmargins($left='', $top='', $right='', $bottom='') {
        if (($left !== '') AND ($left >= 0)) {
            $this->cellmargin['L'] = $left;
        }
        if (($top !== '') AND ($top >= 0)) {
            $this->cellmargin['T'] = $top;
        }
        if (($right !== '') AND ($right >= 0)) {
            $this->cellmargin['R'] = $right;
        }
        if (($bottom !== '') AND ($bottom >= 0)) {
            $this->cellmargin['B'] = $bottom;
        }
    }

    /**
     * Get the internal cell margin array.
     * @return array of margin values
     * @public
     * @since 5.9.000 (2010-10-03)
     * @see setcellmargins()
     */
    public function getcellmargins() {
        return $this->cellmargin;
    }

    /**
     * Adjust the internal cell padding array to take account of the line width.
     */
    protected function adjustcellpadding($brd=0) {
        if (empty($brd)) {
            return;
        }
        if (is_string($brd)) {
            // Convert string to array.
            $slen = strlen($brd);
            $newbrd = array();
            for ($i = 0; $i < $slen; ++$i) {
                $newbrd[$brd[$i]] = true;
            }
            $brd = $newbrd;
        } else if (($brd === 1) OR ($brd === true) OR (is_numeric($brd) AND (intval($brd) > 0))) {
            $brd = array('LRTB' => true);
        }
        if (!is_array($brd)) {
            return;
        }
        // Store current cell padding.
        $cp = $this->cellpadding;
        // Select border mode.
        if (isset($brd['mode'])) {
            $mode = $brd['mode'];
            unset($brd['mode']);
        } else {
            $mode = 'normal';
        }
        // Process borders.
        foreach ($brd as $border => $style) {
            $linewidth = $this->linewidth;
            if (is_array($style) AND isset($style['width'])) {
                // Get border width.
                $linewidth = $style['width'];
            }
            $adj = 0; // Line width inside the cell.
            switch ($mode) {
                case 'ext': {
                    $adj = 0;
                    break;
                }
                case 'int': {
                    $adj = $linewidth;
                    break;
                }
                case 'normal':
                default: {
                    $adj = ($linewidth / 2);
                    break;
                }
            }
            // Correct internal cell padding if required to avoid overlap between text and lines.
            if ((strpos($border, 'T') !== false) AND ($this->cellpadding['T'] < $adj)) {
                $this->cellpadding['T'] = $adj;
            }
            if ((strpos($border, 'R') !== false) AND ($this->cellpadding['R'] < $adj)) {
                $this->cellpadding['R'] = $adj;
            }
            if ((strpos($border, 'B') !== false) AND ($this->cellpadding['B'] < $adj)) {
                $this->cellpadding['B'] = $adj;
            }
            if ((strpos($border, 'L') !== false) AND ($this->cellpadding['L'] < $adj)) {
                $this->cellpadding['L'] = $adj;
            }
        }
        return array('T' => ($this->cellpadding['T'] - $cp['T']), 'R' => ($this->cellpadding['R'] - $cp['R']),
                     'B' => ($this->cellpadding['B'] - $cp['B']), 'L' => ($this->cellpadding['L'] - $cp['L']));
    }

    /**
     * Enables or disables the automatic page breaking mode. When enabling, the second parameter is the distance from the
       bottom of the page that defines the triggering limit. By default, the mode is on and the margin is 2 cm.
     * @see cell(), multicell(), acceptpagebreak()
     */
    public function setautopagebreak($auto, $margin=0) {
        $this->autopagebreak = $auto ? true : false;
        $this->bmargin = $margin;
        $this->pagebreaktrigger = $this->h - $margin;
    }

    /**
     * Return the auto-page-break mode (true or false).
     */
    public function getautopagebreak() {
        return $this->autopagebreak;
    }

    /**
     * Defines the way the document is to be displayed by the viewer.
     */
    public function setdisplaymode($zoom, $layout='SinglePage', $mode='UseNone') {
        if (($zoom == 'fullpage') OR ($zoom == 'fullwidth') OR ($zoom == 'real') OR ($zoom == 'default') OR
           (!is_string($zoom))) {
            $this->zoommode = $zoom;
        } else {
            $this->errord('Incorrect zoom display mode: '.$zoom);
        }
        switch ($layout) {
            case 'default':
            case 'single':
            case 'SinglePage': {
                $this->layoutmode = 'SinglePage';
                break;
            }
            case 'continuous':
            case 'OneColumn': {
                $this->layoutmode = 'OneColumn';
                break;
            }
            case 'two':
            case 'TwoColumnLeft': {
                $this->layoutmode = 'TwoColumnLeft';
                break;
            }
            case 'TwoColumnRight': {
                $this->layoutmode = 'TwoColumnRight';
                break;
            }
            case 'TwoPageLeft': {
                $this->layoutmode = 'TwoPageLeft';
                break;
            }
            case 'TwoPageRight': {
                $this->layoutmode = 'TwoPageRight';
                break;
            }
            default: {
                $this->layoutmode = 'SinglePage';
            }
        }
            switch ($mode) {
                case 'UseNone': {
                    $this->pagemode = 'UseNone';
                    break;
                }
                case 'UseOutlines': {
                    $this->pagemode = 'UseOutlines';
                    break;
                }
                case 'UseThumbs': {
                    $this->pagemode = 'UseThumbs';
                    break;
                }
                case 'FullScreen': {
                    $this->pagemode = 'FullScreen';
                    break;
                }
                case 'UseOC': {
                    $this->pagemode = 'UseOC';
                    break;
                }
                case '': {
                    $this->pagemode = 'UseAttachments';
                    break;
                }
                default: {
                    $this->pagemode = 'UseNone';
                }
            }
    }

    /**
     * Activates or deactivates page compression. When activated, the internal representation of each page is compressed,
       which leads to a compression ratio of about 2 for the resulting document. Compression is on by default.
     * Note: the Zlib extension is required for this feature. If not present, compression will be turned off.
     * @param $compress (boolean) Boolean indicating if compression must be enabled.
     * @public
     * @since 1.4
     */
    public function setcompression($compress=true) {
        if (function_exists('gzcompress')) {
            $this->compress = $compress ? true : false;
        } else {
            $this->compress = false;
        }
    }

    /**
     * Set flag to force sRGB_IEC61966-2.1 black scaled ICC color profile for the whole document.
     * @param $mode (boolean) If true force sRGB output intent.
     * @public
     * @since 5.9.121 (2011-09-28)
     */
    public function setsrgbmode($mode=false) {
        $this->forcesrgb = $mode ? true : false;
    }

    /**
     * Turn on/off Unicode mode for document information dictionary (meta tags).
     * This has effect only when unicode mode is set to false.
     * @param $unicode (boolean) if true set the meta information in Unicode
     * @since 5.9.027 (2010-12-01)
     * @public
     */
    public function setdocinfounicode($unicode=true) {
        $this->docinfounicode = $unicode ? true : false;
    }

    /**
     * Defines the title of the document.
     * @param $title (string) The title.
     * @public
     * @see setauthor(), setcreator(), setkeywords(), setsubject()
     */
    public function settitle($title) {
        $this->title = $title;
    }

    /**
     * Defines the subject of the document.
     * @param $subject (string) The subject.
     * @public
     * @since 1.2
     * @see setauthor(), setcreator(), setkeywords(), settitle()
     */
    public function setsubject($subject) {
        $this->subject = $subject;
    }

    /**
     * Defines the author of the document.
     * @param $author (string) The name of the author.
     * @public
     * @since 1.2
     * @see setcreator(), setkeywords(), setsubject(), settitle()
     */
    public function setauthor($author) {
        $this->author = $author;
    }

    /**
     * Associates keywords with the document, generally in the form 'keyword1 keyword2 ...'.
     * @param $keywords (string) The list of keywords.
     * @public
     * @since 1.2
     * @see setauthor(), setcreator(), setsubject(), settitle()
     */
    public function setkeywords($keywords) {
        $this->keywords = $keywords;
    }

    /**
     * Defines the creator of the document. This is typically the name of the application that generates the PDF.
     * @param $creator (string) The name of the creator.
     * @public
     * @since 1.2
     * @see setauthor(), setkeywords(), setsubject(), settitle()
     */
    public function setcreator($creator) {
        $this->creator = $creator;
    }

    /**
     * This method is automatically called in case of fatal error; it simply outputs the message and halts the execution.
       An inherited class may override it to customize the error handling but should always halt the script, or the resulting
       document would probably be invalid.
     * 2004-06-11 :: Nicola Asuni : changed bold tag with strong
     * @param $msg (string) The error message
     * @public
     * @since 1.0
     */
    public function errord($msg) {
        // Unset all class variables.
        $this->_destroy(true);
        // Exit program and print error.
        die('<strong>TCPDF ERROR: </strong>'.$msg);
    }

    /**
     * This method begins the generation of the PDF document.
     * It is not necessary to call it explicitly because addpage() does it automatically.
     * Note: no page is created by this method
     * @public
     * @since 1.0
     * @see addpage(), close()
     */
    public function open() {
        $this->state = 1;
    }

    /**
     * Terminates the PDF document.
     * It is not necessary to call this method explicitly because output() does it automatically.
     * If the document contains no page, addpage() is called to prevent from getting an invalid document.
     * @public
     * @since 1.0
     * @see open(), output()
     */
    public function close() {
        if ($this->state == 3) {
            return;
        }
        if ($this->page == 0) {
            $this->addpage();
        }
        $this->endlayer();
        if ($this->tcpdflink) {
            // Save current graphic settings.
            $gvars = $this->getgraphicvars();
            $this->setequalcolumns();
            $this->lastpage(true);
            $this->setautopagebreak(false);
            $this->x = 0;
            $this->y = $this->h - (1 / $this->k);
            $this->lmargin = 0;
            $this->_out('q');
            $font = defined('PDF_FONT_NAME_MAIN') ? PDF_FONT_NAME_MAIN : 'helvetica';
            $this->setfont($font, '', 1);
            $this->settextrenderingmode(0, false, false);
            $msg = "\x50\x6f\x77\x65\x72\x65\x64\x20\x62\x79\x20\x54\x43\x50\x44\x46\x20\x28\x77\x77\x77\x2e\x74
                    \x63\x70\x64\x66\x2e\x6f\x72\x67\x29";
            $lnk = "\x68\x74\x74\x70\x3a\x2f\x2f\x77\x77\x77\x2e\x74\x63\x70\x64\x66\x2e\x6f\x72\x67";
            $this->cell(0, 0, $msg, 0, 0, 'L', 0, $lnk, 0, false, 'D', 'B');
            $this->_out('Q');
            // Restore graphic settings.
            $this->setgraphicvars($gvars);
        }
        // Close page.
        $this->endpage();
        // Close document.
        $this->_enddoc();
        // Unset all class variables (except critical ones).
        $this->_destroy(false);
    }

    /**
     * Move pointer at the specified document page and update page dimensions.
     * @param $pnum (int) page number (1 ... numpages)
     * @param $resetmargins (boolean) if true reset left, right, top margins and Y position.
     * @public
     * @since 2.1.000 (2008-01-07)
     * @see getpage(), lastpage(), getnumpages()
     */
    public function setpage($pnum, $resetmargins=false) {
        if (($pnum == $this->page) AND ($this->state == 2)) {
            return;
        }
        if (($pnum > 0) AND ($pnum <= $this->numpages)) {
            $this->state = 2;
            // Save current graphic settings.
            $oldpage = $this->page;
            $this->page = $pnum;
            $this->wpt = $this->pagedim[$this->page]['w'];
            $this->hpt = $this->pagedim[$this->page]['h'];
            $this->w = $this->pagedim[$this->page]['wk'];
            $this->h = $this->pagedim[$this->page]['hk'];
            $this->tmargin = $this->pagedim[$this->page]['tm'];
            $this->bmargin = $this->pagedim[$this->page]['bm'];
            $this->originallmargin = $this->pagedim[$this->page]['olm'];
            $this->originalrmargin = $this->pagedim[$this->page]['orm'];
            $this->autopagebreak = $this->pagedim[$this->page]['pb'];
            $this->curcrientation = $this->pagedim[$this->page]['or'];
            $this->setautopagebreak($this->autopagebreak, $this->bmargin);
            // Restore graphic settings.
            if ($resetmargins) {
                $this->lmargin = $this->pagedim[$this->page]['olm'];
                $this->rmargin = $this->pagedim[$this->page]['orm'];
                $this->sety($this->tmargin);
            } else {
                // Account for booklet mode.
                if ($this->pagedim[$this->page]['olm'] != $this->pagedim[$oldpage]['olm']) {
                    $deltam = $this->pagedim[$this->page]['olm'] - $this->pagedim[$this->page]['orm'];
                    $this->lmargin += $deltam;
                    $this->rmargin -= $deltam;
                }
            }
        } else {
            $this->errord('Wrong page number on setpage() function: '.$pnum);
        }
    }

    /**
     * Reset pointer to the last document page.
     * @param $resetmargins (boolean) if true reset left, right, top margins and Y position.
     * @public
     * @since 2.0.000 (2008-01-04)
     * @see setpage(), getpage(), getnumpages()
     */
    public function lastpage($resetmargins=false) {
        $this->setpage($this->getnumpages(), $resetmargins);
    }

    /**
     * Get current document page number.
     * @return int page number
     * @public
     * @since 2.1.000 (2008-01-07)
     * @see setpage(), lastpage(), getnumpages()
     */
    public function getpage() {
        return $this->page;
    }

    /**
     * Get the total number of insered pages.
     * @return int number of pages
     * @public
     * @since 2.1.000 (2008-01-07)
     * @see setpage(), getpage(), lastpage()
     */
    public function getnumpages() {
        return $this->numpages;
    }

    /**
     * Adds a new TOC (Table Of Content) page to the document.
     * @see addpage(), startpage(), endpage(), endtocpage()
     */
    public function addtocpage($orientation='', $format='', $keepmargins=false) {
        $this->addpage($orientation, $format, $keepmargins, true);
    }

    /**
     * Terminate the current TOC (Table Of Content) page
     * @public
     * @since 5.0.001 (2010-05-06)
     * @see addpage(), startpage(), endpage(), addtocpage()
     */
    public function endtocpage() {
        $this->endpage(true);
    }

    /**
     * Adds a new page to the document. If a page is already present, the footer() method is called first to output
       the footer (if enabled). Then the page is added, the current position set to the top-left corner according to the
       left and top margins (or top-right if in RTL mode), and header() is called to display the header (if enabled).
       The origin of the coordinate system is at the top-left corner (or top-right for RTL) and increasing ordinates go
       downwards.
     * @see startpage(), endpage(), addtocpage(), endtocpage(), getpagesizefromformat(), setpageformat()
     */
    public function addpage($orientation='', $format='', $keepmargins=false, $tocpage=false) {
        if ($this->inxobj) {
            // We are inside an XObject template.
            return;
        }
        if (!isset($this->originallmargin) OR $keepmargins) {
            $this->originallmargin = $this->lmargin;
        }
        if (!isset($this->originalrmargin) OR $keepmargins) {
            $this->originalrmargin = $this->rmargin;
        }
        // Terminate previous page.
        $this->endpage();
        // Start new page.
        $this->startpage($orientation, $format, $tocpage);
    }

    /**
     * Terminate the current page
     * @param $tocpage (boolean) if true set the tocpage state to false (end the page used to display Table Of Content).
     * @public
     * @since 4.2.010 (2008-11-14)
     * @see addpage(), startpage(), addtocpage(), endtocpage()
     */
    public function endpage($tocpage=false) {
        // Check if page is already closed.
        if (($this->page == 0) OR ($this->numpages > $this->page) OR (!$this->pageopen[$this->page])) {
            return;
        }
        // Print page footer.
        $this->setfooter();
        // Close page.
        $this->_endpage();
        // Mark page as closed.
        $this->pageopen[$this->page] = false;
        if ($tocpage) {
            $this->tocpage = false;
        }
    }

    /**
     * Starts a new page to the document. The page must be closed using the endpage() function.
     * The origin of the coordinate system is at the top-left corner and increasing ordinates go downwards.
     * @see addpage(), endpage(), addtocpage(), endtocpage(), getpagesizefromformat(), setpageformat()
     * @public
     */
    public function startpage($orientation='', $format='', $tocpage=false) {
        if ($tocpage) {
            $this->tocpage = true;
        }
        // Move page numbers of documents to be attached.
        if ($this->tocpage) {
            // Move reference to unexistent pages (used for page attachments).
            // Adjust outlines.
            $tmpoutlines = $this->outlines;
            foreach ($tmpoutlines as $key => $outline) {
                if ($outline['p'] > $this->numpages) {
                    $this->outlines[$key]['p'] = ($outline['p'] + 1);
                }
            }
            // Adjust dests.
            $tmpdests = $this->dests;
            foreach ($tmpdests as $key => $dest) {
                if ($dest['p'] > $this->numpages) {
                    $this->dests[$key]['p'] = ($dest['p'] + 1);
                }
            }
            // Adjust links.
            $tmplinks = $this->links;
            foreach ($tmplinks as $key => $link) {
                if ($link[0] > $this->numpages) {
                    $this->links[$key][0] = ($link[0] + 1);
                }
            }
        }
        if ($this->numpages > $this->page) {
            // This page has been already added.
            $this->setpage($this->page + 1);
            $this->sety($this->tmargin);
            return;
        }
        // Start a new page.
        if ($this->state == 0) {
            $this->open();
        }
        ++$this->numpages;
        $this->swapmargins($this->booklet);
        // Save current graphic settings.
        $gvars = $this->getgraphicvars();
        // Start new page.
        $this->_beginpage($orientation, $format);
        // Mark page as open.
        $this->pageopen[$this->page] = true;
        // Restore graphic settings.
        $this->setgraphicvars($gvars);
        // Mark this point.
        $this->setpagemark();
        // Print page header.
        $this->setheader();
        // Restore graphic settings.
        $this->setgraphicvars($gvars);
        // Mark this point.
        $this->setpagemark();
        // Print table header (if any).
        $this->settableheader();
        // Set mark for empty page check.
        $this->emptypagemrk[$this->page] = $this->pagelen[$this->page];
    }

    /**
     * Set start-writing mark on current page stream used to put borders and fills.
     * Borders and fills are always created after content and inserted on the position marked by this method.
     * This function must be called after calling imageq() function for a background image.
     * Background images must be always inserted before calling multicell() or writehtmlcell() or writehtml() functions.
     * @public
     * @since 4.0.016 (2008-07-30)
     */
    public function setpagemark() {
        $this->intmrk[$this->page] = $this->pagelen[$this->page];
        $this->bordermrk[$this->page] = $this->intmrk[$this->page];
        $this->setcontentmark();
    }

    /**
     * Set start-writing mark on selected page.
     * Borders and fills are always created after content and inserted on the position marked by this method.
     * @param $page (int) page number (default is the current page)
     * @protected
     * @since 4.6.021 (2009-07-20)
     */
    protected function setcontentmark($page=0) {
        if ($page <= 0) {
            $page = $this->page;
        }
        if (isset($this->footerlen[$page])) {
            $this->cntmrk[$page] = $this->pagelen[$page] - $this->footerlen[$page];
        } else {
            $this->cntmrk[$page] = $this->pagelen[$page];
        }
    }

    /**
     * Set header data.
     * @param $ln (string) header image logo
     * @param $lw (string) header image logo width in mm
     * @param $ht (string) string to print as title on document header
     * @param $hs (string) string to print on document header
     * @public
     */
    public function setheaderdata($ln='', $lw=0, $ht='', $hs='') {
        $this->headerlogo = $ln;
        $this->headerlogowidth = $lw;
        $this->headertitle = $ht;
        $this->headerstring = $hs;
    }

    /**
     * Returns header data:
     */
    public function getheaderdata() {
        $ret = array();
        $ret['logo'] = $this->headerlogo;
        $ret['logo_width'] = $this->headerlogowidth;
        $ret['title'] = $this->headertitle;
        $ret['string'] = $this->headerstring;
        return $ret;
    }

    /**
     * Set header margin.
     * (minimum distance between header and top page margin)
     * @param $hm (int) distance in user units
     * @public
     */
    public function setheadermargin($hm=10) {
        $this->headermargin = $hm;
    }

    /**
     * Returns header margin in user units.
     * @return float
     * @since 4.0.012 (2008-07-24)
     * @public
     */
    public function getheadermargin() {
        return $this->headermargin;
    }

    /**
     * Set footer margin.
     * (minimum distance between footer and bottom page margin)
     * @param $fm (int) distance in user units
     * @public
     */
    public function setfootermargin($fm=10) {
        $this->footermargin = $fm;
    }

    /**
     * Returns footer margin in user units.
     * @return float
     * @since 4.0.012 (2008-07-24)
     * @public
     */
    public function getfootermargin() {
        return $this->footermargin;
    }
    /**
     * Set a flag to print page header.
     * @param $val (boolean) set to true to print the page header (default), false otherwise.
     * @public
     */
    public function setprintheader($val=true) {
        $this->printheader = $val ? true : false;
    }

    /**
     * Set a flag to print page footer.
     * @param $val (boolean) set to true to print the page footer (default), false otherwise.
     * @public
     */
    public function setprintfooter($val=true) {
        $this->printfooter = $val ? true : false;
    }

    /**
     * Return the right-bottom (or left-bottom for RTL) corner X coordinate of last inserted image
     * @return float
     * @public
     */
    public function getimagerbx() {
        return $this->imgrbx;
    }

    /**
     * Return the right-bottom (or left-bottom for RTL) corner Y coordinate of last inserted image
     * @return float
     * @public
     */
    public function getimagerby() {
        return $this->imgrby;
    }

    /**
     * Reset the xobject template used by header() method.
     * @public
     */
    public function resetheadertemplate() {
        $this->headerxobjid = -1;
    }

    /**
     * Set a flag to automatically reset the xobject template used by header() method at each page.
     * @param $val (boolean) set to true to reset header xobject template at each page, false otherwise.
     * @public
     */
    public function setheadertemplateautoreset($val=true) {
        $this->headerxobjautoreset = $val ? true : false;
    }

    /**
     * This method is used to render the page header.
     * It is automatically called by addpage() and could be overwritten in your own inherited class.
     * @public
     */
    public function header() {
        if ($this->headerxobjid < 0) {
            // Start a new XObject Template.
            $this->headerxobjid = $this->starttemplate($this->w, $this->tmargin);
            $headerfont = $this->getheaderfont();
            $headerdata = $this->getheaderdata();
            $this->y = $this->headermargin;
            if ($this->rtl) {
                $this->x = $this->w - $this->originalrmargin;
            } else {
                $this->x = $this->originallmargin;
            }
            if (($headerdata['logo']) AND ($headerdata['logo'] != K_BLANK_IMAGE)) {
                $imgtype = $this->getimagefiletype(K_PATH_IMAGES.$headerdata['logo']);
                if (($imgtype == 'eps') OR ($imgtype == 'ai')) {
                    $this->imageeps(K_PATH_IMAGES.$headerdata['logo'], '', '', $headerdata['logo_width']);
                } else if ($imgtype == 'svg') {
                    $this->imagesvg(K_PATH_IMAGES.$headerdata['logo'], '', '', $headerdata['logo_width']);
                } else {
                    $this->imageq(K_PATH_IMAGES.$headerdata['logo'], '', '', $headerdata['logo_width']);
                }
                $imgy = $this->getimagerby();
            } else {
                $imgy = $this->y;
            }
            $cellheight = round(($this->cellheightratio * $headerfont[2]) / $this->k, 2);
            // Set starting margin for text data cell.
            if ($this->getrtl()) {
                $headerx = $this->originalrmargin + ($headerdata['logo_width'] * 1.1);
            } else {
                $headerx = $this->originallmargin + ($headerdata['logo_width'] * 1.1);
            }
            $cw = $this->w - $this->originallmargin - $this->originalrmargin - ($headerdata['logo_width'] * 1.1);
            $this->settextcolor(0, 0, 0);
            // Header title.
            $this->setfont($headerfont[0], 'B', $headerfont[2] + 1);
            $this->setx($headerx);
            $this->cell($cw, $cellheight, $headerdata['title'], 0, 1, '', 0, '', 0);
            // Header string.
            $this->setfont($headerfont[0], $headerfont[1], $headerfont[2]);
            $this->setx($headerx);
            $this->multicell($cw, $cellheight, $headerdata['string'], 0, '', 0, 1, '', '', true, 0, false,
                             true, 0, 'T', false);
            // Print an ending header line.
            $this->setlinestyle(array('width' => 0.85 / $this->k, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0,
                                'color' => array(0, 0, 0)));
            $this->sety((2.835 / $this->k) + max($imgy, $this->y));
            if ($this->rtl) {
                $this->setx($this->originalrmargin);
            } else {
                $this->setx($this->originallmargin);
            }
            $this->cell(($this->w - $this->originallmargin - $this->originalrmargin), 0, '', 'T', 0, 'C');
            $this->endtemplate();
        }
        // Print header template.
        $x = 0;
        $dx = 0;
        if (!$this->headerxobjautoreset AND $this->booklet AND (($this->page % 2) == 0)) {
            // Adjust margins for booklet mode.
            $dx = ($this->originallmargin - $this->originalrmargin);
        }
        if ($this->rtl) {
            $x = $this->w + $dx;
        } else {
            $x = 0 + $dx;
        }
        $this->printtemplate($this->headerxobjid, $x, 0, 0, 0, '', '', false);
        if ($this->headerxobjautoreset) {
            // Reset header xobject template at each page.
            $this->headerxobjid = -1;
        }
    }

    /**
     * This method is used to render the page footer.
     * It is automatically called by addpage() and could be overwritten in your own inherited class.
     * @public
     */
    public function footer() {
        $cury = $this->y;
        $this->settextcolor(0, 0, 0);
        // Set style for cell border.
        $linewidth = 0.85 / $this->k;
        $this->setlinestyle(array('width' => $linewidth, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0,
                            'color' => array(0, 0, 0)));
        // Print document barcode.
        $barcode = $this->getbarcode();
        if (!empty($barcode)) {
            $this->ln($linewidth);
            $barcodewidth = round(($this->w - $this->originallmargin - $this->originalrmargin) / 3);
            $style = array(
                'position' => $this->rtl ? 'R' : 'L',
                'align' => $this->rtl ? 'R' : 'L',
                'stretch' => false,
                'fitwidth' => true,
                'cellfitalign' => '',
                'border' => false,
                'padding' => 0,
                'fgcolor' => array(0, 0, 0),
                'bgcolor' => false,
                'text' => false
            );
            $this->write1dbarcode($barcode, 'C128', '', $cury + $linewidth, '', (($this->footermargin / 3) - $linewidth),
                                  0.3, $style, '');
        }
        if (empty($this->pagegroups)) {
            $pagenumtxt = $this->l['w_page'].' '.$this->getaliasnumpage().' / '.$this->getaliasnbpages();
        } else {
            $pagenumtxt = $this->l['w_page'].' '.$this->getpagenumgroupalias().' / '.$this->getpagegroupalias();
        }
        $this->sety($cury);
        // Print page number.
        if ($this->getrtl()) {
            $this->setx($this->originalrmargin);
            $this->cell(0, 0, $pagenumtxt, 'T', 0, 'L');
        } else {
            $this->setx($this->originallmargin);
            $this->cell(0, 0, $this->getaliasrightshift().$pagenumtxt, 'T', 0, 'R');
        }
    }

    /**
     * This method is used to render the page header.
     * @protected
     * @since 4.0.012 (2008-07-24)
     */
    protected function setheader() {
        if (!$this->printheader) {
            return;
        }
        $this->inheader = true;
        $this->setgraphicvars($this->defaultgraphicvars);
        $tempthead = $this->thead;
        $temptheadmargins = $this->theadmargins;
        $lasth = $this->lasth;
        $this->_out('q');
        $this->rmargin = $this->originalrmargin;
        $this->lmargin = $this->originallmargin;
        $this->setcellpadding(0);
        // Set current position.
        if ($this->rtl) {
            $this->setxy($this->originalrmargin, $this->headermargin);
        } else {
            $this->setxy($this->originallmargin, $this->headermargin);
        }
        $this->setfont($this->headerfont[0], $this->headerfont[1], $this->headerfont[2]);
        $this->header();
        // Restore position.
        if ($this->rtl) {
            $this->setxy($this->originalrmargin, $this->tmargin);
        } else {
            $this->setxy($this->originallmargin, $this->tmargin);
        }
        $this->_out('Q');
        $this->lasth = $lasth;
        $this->thead = $tempthead;
        $this->theadmargins = $temptheadmargins;
        $this->newline = false;
        $this->inheader = false;
    }

    /**
     * This method is used to render the page footer.
     * @protected
     * @since 4.0.012 (2008-07-24)
     */
    protected function setfooter() {
        // Page footer.
        $this->infooter = true;
        // Save current graphic settings.
        $gvars = $this->getgraphicvars();
        // Mark this point.
        $this->footerpos[$this->page] = $this->pagelen[$this->page];
        $this->_out("\n");
        if ($this->printfooter) {
            $this->setgraphicvars($this->defaultgraphicvars);
            $this->currentcolumn = 0;
            $this->numcolumns = 1;
            $tempthead = $this->thead;
            $temptheadmargins = $this->theadmargins;
            $lasth = $this->lasth;
            $this->_out('q');
            $this->rmargin = $this->originalrmargin;
            $this->lmargin = $this->originallmargin;
            $this->setcellpadding(0);
            // Set current position.
            $footery = $this->h - $this->footermargin;
            if ($this->rtl) {
                $this->setxy($this->originalrmargin, $footery);
            } else {
                $this->setxy($this->originallmargin, $footery);
            }
            $this->setfont($this->footerfont[0], $this->footerfont[1], $this->footerfont[2]);
            $this->footer();
            // Restore position.
            if ($this->rtl) {
                $this->setxy($this->originalrmargin, $this->tmargin);
            } else {
                $this->setxy($this->originallmargin, $this->tmargin);
            }
            $this->_out('Q');
            $this->lasth = $lasth;
            $this->thead = $tempthead;
            $this->theadmargins = $temptheadmargins;
        }
        // Restore graphic settings.
        $this->setgraphicvars($gvars);
        $this->currentcolumn = $gvars['currentcolumn'];
        $this->numcolumns = $gvars['numcolumns'];
        // Calculate footer length.
        $this->footerlen[$this->page] = $this->pagelen[$this->page] - $this->footerpos[$this->page] + 1;
        $this->infooter = false;
    }

    /**
     * Check if we are on the page body (excluding page header and footer).
     * @return true if we are not in page header nor in page footer, false otherwise.
     * @protected
     * @since 5.9.091 (2011-06-15)
     */
    protected function inpagebody() {
        return (($this->inheader === false) AND ($this->infooter === false));
    }

    /**
     * This method is used to render the table header on new page (if any).
     * @protected
     * @since 4.5.030 (2009-03-25)
     */
    protected function settableheader() {
        if ($this->numcolumns > 1) {
            // Multi column mode.
            return;
        }
        if (isset($this->theadmargins['top'])) {
            // Restore the original top-margin.
            $this->tmargin = $this->theadmargins['top'];
            $this->pagedim[$this->page]['tm'] = $this->tmargin;
            $this->y = $this->tmargin;
        }
        if (!$this->empty_string($this->thead) AND (!$this->inthead)) {
            // Set margins.
            $prevlmargin = $this->lmargin;
            $prevrmargin = $this->rmargin;
            $prevcellpadding = $this->cellpadding;
            $this->lmargin = $this->theadmargins['lmargin'] + ($this->pagedim[$this->page]['olm'] -
                             $this->pagedim[$this->theadmargins['page']]['olm']);
            $this->rmargin = $this->theadmargins['rmargin'] + ($this->pagedim[$this->page]['orm'] -
                             $this->pagedim[$this->theadmargins['page']]['orm']);
            $this->cellpadding = $this->theadmargins['cellpadding'];
            if ($this->rtl) {
                $this->x = $this->w - $this->rmargin;
            } else {
                $this->x = $this->lmargin;
            }
            // Account for special "cell" mode.
            if ($this->theadmargins['cell']) {
                if ($this->rtl) {
                    $this->x -= $this->cellpadding['R'];
                } else {
                    $this->x += $this->cellpadding['L'];
                }
            }
            // Rrint table header.
            $this->writehtml($this->thead, false, false, false, false, '');
            // Set new top margin to skip the table headers.
            if (!isset($this->theadmargins['top'])) {
                $this->theadmargins['top'] = $this->tmargin;
            }
            // Store end of header position.
            if (!isset($this->columns[0]['th'])) {
                $this->columns[0]['th'] = array();
            }
            $this->columns[0]['th']['\''.$this->page.'\''] = $this->y;
            $this->tmargin = $this->y;
            $this->pagedim[$this->page]['tm'] = $this->tmargin;
            $this->lasth = 0;
            $this->lmargin = $prevlmargin;
            $this->rmargin = $prevrmargin;
            $this->cellpadding = $prevcellpadding;
        }
    }

    /**
     * Returns the current page number.
     * @return int page number
     * @public
     * @since 1.0
     * @see getaliasnbpages()
     */
    public function pageno() {
        return $this->page;
    }

    /**
     * Defines a new spot color.
     * It can be expressed in RGB components or gray scale.
     * The method can be called before the first page is created and the value is retained from page to page.
     * @param $name (string) Full name of the spot color.
     * @param $c (float) Cyan color for CMYK. Value between 0 and 100.
     * @param $m (float) Magenta color for CMYK. Value between 0 and 100.
     * @param $y (float) Yellow color for CMYK. Value between 0 and 100.
     * @param $k (float) Key (Black) color for CMYK. Value between 0 and 100.
     * @public
     * @since 4.0.024 (2008-09-12)
     * @see setdrawspotcolor(), setfillspotcolor(), settextspotcolor()
     */
    public function addspotcolor($name, $c, $m, $y, $k) {
        if (!isset($this->spotcolors[$name])) {
            $i = (1 + count($this->spotcolors));
            $this->spotcolors[$name] = array('C' => $c, 'M' => $m, 'Y' => $y, 'K' => $k, 'name' => $name, 'i' => $i);
        }
    }

    /**
     * Return the Spot color array.
     * @param $name (string) Name of the spot color.
     * @return (array) Spot color array or false if not defined.
     * @public
     * @since 5.9.125 (2011-10-03)
     */
    public function getspotcolor($name) {
        if (isset($this->spotcolors[$name])) {
            return $this->spotcolors[$name];
        }
        $color = preg_replace('/[\s]*/', '', $name); // Remove extra spaces.
        $color = strtolower($color);
        if (isset($this->spotcolor[$color])) {
            $this->addspotcolor($this->spotcolor[$color][4], $this->spotcolor[$color][0],
                                $this->spotcolor[$color][1], $this->spotcolor[$color][2], $this->spotcolor[$color][3]);
            return $this->spotcolors[$this->spotcolor[$color][4]];
        }
        return false;
    }

    /**
     * Set the spot color for the specified type ('draw', 'fill', 'text').
     * @param $type (string) Type of object affected by this color: ('draw', 'fill', 'text').
     * @param $name (string) Name of the spot color.
     * @param $tint (float) Intensity of the color (from 0 to 100 ; 100 = full intensity by default).
     * @return (string) PDF color command.
     * @public
     * @since 5.9.125 (2011-10-03)
     */
    public function setspotcolor($type, $name, $tint = 100) {
        $spotcolor = $this->getspotcolor($name);
        if ($spotcolor === false) {
            $this->errord('Undefined spot color: '.$name.', you must add it on the spotcolors.php file.');
        }
        $tint = (max(0, min(100, $tint)) / 100);
        $pdfcolor = sprintf('/CS%d ', $this->spotcolors[$name]['i']);
        switch ($type) {
            case 'draw': {
                $pdfcolor .= sprintf('CS %F SCN', $tint);
                $this->drawcolor = $pdfcolor;
                $this->strokecolor = $spotcolor;
                break;
            }
            case 'fill': {
                $pdfcolor .= sprintf('cs %F scn', $tint);
                $this->fillcolor = $pdfcolor;
                $this->bgcolor = $spotcolor;
                break;
            }
            case 'text': {
                $pdfcolor .= sprintf('cs %F scn', $tint);
                $this->textcolor = $pdfcolor;
                $this->fgcolor = $spotcolor;
                break;
            }
        }
        $this->colorflag = ($this->fillcolor != $this->textcolor);
        if ($this->page > 0) {
            $this->_out($pdfcolor);
        }
        if ($this->inxobj) {
            // We are inside an XObject template.
            $this->xobjects[$this->xobjid]['spotcolors'][$name] = $this->spotcolors[$name];
        }
        return $pdfcolor;
    }

    /**
     * Defines the spot color used for all drawing operations (lines, rectangles and cell borders).
     * @param $name (string) Name of the spot color.
     * @param $tint (float) Intensity of the color (from 0 to 100 ; 100 = full intensity by default).
     * @public
     * @since 4.0.024 (2008-09-12)
     * @see addspotcolor(), setfillspotcolor(), settextspotcolor()
     */
    public function setdrawspotcolor($name, $tint = 100) {
        $this->setspotcolor('draw', $name, $tint);
    }

    /**
     * Defines the spot color used for all filling operations (filled rectangles and cell backgrounds).
     * @param $name (string) Name of the spot color.
     * @param $tint (float) Intensity of the color (from 0 to 100 ; 100 = full intensity by default).
     * @public
     * @since 4.0.024 (2008-09-12)
     * @see addspotcolor(), setdrawspotcolor(), settextspotcolor()
     */
    public function setfillspotcolor($name, $tint = 100) {
        $this->setspotcolor('fill', $name, $tint);
    }

    /**
     * Defines the spot color used for text.
     * @param $name (string) Name of the spot color.
     * @param $tint (int) Intensity of the color (from 0 to 100 ; 100 = full intensity by default).
     * @public
     * @since 4.0.024 (2008-09-12)
     * @see addspotcolor(), setdrawspotcolor(), setfillspotcolor()
     */
    public function settextspotcolor($name, $tint = 100) {
        $this->setspotcolor('text', $name, $tint);
    }

    /**
     * Set the color array for the specified type ('draw', 'fill', 'text').
     * It can be expressed in RGB, CMYK or GRAY SCALE components.
     * The method can be called before the first page is created and the value is retained from page to page.
     * @param $type (string) Type of object affected by this color: ('draw', 'fill', 'text').
     * @param $color (array) Array of colors (1=gray, 3=RGB, 4=CMYK or 5=spotcolor=CMYK+name values).
     * @param $ret (boolean) If true do not send the PDF command.
     * @return (string) The PDF command or empty string.
     * @public
     * @since 3.1.000 (2008-06-11)
     */
    public function setcolorarray($type, $color, $ret = false) {
        if (is_array($color)) {
            $color = array_values($color);
            // Component: grey, RGB red or CMYK cyan.
            $c = isset($color[0]) ? $color[0] : -1;
            // Component: RGB green or CMYK magenta.
            $m = isset($color[1]) ? $color[1] : -1;
            // Component: RGB blue or CMYK yellow.
            $y = isset($color[2]) ? $color[2] : -1;
            // Component: CMYK black.
            $k = isset($color[3]) ? $color[3] : -1;
            // Color name.
            $name = isset($color[4]) ? $color[4] : '';
            if ($c >= 0) {
                return $this->setcolor($type, $c, $m, $y, $k, $ret, $name);
            }
        }
        return '';
    }

    /**
     * Defines the color used for all drawing operations (lines, rectangles and cell borders).
     * It can be expressed in RGB, CMYK or GRAY SCALE components.
     * The method can be called before the first page is created and the value is retained from page to page.
     * @param $color (array) Array of colors (1, 3 or 4 values).
     * @param $ret (boolean) If true do not send the PDF command.
     * @return string the PDF command
     * @public
     * @since 3.1.000 (2008-06-11)
     * @see setdrawcolor()
     */
    public function setdrawcolorarray($color, $ret = false) {
        return $this->setcolorarray('draw', $color, $ret);
    }

    /**
     * Defines the color used for all filling operations (filled rectangles and cell backgrounds).
     * It can be expressed in RGB, CMYK or GRAY SCALE components.
     * The method can be called before the first page is created and the value is retained from page to page.
     * @param $color (array) Array of colors (1, 3 or 4 values).
     * @param $ret (boolean) If true do not send the PDF command.
     * @public
     * @since 3.1.000 (2008-6-11)
     * @see setfillcolor()
     */
    public function setfillcolorarray($color, $ret = false) {
        return $this->setcolorarray('fill', $color, $ret);
    }

    /**
     * Defines the color used for text. It can be expressed in RGB components or gray scale.
     * The method can be called before the first page is created and the value is retained from page to page.
     * @param $color (array) Array of colors (1, 3 or 4 values).
     * @param $ret (boolean) If true do not send the PDF command.
     * @public
     * @since 3.1.000 (2008-6-11)
     * @see setfillcolor()
     */
    public function settextcolorarray($color, $ret = false) {
        return $this->setcolorarray('text', $color, $ret);
    }

    /**
     * Defines the color used by the specified type ('draw', 'fill', 'text').
     * @param $type (string) Type of object affected by this color: ('draw', 'fill', 'text').
     * @param $col1 (float) GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).
     * @param $col2 (float) GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).
     * @param $col3 (float) BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).
     * @param $col4 (float) KEY (BLACK) color for CMYK (0-100).
     * @param $ret (boolean) If true do not send the command.
     * @param $name (string) spot color name (if any)
     * @return (string) The PDF command or empty string.
     * @public
     * @since 5.9.125 (2011-10-03)
     */
    public function setcolor($type, $col1 = 0, $col2 = -1, $col3 = -1, $col4 = -1, $ret = false, $name = '') {
        // Set default values.
        if (!is_numeric($col1)) {
            $col1 = 0;
        }
        if (!is_numeric($col2)) {
            $col2 = -1;
        }
        if (!is_numeric($col3)) {
            $col3 = -1;
        }
        if (!is_numeric($col4)) {
            $col4 = -1;
        }
        // Set color by case.
        $suffix = '';
        if (($col2 == -1) AND ($col3 == -1) AND ($col4 == -1)) {
            // Grey scale.
            $col1 = max(0, min(255, $col1));
            $intcolor = array('G' => $col1);
            $pdfcolor = sprintf('%F ', ($col1 / 255));
            $suffix = 'g';
        } else if ($col4 == -1) {
            // RGB.
            $col1 = max(0, min(255, $col1));
            $col2 = max(0, min(255, $col2));
            $col3 = max(0, min(255, $col3));
            $intcolor = array('R' => $col1, 'G' => $col2, 'B' => $col3);
            $pdfcolor = sprintf('%F %F %F ', ($col1 / 255), ($col2 / 255), ($col3 / 255));
            $suffix = 'rg';
        } else {
            $col1 = max(0, min(100, $col1));
            $col2 = max(0, min(100, $col2));
            $col3 = max(0, min(100, $col3));
            $col4 = max(0, min(100, $col4));
            if (empty($name)) {
                // CMYK.
                $intcolor = array('C' => $col1, 'M' => $col2, 'Y' => $col3, 'K' => $col4);
                $pdfcolor = sprintf('%F %F %F %F ', ($col1 / 100), ($col2 / 100), ($col3 / 100), ($col4 / 100));
                $suffix = 'k';
            } else {
                // SPOT COLOR.
                $intcolor = array('C' => $col1, 'M' => $col2, 'Y' => $col3, 'K' => $col4, 'name' => $name);
                $this->addspotcolor($name, $col1, $col2, $col3, $col4);
                $pdfcolor = $this->setspotcolor($type, $name, 100);
            }
        }
        switch ($type) {
            case 'draw': {
                $pdfcolor .= strtoupper($suffix);
                $this->drawcolor = $pdfcolor;
                $this->strokecolor = $intcolor;
                break;
            }
            case 'fill': {
                $pdfcolor .= $suffix;
                $this->fillcolor = $pdfcolor;
                $this->bgcolor = $intcolor;
                break;
            }
            case 'text': {
                $pdfcolor .= $suffix;
                $this->textcolor = $pdfcolor;
                $this->fgcolor = $intcolor;
                break;
            }
        }
        $this->colorflag = ($this->fillcolor != $this->textcolor);
        if (($type != 'text') AND ($this->page > 0)) {
            if (!$ret) {
                $this->_out($pdfcolor);
            }
            return $pdfcolor;
        }
        return '';
    }

    /**
     * Convert a color array into a string representation.
     * @param $c (array) Array of colors.
     * @return (string) The color array representation.
     * @protected
     * @since 5.9.137 (2011-12-01)
     */
    protected function getcolorstringfromarray($c) {
        $c = array_values($c);
        $color = '[';
        switch (count($c)) {
            case 4: {
                // CMYK.
                $color .= sprintf('%F %F %F %F', (max(0, min(100, floatval($c[0]))) / 100),
                                                 (max(0, min(100, floatval($c[1]))) / 100),
                                                 (max(0, min(100, floatval($c[2]))) / 100),
                                                 (max(0, min(100, floatval($c[3]))) / 100));
                break;
            }
            case 3: {
                // RGB.
                $color .= sprintf('%F %F %F', (max(0, min(255, floatval($c[0]))) / 255),
                                              (max(0, min(255, floatval($c[1]))) / 255),
                                              (max(0, min(255, floatval($c[2]))) / 255));
                break;
            }
            case 1: {
                // Grayscale.
                $color .= sprintf('%F', (max(0, min(255, floatval($c[0]))) / 255));
                break;
            }
        }
        $color .= ']';
        return $color;
    }

    /**
     * Defines the color used for all drawing operations (lines, rectangles and cell borders).
       It can be expressed in RGB components or gray scale. The method can be called before the first page is
       created and the value is retained from page to page.
     * @param $col1 (float) GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).
     * @param $col2 (float) GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).
     * @param $col3 (float) BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).
     * @param $col4 (float) KEY (BLACK) color for CMYK (0-100).
     * @param $ret (boolean) If true do not send the command.
     * @param $name (string) spot color name (if any)
     * @return string the PDF command
     * @public
     * @since 1.3
     * @see setdrawcolorarray(), setfillcolor(), settextcolor(), line(), rect(), cell(), multicell()
     */
    public function setdrawcolor($col1 = 0, $col2 = -1, $col3 = -1, $col4 = -1, $ret = false, $name = '') {
        return $this->setcolor('draw', $col1, $col2, $col3, $col4, $ret, $name);
    }

    /**
     * Defines the color used for all filling operations (filled rectangles and cell backgrounds).
       It can be expressed in RGB components or gray scale. The method can be called before the first page is created
       and the value is retained from page to page.
     * @param $col1 (float) GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).
     * @param $col2 (float) GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).
     * @param $col3 (float) BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).
     * @param $col4 (float) KEY (BLACK) color for CMYK (0-100).
     * @param $ret (boolean) If true do not send the command.
     * @param $name (string) Spot color name (if any).
     * @return (string) The PDF command.
     * @public
     * @since 1.3
     * @see setfillcolorarray(), setdrawcolor(), settextcolor(), rect(), cell(), multicell()
     */
    public function setfillcolor($col1 = 0, $col2 = -1, $col3 = -1, $col4 = -1, $ret = false, $name = '') {
        return $this->setcolor('fill', $col1, $col2, $col3, $col4, $ret, $name);
    }

    /**
     * Defines the color used for text. It can be expressed in RGB components or gray scale.
       The method can be called before the first page is created and the value is retained from page to page.
     * @param $col1 (float) GRAY level for single color, or Red color for RGB (0-255), or CYAN color for CMYK (0-100).
     * @param $col2 (float) GREEN color for RGB (0-255), or MAGENTA color for CMYK (0-100).
     * @param $col3 (float) BLUE color for RGB (0-255), or YELLOW color for CMYK (0-100).
     * @param $col4 (float) KEY (BLACK) color for CMYK (0-100).
     * @param $ret (boolean) If true do not send the command.
     * @param $name (string) Spot color name (if any).
     * @return (string) Empty string.
     * @public
     * @since 1.3
     * @see settextcolorarray(), setdrawcolor(), setfillcolor(), text(), cell(), multicell()
     */
    public function settextcolor($col1 = 0, $col2 = -1, $col3 = -1, $col4 = -1, $ret = false, $name = '') {
        return $this->setcolor('text', $col1, $col2, $col3, $col4, $ret, $name);
    }

    /**
     * Returns the length of a string in user unit. A font must be selected.<br>
     * @param $s (string) The string whose length is to be computed
     * @param $fontname (string) Family font. It can be either a name defined by addfont() or one of the standard families.
       It is also possible to pass an empty string, in that case, the current family is retained.
     */
    public function getstringwidth($s, $fontname = '', $fontstyle = '', $fontsize = 0, $getarray = false) {
        return $this->getarrstringwidth($this->utf8bidi($this->utf8stringtoarray($s), $s, $this->tmprtl),
               $fontname, $fontstyle, $fontsize, $getarray);
    }

    /**
     * Returns the string length of an array of chars in user unit or an array of characters widths.
       A font must be selected.<br>
     * @param $sa (string) The array of chars whose total length is to be computed
     * @param $fontname (string) Family font. It can be either a name defined by addfont() or one of the standard
       families. It is also possible to pass an empty string, in that case, the current family is retained.
     */
    public function getarrstringwidth($sa, $fontname = '', $fontstyle = '', $fontsize = 0, $getarray = false) {
        // Store current values.
        if (!$this->empty_string($fontname)) {
            $prevfontfamily = $this->fontfamily;
            $prevfontstyle = $this->fontstyle;
            $prevfontsizept = $this->fontsizept;
            $this->setfont($fontname, $fontstyle, $fontsize, '', 'default', false);
        }
        // Convert UTF-8 array to Latin1 if required.
        $sa = $this->utf8arrtolatin1($sa);
        $w = 0; // Total width.
        $wa = array(); // Array of characters widths.
        foreach ($sa as $ck => $char) {
            // Character width.
            $cw = $this->getcharwidth($char, isset($sa[($ck + 1)]));
            $wa[] = $cw;
            $w += $cw;
        }
        // Restore previous values.
        if (!$this->empty_string($fontname)) {
            $this->setfont($prevfontfamily, $prevfontstyle, $prevfontsizept, '', 'default', false);
        }
        if ($getarray) {
            return $wa;
        }
        return $w;
    }

    /**
     * Returns the length of the char in user unit for the current font considering current stretching and spacing (tracking).
     * @param $char (int) The char code whose length is to be returned
     * @param $notlast (boolean) set to false for the latest character on string, true otherwise (default)
     * @return float char width
     * @public
     * @since 2.4.000 (2008-03-06)
     */
    public function getcharwidth($char, $notlast=true) {
        // Get raw width.
        $chw = $this->getrawcharwidth($char);
        if (($this->fontspacing != 0) AND $notlast) {
            // Increase/decrease font spacing.
            $chw += $this->fontspacing;
        }
        if ($this->fontstretching != 100) {
            // Fixed stretching mode.
            $chw *= ($this->fontstretching / 100);
        }
        return $chw;
    }

    /**
     * Returns the length of the char in user unit for the current font.
     * @param $char (int) The char code whose length is to be returned
     * @return float char width
     * @public
     * @since 5.9.000 (2010-09-28)
     */
    public function getrawcharwidth($char) {
        if ($char == 173) {
            // SHY character will not be printed.
            return (0);
        }
        if (isset($this->currentfont['cw'][$char])) {
            $w = $this->currentfont['cw'][$char];
        } else if (isset($this->currentfont['dw'])) {
            // Default width.
            $w = $this->currentfont['dw'];
        } else if (isset($this->currentfont['cw'][32])) {
            // Default width.
            $w = $this->currentfont['cw'][32];
        } else {
            $w = 600;
        }
        return ($w * $this->fontsize / 1000);
    }

    /**
     * Returns the numbero of characters in a string.
     * @param $s (string) The input string.
     * @return int number of characters
     * @public
     * @since 2.0.0001 (2008-01-07)
     */
    public function getnumchars($s) {
        if ($this->isunicodefont()) {
            return count($this->utf8stringtoarray($s));
        }
        return strlen($s);
    }

    /**
     * Fill the list of available fonts ($this->fontlist).
     * @protected
     * @since 4.0.013 (2008-07-28)
     */
    protected function getfontslist() {
        $fontsdir = opendir($this->_getfontpath());
        while (($file = readdir($fontsdir)) !== false) {
            if (substr($file, -4) == '.php') {
                array_push($this->fontlist, strtolower(basename($file, '.php')));
            }
        }
        closedir($fontsdir);
    }

    /**
     * Imports a TrueType, Type1, core, or CID0 font and makes it available.
     * It is necessary to generate a font definition file first (read /fonts/utils/README.TXT).
     * The definition file (and the font file itself when embedding) must be present either in the current directory
       or in the one indicated by K_PATH_FONTS if the constant is defined. If it could not be found, the error "Could not
       include font definition file" is generated.
     * @see setfont(), setfontsubsetting()
     */
    public function addfont($family, $style = '', $fontfile = '', $subset = 'default') {
        if ($subset === 'default') {
            $subset = $this->fontsubsetting;
        }
        if ($this->pdfamode) {
            $subset = false;
        }
        if ($this->empty_string($family)) {
            if (!$this->empty_string($this->fontfamily)) {
                $family = $this->fontfamily;
            } else {
                $this->errord('Empty font family');
            }
        }
        // Move embedded styles on $style.
        if (substr($family, -1) == 'I') {
            $style .= 'I';
            $family = substr($family, 0, -1);
        }
        if (substr($family, -1) == 'B') {
            $style .= 'B';
            $family = substr($family, 0, -1);
        }
        // Normalize family name.
        $family = strtolower($family);
        if ((!$this->isunicode) AND ($family == 'arial')) {
            $family = 'helvetica';
        }
        if (($family == 'symbol') OR ($family == 'zapfdingbats')) {
            $style = '';
        }
        if ($this->pdfamode AND (isset($this->corefonts[$family]))) {
            // All fonts must be embedded.
            $family = 'pdfa'.$family;
        }
        $tempstyle = strtoupper($style);
        $style = '';
        // Underline.
        if (strpos($tempstyle, 'U') !== false) {
            $this->underline = true;
        } else {
            $this->underline = false;
        }
        // Line-through (deleted).
        if (strpos($tempstyle, 'D') !== false) {
            $this->linethrough = true;
        } else {
            $this->linethrough = false;
        }
        // Overline.
        if (strpos($tempstyle, 'O') !== false) {
            $this->overline = true;
        } else {
            $this->overline = false;
        }
        // Bold.
        if (strpos($tempstyle, 'B') !== false) {
            $style .= 'B';
        }
        // Oblique.
        if (strpos($tempstyle, 'I') !== false) {
            $style .= 'I';
        }
        $bistyle = $style;
        $fontkey = $family.$style;
        $fontstyle = $style.($this->underline ? 'U' : '').($this->linethrough ? 'D' : '').($this->overline ? 'O' : '');
        $fontdata = array('fontkey' => $fontkey, 'family' => $family, 'style' => $fontstyle);
        // Check if the font has been already added.
        $fb = $this->getfontbuffer($fontkey);
        if ($fb !== false) {
            if ($this->inxobj) {
                // We are inside an XObject template.
                $this->xobjects[$this->xobjid]['fonts'][$fontkey] = $fb['i'];
            }
            return $fontdata;
        }
        if (isset($type)) {
            unset($type);
        }
        if (isset($cw)) {
            unset($cw);
        }
        // Get specified font directory (if any).
        $fontdir = false;
        if (!$this->empty_string($fontfile)) {
            $fontdir = dirname($fontfile);
            if ($this->empty_string($fontdir) OR ($fontdir == '.')) {
                $fontdir = '';
            } else {
                $fontdir .= '/';
            }
        }
        $missingstyle = false; // True when the font style variation is missing.
        // Search and include font file.
        if ($this->empty_string($fontfile) OR (!file_exists($fontfile))) {
            // Build a standard filenames for specified font.
            $tmpfontfile = str_replace(' ', '', $family).strtolower($style).'.php';
            // Search files on various directories.
            if (($fontdir !== false) AND file_exists($fontdir.$tmpfontfile)) {
                $fontfile = $fontdir.$tmpfontfile;
            } else if (file_exists($this->_getfontpath().$tmpfontfile)) {
                $fontfile = $this->_getfontpath().$tmpfontfile;
            } else if (file_exists($tmpfontfile)) {
                $fontfile = $tmpfontfile;
            } else if (!$this->empty_string($style)) {
                $missingstyle = true;
                // Try to remove the style part.
                $tmpfontfile = str_replace(' ', '', $family).'.php';
                if (($fontdir !== false) AND file_exists($fontdir.$tmpfontfile)) {
                    $fontfile = $fontdir.$tmpfontfile;
                } else if (file_exists($this->_getfontpath().$tmpfontfile)) {
                    $fontfile = $this->_getfontpath().$tmpfontfile;
                } else {
                    $fontfile = $tmpfontfile;
                }
            }
        }
        // Include font file.
        if (file_exists($fontfile)) {
            include($fontfile);
        } else {
            $this->errord('Could not include font definition file: '.$family.'');
        }
        // Check font parameters.
        if ((!isset($type)) OR (!isset($cw))) {
            $this->errord('The font definition file has a bad format: '.$fontfile.'');
        }
        // SET default parameters.
        if (!isset($file) OR $this->empty_string($file)) {
            $file = '';
        }
        if (!isset($enc) OR $this->empty_string($enc)) {
            $enc = '';
        }
        if (!isset($cidinfo) OR $this->empty_string($cidinfo)) {
            $cidinfo = array('Registry' => 'Adobe', 'Ordering' => 'Identity', 'Supplement' => 0);
            $cidinfo['uni2cid'] = array();
        }
        if (!isset($ctg) OR $this->empty_string($ctg)) {
            $ctg = '';
        }
        if (!isset($desc) OR $this->empty_string($desc)) {
            $desc = array();
        }
        if (!isset($up) OR $this->empty_string($up)) {
            $up = -100;
        }
        if (!isset($ut) OR $this->empty_string($ut)) {
            $ut = 50;
        }
        if (!isset($cw) OR $this->empty_string($cw)) {
            $cw = array();
        }
        if (!isset($dw) OR $this->empty_string($dw)) {
            // Set default width.
            if (isset($desc['MissingWidth']) AND ($desc['MissingWidth'] > 0)) {
                $dw = $desc['MissingWidth'];
            } else if (isset($cw[32])) {
                $dw = $cw[32];
            } else {
                $dw = 600;
            }
        }
        ++$this->numfonts;
        if ($type == 'core') {
            $name = $this->corefonts[$fontkey];
            $subset = false;
        } else if (($type == 'TrueType') OR ($type == 'Type1')) {
            $subset = false;
        } else if ($type == 'TrueTypeUnicode') {
            $enc = 'Identity-H';
        } else if ($type == 'cidfont0') {
            if ($this->pdfamode) {
                $this->errord('All fonts must be embedded in PDF/A mode!');
            }
        } else {
            $this->errord('Unknow font type: '.$type.'');
        }
        // Set name if unset.
        if (!isset($name) OR empty($name)) {
            $name = $fontkey;
        }
        // Create artificial font style variations if missing (only works with non-embedded fonts).
        if (($type != 'core') AND $missingstyle) {
            // Style variations.
            $styles = array('' => '', 'B' => ',Bold', 'I' => ',Italic', 'BI' => ',BoldItalic');
            $name .= $styles[$bistyle];
            // Artificial bold.
            if (strpos($bistyle, 'B') !== false) {
                if (isset($desc['StemV'])) {
                    // From normal to bold.
                    $desc['StemV'] = round($desc['StemV'] * 1.75);
                } else {
                    // Bold.
                    $desc['StemV'] = 123;
                }
            }
            // Artificial italic.
            if (strpos($bistyle, 'I') !== false) {
                if (isset($desc['ItalicAngle'])) {
                    $desc['ItalicAngle'] -= 11;
                } else {
                    $desc['ItalicAngle'] = -11;
                }
                if (isset($desc['Flags'])) {
                    $desc['Flags'] |= 64;
                } else {
                    $desc['Flags'] = 64;
                }
            }
        }
        // Initialize subsetchars to contain default ASCII values (0-255).
        $subsetchars = array_fill(0, 256, true);
        $this->setfontbuffer($fontkey, array('fontkey' => $fontkey, 'i' => $this->numfonts, 'type' => $type,
                                             'name' => $name, 'desc' => $desc, 'up' => $up, 'ut' => $ut, 'cw' => $cw,
                                             'dw' => $dw, 'enc' => $enc, 'cidinfo' => $cidinfo, 'file' => $file,
                                             'ctg' => $ctg, 'subset' => $subset, 'subsetchars' => $subsetchars));
        if ($this->inxobj) {
            // We are inside an XObject template.
            $this->xobjects[$this->xobjid]['fonts'][$fontkey] = $this->numfonts;
        }
        if (isset($diff) AND (!empty($diff))) {
            // Search existing encodings.
            $d = 0;
            $nb = count($this->diffs);
            for ($i = 1; $i <= $nb; ++$i) {
                if ($this->diffs[$i] == $diff) {
                    $d = $i;
                    break;
                }
            }
            if ($d == 0) {
                $d = $nb + 1;
                $this->diffs[$d] = $diff;
            }
            $this->setfontsubbuffer($fontkey, 'diff', $d);
        }
        if (!$this->empty_string($file)) {
            if (!isset($this->fontfiles[$file])) {
                if ((strcasecmp($type, 'TrueType') == 0) OR (strcasecmp($type, 'TrueTypeUnicode') == 0)) {
                    $this->fontfiles[$file] = array('length1' => $originalsize, 'fontdir' => $fontdir,
                                                    'subset' => $subset, 'fontkeys' => array($fontkey));
                } else if ($type != 'core') {
                    $this->fontfiles[$file] = array('length1' => $size1, 'length2' => $size2,
                                                    'fontdir' => $fontdir, 'subset' => $subset,
                                                    'fontkeys' => array($fontkey));
                }
            } else {
                // Update fontkeys that are sharing this font file.
                $this->fontfiles[$file]['subset'] = ($this->fontfiles[$file]['subset'] AND $subset);
                if (!in_array($fontkey, $this->fontfiles[$file]['fontkeys'])) {
                    $this->fontfiles[$file]['fontkeys'][] = $fontkey;
                }
            }
        }
        return $fontdata;
    }

    /**
     * Sets the font used to print character strings.
     * The font can be either a standard one or a font added via the addfont() method. Standard fonts use
       Windows encoding cp1252 (Western Europe).
     * The method can be called before the first page is created and the font is retained from page to page.
     * If you just wish to change the current font size, it is simpler to call setfontsize().
     * Note: for the standard fonts, the font metric files must be accessible. There are three possibilities for this:
      <ul><li>They are in the current directory (the one where the running script lies)</li>
      <li>They are in one of the directories defined by the include_path parameter</li>
      <li>They are in the directory defined by the K_PATH_FONTS constant</li></ul><br />
     * @public
     * @since 1.0
     * @see addfont(), setfontsize()
     */
    public function setfont($family, $style = '', $size = null, $fontfile = '', $subset = 'default', $out = true) {
        // Select a font; size given in points.
        if ($size === null) {
            $size = $this->fontsizept;
        }
        if ($size < 0) {
            $size = 0;
        }
        // Try to add font (if not already added).
        $fontdata = $this->addfont($family, $style, $fontfile, $subset);
        $this->fontfamily = $fontdata['family'];
        $this->fontstyle = $fontdata['style'];
        $this->currentfont = $this->getfontbuffer($fontdata['fontkey']);
        $this->setfontsize($size, $out);
    }

    /**
     * Defines the size of the current font.
     * @param $size (float) The font size in points.
     * @param $out (boolean) if true output the font size command, otherwise only set the font properties.
     * @public
     * @since 1.0
     * @see setfont()
     */
    public function setfontsize($size, $out=true) {
        // Font size in points.
        $this->fontsizept = $size;
        // Font size in user units.
        $this->fontsize = $size / $this->k;
        // Calculate some font metrics.
        if (isset($this->currentfont['desc']['FontBBox'])) {
            $bbox = explode(' ', substr($this->currentfont['desc']['FontBBox'], 1, -1));
            $fontheight = ((intval($bbox[3]) - intval($bbox[1])) * $size / 1000);
        } else {
            $fontheight = $size * 1.219;
        }
        if (isset($this->currentfont['desc']['Ascent']) AND ($this->currentfont['desc']['Ascent'] > 0)) {
            $fontascent = ($this->currentfont['desc']['Ascent'] * $size / 1000);
        }
        if (isset($this->currentfont['desc']['Descent']) AND ($this->currentfont['desc']['Descent'] <= 0)) {
            $fontdescent = (- $this->currentfont['desc']['Descent'] * $size / 1000);
        }
        if (!isset($fontascent) AND !isset($fontdescent)) {
            // Core font.
            $fontascent = 0.76 * $fontheight;
            $fontdescent = $fontheight - $fontascent;
        } else if (!isset($fontdescent)) {
            $fontdescent = $fontheight - $fontascent;
        } else if (!isset($fontascent)) {
            $fontascent = $fontheight - $fontdescent;
        }
        $this->fontascent = ($fontascent / $this->k);
        $this->fontdescent = ($fontdescent / $this->k);
        if ($out AND ($this->page > 0) AND (isset($this->currentfont['i']))) {
            $this->_out(sprintf('BT /F%d %F Tf ET', $this->currentfont['i'], $this->fontsizept));
        }
    }

    /**
     * Returns the bounding box of the current font in user units.
     * @return array
     * @public
     * @since 5.9.152 (2012-03-23)
     */
    public function getfontbbox() {
        $result = array();
        if (isset($this->currentfont['desc']['FontBBox'])) {
            $bbox = explode(' ', substr($this->currentfont['desc']['FontBBox'], 1, -1));
            foreach ($bbox as $v) {
                $result[] = (intval($v) * $this->fontsize / 1000);
            }
        } else {
            // Find max width.
            if (isset($this->currentfont['desc']['MaxWidth'])) {
                $maxw = (intval($this->currentfont['desc']['MaxWidth']) * $this->fontsize / 1000);
            } else {
                $maxw = 0;
                if (isset($this->currentfont['desc']['MissingWidth'])) {
                    $maxw = max($maxw, $this->currentfont['desc']['MissingWidth']);
                }
                if (isset($this->currentfont['desc']['AvgWidth'])) {
                    $maxw = max($maxw, $this->currentfont['desc']['AvgWidth']);
                }
                if (isset($this->currentfont['dw'])) {
                    $maxw = max($maxw, $this->currentfont['dw']);
                }
                foreach ($this->currentfont['cw'] as $char => $w) {
                    $maxw = max($maxw, $w);
                }
                if ($maxw == 0) {
                    $maxw = 600;
                }
                $maxw = ($maxw * $this->fontsize / 1000);
            }
            $result = array(0, -$this->fontdescent, $maxw, $this->fontascent);
        }
        return $result;
    }

    /**
     * Return the font descent value
     * @param $font (string) font name
     * @param $style (string) font style
     * @param $size (float) The size (in points)
     * @return int font descent
     * @public
     * @since 4.9.003 (2010-03-30)
     */
    public function getfontdescent($font, $style = '', $size = 0) {
        $fontdata = $this->addfont($font, $style);
        $fontinfo = $this->getfontbuffer($fontdata['fontkey']);
        if (isset($fontinfo['desc']['Descent']) AND ($fontinfo['desc']['Descent'] <= 0)) {
            $descent = (- $fontinfo['desc']['Descent'] * $size / 1000);
        } else {
            $descent = 1.219 * 0.24 * $size;
        }
        return ($descent / $this->k);
    }

    /**
     * Return the font ascent value.
     * @param $font (string) font name
     * @param $style (string) font style
     * @param $size (float) The size (in points)
     * @return int font ascent
     * @public
     * @since 4.9.003 (2010-03-30)
     */
    public function getfontascent($font, $style = '', $size = 0) {
        $fontdata = $this->addfont($font, $style);
        $fontinfo = $this->getfontbuffer($fontdata['fontkey']);
        if (isset($fontinfo['desc']['Ascent']) AND ($fontinfo['desc']['Ascent'] > 0)) {
            $ascent = ($fontinfo['desc']['Ascent'] * $size / 1000);
        } else {
            $ascent = 1.219 * 0.76 * $size;
        }
        return ($ascent / $this->k);
    }

    /**
     * Return true in the character is present in the specified font.
     * @param $char (mixed) Character to check (integer value or string)
     * @param $font (string) Font name (family name).
     * @param $style (string) Font style.
     * @return (boolean) true if the char is defined, false otherwise.
     * @public
     * @since 5.9.153 (2012-03-28)
     */
    public function ischardefined($char, $font = '', $style = '') {
        if (is_string($char)) {
            // Get character code.
            $char = $this->utf8stringtoarray($char);
            $char = $char[0];
        }
        if ($this->empty_string($font)) {
            if ($this->empty_string($style)) {
                return (isset($this->currentfont['cw'][intval($char)]));
            }
            $font = $this->fontfamily;
        }
        $fontdata = $this->addfont($font, $style);
        $fontinfo = $this->getfontbuffer($fontdata['fontkey']);
        return (isset($fontinfo['cw'][intval($char)]));
    }

    /**
     * Replace missing font characters on selected font with specified substitutions.
     * @param $text (string) text to process.
     * @param $font (string) Font name (family name).
     * @param $style (string) Font style.
     * @param $subs (array) Array of possible character substitutions. The key is the character to check
      (integer value) and the value is a single intege value or an array of possible substitutes.
     * @return (string) Processed text.
     * @public
     * @since 5.9.153 (2012-03-28)
     */
    public function replacemissingchars($text, $font = '', $style = '', $subs = array()) {
        if (empty($subs)) {
            return $text;
        }
        if ($this->empty_string($font)) {
            $font = $this->fontfamily;
        }
        $fontdata = $this->addfont($font, $style);
        $fontinfo = $this->getfontbuffer($fontdata['fontkey']);
        $uniarr = $this->utf8stringtoarray($text);
        foreach ($uniarr as $k => $chr) {
            if (!isset($fontinfo['cw'][$chr])) {
                // This character is missing on the selected font.
                if (isset($subs[$chr])) {
                    // We have available substitutions.
                    if (is_array($subs[$chr])) {
                        foreach ($subs[$chr] as $s) {
                            if (isset($fontinfo['cw'][$s])) {
                                $uniarr[$k] = $s;
                                break;
                            }
                        }
                    } else if (isset($fontinfo['cw'][$subs[$chr]])) {
                        $uniarr[$k] = $subs[$chr];
                    }
                }
            }
        }
        return $this->uniarrsubstring($this->utf8arraytouniarray($uniarr));
    }

    /**
     * Defines the default monospaced font.
     * @param $font (string) Font name.
     * @public
     * @since 4.5.025
     */
    public function setdefaultmonospacedfont($font) {
        $this->defaultmonospacedfont = $font;
    }

    /**
     * Creates a new internal link and returns its identifier. An internal link is a clickable area which directs to another
       place within the document.<br />
     * The identifier can then be passed to cell(), write(), imageq() or link(). The destination is defined with setlink().
     * @public
     * @since 1.5
     * @see cell(), write(), imageq(), link(), setlink()
     */
    public function addlink() {
        // Create a new internal link.
        $n = count($this->links) + 1;
        $this->links[$n] = array(0, 0);
        return $n;
    }

    /**
     * Defines the page and position a link points to.
     * @param $link (int) The link identifier returned by addlink()
     * @param $y (float) Ordinate of target position; -1 indicates the current position. The default value is 0
       (top of page)
     * @param $page (int) Number of target page; -1 indicates the current page. This is the default value
     * @public
     * @since 1.5
     * @see addlink()
     */
    public function setlink($link, $y = 0, $page = -1) {
        if ($y == -1) {
            $y = $this->y;
        }
        if ($page == -1) {
            $page = $this->page;
        }
        $this->links[$link] = array($page, $y);
    }

    /**
     * Puts a link on a rectangular area of the page.
     * text or image links are generally put via cell(), write() or imageq(), but this method can be useful for
       instance to define a clickable area inside an image.
     * @param $x (float) Abscissa of the upper-left corner of the rectangle
     * @param $y (float) Ordinate of the upper-left corner of the rectangle
     * @param $w (float) Width of the rectangle
     * @param $h (float) Height of the rectangle
     * @param $link (mixed) URL or identifier returned by addlink()
     * @param $spaces (int) number of spaces on the text to link
     * @public
     * @since 1.5
     * @see addlink(), annotation(), cell(), write(), imageq()
     */
    public function link($x, $y, $w, $h, $link, $spaces = 0) {
        $this->annotation($x, $y, $w, $h, $link, array('Subtype' => 'link'), $spaces);
    }

    /**
     * Puts a markup annotation on a rectangular area of the page.
     * !!!!THE ANNOTATION SUPPORT IS NOT YET FULLY IMPLEMENTED !!!!
     * @param $x (float) Abscissa of the upper-left corner of the rectangle
     * @param $y (float) Ordinate of the upper-left corner of the rectangle
     * @param $w (float) Width of the rectangle
     * @param $h (float) Height of the rectangle
     * @param $text (string) annotation text or alternate content
     * @param $opt (array) array of options (see section 8.4 of PDF reference 1.7).
     * @param $spaces (int) number of spaces on the text to link
     * @public
     * @since 4.0.018 (2008-08-06)
     */
    public function annotation($x, $y, $w, $h, $text, $opt=array('Subtype' => 'text'), $spaces = 0) {
        if ($this->inxobj) {
            // Store parameters for later use on template.
            $this->xobjects[$this->xobjid]['annotations'][] = array('x' => $x, 'y' => $y, 'w' => $w, 'h' => $h,
                           'text' => $text, 'opt' => $opt, 'spaces' => $spaces);
            return;
        }
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        // Recalculate coordinates to account for graphic transformations.
        if (isset($this->transfmatrix) AND !empty($this->transfmatrix)) {
            for ($i = $this->transfmatrixkey; $i > 0; --$i) {
                $maxid = count($this->transfmatrix[$i]) - 1;
                for ($j = $maxid; $j >= 0; --$j) {
                    $ctm = $this->transfmatrix[$i][$j];
                    if (isset($ctm['a'])) {
                        $x = $x * $this->k;
                        $y = ($this->h - $y) * $this->k;
                        $w = $w * $this->k;
                        $h = $h * $this->k;
                        // Top left.
                        $xt = $x;
                        $yt = $y;
                        $x1 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];
                        $y1 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];
                        // Top right.
                        $xt = $x + $w;
                        $yt = $y;
                        $x2 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];
                        $y2 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];
                        // Bottom left.
                        $xt = $x;
                        $yt = $y - $h;
                        $x3 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];
                        $y3 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];
                        // Bottom right.
                        $xt = $x + $w;
                        $yt = $y - $h;
                        $x4 = ($ctm['a'] * $xt) + ($ctm['c'] * $yt) + $ctm['e'];
                        $y4 = ($ctm['b'] * $xt) + ($ctm['d'] * $yt) + $ctm['f'];
                        // New coordinates (rectangle area).
                        $x = min($x1, $x2, $x3, $x4);
                        $y = max($y1, $y2, $y3, $y4);
                        $w = (max($x1, $x2, $x3, $x4) - $x) / $this->k;
                        $h = ($y - min($y1, $y2, $y3, $y4)) / $this->k;
                        $x = $x / $this->k;
                        $y = $this->h - ($y / $this->k);
                    }
                }
            }
        }
        if ($this->page <= 0) {
            $page = 1;
        } else {
            $page = $this->page;
        }
        if (!isset($this->pageannots[$page])) {
            $this->pageannots[$page] = array();
        }
        ++$this->n;
        $this->pageannots[$page][] = array('n' => $this->n, 'x' => $x, 'y' => $y, 'w' => $w, 'h' => $h,
                                           'txt' => $text, 'opt' => $opt, 'numspaces' => $spaces);
        if (!$this->pdfamode) {
            if ((($opt['Subtype'] == 'FileAttachment') OR ($opt['Subtype'] == 'Sound')) AND
               (!$this->empty_string($opt['FS'])) AND file_exists($opt['FS']) AND
               (!isset($this->embeddedfiles[basename($opt['FS'])]))) {
                ++$this->n;
                $this->embeddedfiles[basename($opt['FS'])] = array('n' => $this->n, 'file' => $opt['FS']);
            }
        }
        // Add widgets annotation's icons.
        if (isset($opt['mk']['i']) AND file_exists($opt['mk']['i'])) {
            $this->imageq($opt['mk']['i'], '', '', 10, 10, '', '', '', false, 300, '', false, false, 0, false, true);
        }
        if (isset($opt['mk']['ri']) AND file_exists($opt['mk']['ri'])) {
            $this->imageq($opt['mk']['ri'], '', '', 0, 0, '', '', '', false, 300, '', false, false, 0, false, true);
        }
        if (isset($opt['mk']['ix']) AND file_exists($opt['mk']['ix'])) {
            $this->imageq($opt['mk']['ix'], '', '', 0, 0, '', '', '', false, 300, '', false, false, 0, false, true);
        }
    }

    /**
     * Embedd the attached files.
     * @since 4.4.000 (2008-12-07)
     * @protected
     * @see annotation()
     */
    protected function _putembeddedfiles() {
        if ($this->pdfamode) {
            // Embedded files are not allowed in PDF/A mode.
            return;
        }
        reset($this->embeddedfiles);
        foreach ($this->embeddedfiles as $filename => $filedata) {
            $data = file_get_contents($filedata['file']);
            $filter = '';
            if ($this->compress) {
                $data = gzcompress($data);
                $filter = ' /Filter /FlateDecode';
            }
            $stream = $this->_getrawstream($data, $filedata['n']);
            $out = $this->_getobj($filedata['n'])."\n";
            $out .= '<< /Type /EmbeddedFile'.$filter.' /Length '.strlen($stream).' >>';
            $out .= ' stream'."\n".$stream."\n".'endstream';
            $out .= "\n".'endobj';
            $this->_out($out);
        }
    }

    /**
     * Prints a text cell at the specified position.
     * This method allows to place a string precisely on the page.
     * @see cell(), write(), multicell(), writehtml(), writehtmlcell()
     */
    public function text($x, $y, $txt, $fstroke = false, $fclip = false, $ffill = true, $border = 0, $ln = 0,
                         $align = '', $fill = false, $link = '', $stretch = 0, $ignoreminheight = false,
                         $calign = 'T', $valign = 'M', $rtloff = false) {
        $textrendermode = $this->textrendermode;
        $textstrokewidth = $this->textstrokewidth;
        $this->settextrenderingmode($fstroke, $ffill, $fclip);
        $this->setxy($x, $y, $rtloff);
        $this->cell(0, 0, $txt, $border, $ln, $align, $fill, $link, $stretch, $ignoreminheight, $calign, $valign);
        // Restore previous rendering mode.
        $this->textrendermode = $textrendermode;
        $this->textstrokewidth = $textstrokewidth;
    }

    /**
     * Whenever a page break condition is met, the method is called, and the break is issued or not depending on the returned value.
     * The default implementation returns a value according to the mode selected by setautopagebreak().<br />
     * This method is called automatically and should not be called directly by the application.
     * @return boolean
     * @public
     * @since 1.4
     * @see setautopagebreak()
     */
    public function acceptpagebreak() {
        if ($this->numcolumns > 1) {
            // Multi column mode.
            if ($this->currentcolumn < ($this->numcolumns - 1)) {
                // Go to next column.
                $this->selectcolumn($this->currentcolumn + 1);
            } else if ($this->autopagebreak) {
                // Add a new page.
                $this->addpage();
                // Set first column.
                $this->selectcolumn(0);
            }
            // Avoid page breaking from checkpagebreak().
            return false;
        }
        return $this->autopagebreak;
    }

    /**
     * Add page if needed.
     * @param $h (float) cell height. Default value: 0.
     * @param $y (mixed) starting y position, leave empty for current position.
     * @param $addpage (boolean) if true add a page, otherwise only return the true/false state
     * @return boolean true in case of page break, false otherwise.
     * @since 3.2.000 (2008-07-01)
     * @protected
     */
    protected function checkpagebreak($h = 0, $y = '', $addpage = true) {
        if ($this->empty_string($y)) {
            $y = $this->y;
        }
        $currentpage = $this->page;
        if ((($y + $h) > $this->pagebreaktrigger) AND ($this->inpagebody()) AND ($this->acceptpagebreak())) {
            if ($addpage) {
                // Automatic page break.
                $x = $this->x;
                $this->addpage($this->curcrientation);
                $this->y = $this->tmargin;
                $oldpage = $this->page - 1;
                if ($this->rtl) {
                    if ($this->pagedim[$this->page]['orm'] != $this->pagedim[$oldpage]['orm']) {
                        $this->x = $x - ($this->pagedim[$this->page]['orm'] - $this->pagedim[$oldpage]['orm']);
                    } else {
                        $this->x = $x;
                    }
                } else {
                    if ($this->pagedim[$this->page]['olm'] != $this->pagedim[$oldpage]['olm']) {
                        $this->x = $x + ($this->pagedim[$this->page]['olm'] - $this->pagedim[$oldpage]['olm']);
                    } else {
                        $this->x = $x;
                    }
                }
            }
            return true;
        }
        if ($currentpage != $this->page) {
            // Account for columns mode.
            return true;
        }
        return false;
    }

    /**
     * Removes SHY characters from text.
     * Unicode Data:<ul>
     * <li>Name : SOFT HYPHEN, commonly abbreviated as SHY</li>
     * <li>HTML Entity (decimal): "&amp;#173;"</li>
     * <li>HTML Entity (hex): "&amp;#xad;"</li>
     * <li>HTML Entity (named): "&amp;shy;"</li>
     * <li>How to type in Microsoft Windows: [Alt +00AD] or [Alt 0173]</li>
     * <li>UTF-8 (hex): 0xC2 0xAD (c2ad)</li>
     * <li>UTF-8 character: chr(194).chr(173)</li>
     * </ul>
     * @param $txt (string) input string
     * @return string without SHY characters.
     * @public
     * @since (4.5.019) 2009-02-28
     */
    public function removeshy($txt='') {
        $txt = preg_replace('/([\\xc2]{1}[\\xad]{1})/', '', $txt);
        if (!$this->isunicode) {
            $txt = preg_replace('/([\\xad]{1})/', '', $txt);
        }
        return $txt;
    }

    /**
     * Prints a cell (rectangular area) with optional borders, background color and character string.
       The upper-left corner of the cell corresponds to the current position. The text can be aligned or centered.
       After the call, the current position moves to the right or to the next line. It is possible to put a link on the text.
     * If automatic page breaking is enabled and the cell goes beyond the limit, a page break is done before outputting.
     * @see setfont(), setdrawcolor(), setfillcolor(), settextcolor(), setlinewidth(), addlink(), ln(), multicell(),
       write(), setautopagebreak()
     */
    public function cell($w, $h = 0, $txt = '', $border = 0, $ln = 0, $align = '', $fill = false, $link = '',
                         $stretch = 0, $ignoreminheight = false, $calign = 'T', $valign = 'M') {
        $prevcellmargin = $this->cellmargin;
        $prevcellpadding = $this->cellpadding;
        $this->adjustcellpadding($border);
        if (!$ignoreminheight) {
            $mincellheight = ($this->fontsize * $this->cellheightratio) + $this->cellpadding['T'] + $this->cellpadding['B'];
            if ($h < $mincellheight) {
                $h = $mincellheight;
            }
        }
        $this->checkpagebreak($h + $this->cellmargin['T'] + $this->cellmargin['B']);
        $this->_out($this->getcellcode($w, $h, $txt, $border, $ln, $align, $fill, $link, $stretch, true, $calign, $valign));
        $this->cellpadding = $prevcellpadding;
        $this->cellmargin = $prevcellmargin;
    }

    /**
     * Returns the PDF string code to print a cell (rectangular area) with optional borders, background color and
       character string. The upper-left corner of the cell corresponds to the current position. The text can be aligned
       or centered. After the call, the current position moves to the right or to the next line. It is possible to put a
       link on the text.<br />
     * If automatic page breaking is enabled and the cell goes beyond the limit, a page break is done before outputting.
     * @see cell()
     */
    protected function getcellcode($w, $h = 0, $txt = '', $border = 0, $ln = 0, $align = '', $fill = false, $link = '',
                                   $stretch = 0, $ignoreminheight = false, $calign = 'T', $valign = 'M') {
        // Replace 'NO-BREAK SPACE' (U+00A0) character with a simple space.
        $txt = str_replace($this->unichr(160), ' ', $txt);
        $prevcellmargin = $this->cellmargin;
        $prevcellpadding = $this->cellpadding;
        $txt = $this->removeshy($txt);
        $rs = ''; // String to be returned.
        $this->adjustcellpadding($border);
        if (!$ignoreminheight) {
            $mincellheight = ($this->fontsize * $this->cellheightratio) + $this->cellpadding['T'] + $this->cellpadding['B'];
            if ($h < $mincellheight) {
                $h = $mincellheight;
            }
        }
        $k = $this->k;
        // Check page for no-write regions and adapt page margins if necessary.
        list($this->x, $this->y) = $this->checkpageregions($h, $this->x, $this->y);
        if ($this->rtl) {
            $x = $this->x - $this->cellmargin['R'];
        } else {
            $x = $this->x + $this->cellmargin['L'];
        }
        $y = $this->y + $this->cellmargin['T'];
        $prevfontstretching = $this->fontstretching;
        $prevfontspacing = $this->fontspacing;
        // Cell vertical alignment.
        switch ($calign) {
            case 'A': {
                // Font top.
                switch ($valign) {
                    case 'T': {
                        // Top.
                        $y -= $this->cellpadding['T'];
                        break;
                    }
                    case 'B': {
                        // Bottom.
                        $y -= ($h - $this->cellpadding['B'] - $this->fontascent - $this->fontdescent);
                        break;
                    }
                    default:
                    case 'C':
                    case 'M': {
                        // Center.
                        $y -= (($h - $this->fontascent - $this->fontdescent) / 2);
                        break;
                    }
                }
                break;
            }
            case 'L': {
                // Font baseline.
                switch ($valign) {
                    case 'T': {
                        // Top.
                        $y -= ($this->cellpadding['T'] + $this->fontascent);
                        break;
                    }
                    case 'B': {
                        // Bottom.
                        $y -= ($h - $this->cellpadding['B'] - $this->fontdescent);
                        break;
                    }
                    default:
                    case 'C':
                    case 'M': {
                        // Center.
                        $y -= (($h + $this->fontascent - $this->fontdescent) / 2);
                        break;
                    }
                }
                break;
            }
            case 'D': {
                // Font bottom.
                switch ($valign) {
                    case 'T': {
                        // Top.
                        $y -= ($this->cellpadding['T'] + $this->fontascent + $this->fontdescent);
                        break;
                    }
                    case 'B': {
                        // Bottom.
                        $y -= ($h - $this->cellpadding['B']);
                        break;
                    }
                    default:
                    case 'C':
                    case 'M': {
                        // Center.
                        $y -= (($h + $this->fontascent + $this->fontdescent) / 2);
                        break;
                    }
                }
                break;
            }
            case 'B': {
                // Cell bottom.
                $y -= $h;
                break;
            }
            case 'C':
            case 'M': {
                // Cell center.
                $y -= ($h / 2);
                break;
            }
            default:
            case 'T': {
                // Cell top.
                break;
            }
        }
        // Text vertical alignment.
        switch ($valign) {
            case 'T': {
                // Top.
                $yt = $y + $this->cellpadding['T'];
                break;
            }
            case 'B': {
                // Bottom.
                $yt = $y + $h - $this->cellpadding['B'] - $this->fontascent - $this->fontdescent;
                break;
            }
            default:
            case 'C':
            case 'M': {
                // Center.
                $yt = $y + (($h - $this->fontascent - $this->fontdescent) / 2);
                break;
            }
        }
        $basefonty = $yt + $this->fontascent;
        if ($this->empty_string($w) OR ($w <= 0)) {
            if ($this->rtl) {
                $w = $x - $this->lmargin;
            } else {
                $w = $this->w - $this->rmargin - $x;
            }
        }
        $s = '';
        // Fill and borders.
        if (is_string($border) AND (strlen($border) == 4)) {
            // Full border.
            $border = 1;
        }
        if ($fill OR ($border == 1)) {
            if ($fill) {
                $op = ($border == 1) ? 'B' : 'f';
            } else {
                $op = 'S';
            }
            if ($this->rtl) {
                $xk = (($x - $w) * $k);
            } else {
                $xk = ($x * $k);
            }
            $s .= sprintf('%F %F %F %F re %s ', $xk, (($this->h - $y) * $k), ($w * $k), (-$h * $k), $op);
        }
        // Draw borders.
        $s .= $this->getcellborder($x, $y, $w, $h, $border);
        if ($txt != '') {
            $txt2 = $txt;
            if ($this->isunicode) {
                if (($this->currentfont['type'] == 'core') OR ($this->currentfont['type'] == 'TrueType') OR
                    ($this->currentfont['type'] == 'Type1')) {
                    $txt2 = $this->utf8tolatin1($txt2);
                } else {
                    $unicode = $this->utf8stringtoarray($txt); // Array of UTF-8 unicode values.
                    $unicode = $this->utf8bidi($unicode, '', $this->tmprtl);
                    // Replace thai chars (if any).
                    if (defined('K_THAI_TOPCHARS') AND (K_THAI_TOPCHARS == true)) {
                        // Number of chars.
                        $numchars = count($unicode);
                        $longtail = array(0x0e1b, 0x0e1d, 0x0e1f);
                        $lowtail = array(0x0e0e, 0x0e0f);
                        $upvowel = array(0x0e31, 0x0e34, 0x0e35, 0x0e36, 0x0e37);
                        $tonemark = array(0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c);
                        $lowvowel = array(0x0e38, 0x0e39, 0x0e3a);
                        $output = array();
                        for ($i = 0; $i < $numchars; $i++) {
                            if (($unicode[$i] >= 0x0e00) && ($unicode[$i] <= 0x0e5b)) {
                                $ch0 = $unicode[$i];
                                $ch1 = ($i > 0) ? $unicode[($i - 1)] : 0;
                                $ch2 = ($i > 1) ? $unicode[($i - 2)] : 0;
                                $chn = ($i < ($numchars - 1)) ? $unicode[($i + 1)] : 0;
                                if (in_array($ch0, $tonemark)) {
                                    if ($chn == 0x0e33) {
                                        if (in_array($ch1, $longtail)) {
                                            // Tonemark at upper left.
                                            $output[] = $this->replacechar($ch0, (0xf713 + $ch0 - 0x0e48));
                                        } else {
                                            // Tonemark at upper right (normal position).
                                            $output[] = $ch0;
                                        }
                                    } else if (in_array($ch1, $longtail) OR (in_array($ch2, $longtail) AND
                                               in_array($ch1, $lowvowel))) {
                                        // Tonemark at lower left.
                                        $output[] = $this->replacechar($ch0, (0xf705 + $ch0 - 0x0e48));
                                    } else if (in_array($ch1, $upvowel)) {
                                        if (in_array($ch2, $longtail)) {
                                            // Tonemark at upper left.
                                            $output[] = $this->replacechar($ch0, (0xf713 + $ch0 - 0x0e48));
                                        } else {
                                            // Tonemark at upper right (normal position).
                                            $output[] = $ch0;
                                        }
                                    } else {
                                        // Tonemark at lower right.
                                        $output[] = $this->replacechar($ch0, (0xf70a + $ch0 - 0x0e48));
                                    }
                                } else if (($ch0 == 0x0e33) AND (in_array($ch1, $longtail) OR (in_array($ch2, $longtail)
                                      AND in_array($ch1, $tonemark)))) {
                                    if ($this->ischardefined(0xf711) AND $this->ischardefined(0x0e32)) {
                                        $output[] = 0xf711;
                                        $this->currentfont['subsetchars'][0xf711] = true;
                                        $output[] = 0x0e32;
                                        $this->currentfont['subsetchars'][0x0e32] = true;
                                    } else {
                                        $output[] = $ch0;
                                    }
                                } else if (in_array($ch1, $longtail)) {
                                    if ($ch0 == 0x0e31) {
                                        $output[] = $this->replacechar($ch0, 0xf710);
                                    } else if (in_array($ch0, $upvowel)) {
                                        // Lower left.
                                        $output[] = $this->replacechar($ch0, (0xf701 + $ch0 - 0x0e34));
                                    } else if ($ch0 == 0x0e47) {
                                        $output[] = $this->replacechar($ch0, 0xf712);
                                    } else {
                                        // Normal character.
                                        $output[] = $ch0;
                                    }
                                } else if (in_array($ch1, $lowtail) AND in_array($ch0, $lowvowel)) {
                                    // Lower vowel.
                                    $output[] = $this->replacechar($ch0, (0xf718 + $ch0 - 0x0e38));
                                } else if (($ch0 == 0x0e0d) AND in_array($chn, $lowvowel)) {
                                    $output[] = $this->replacechar($ch0, 0xf70f);
                                } else if (($ch0 == 0x0e10) AND in_array($chn, $lowvowel)) {
                                    $output[] = $this->replacechar($ch0, 0xf700);
                                } else {
                                    $output[] = $ch0;
                                }
                            } else {
                                // Non-thai character.
                                $output[] = $unicode[$i];
                            }
                        }
                        $unicode = $output;
                    } // End of K_THAI_TOPCHARS.
                    $txt2 = $this->arrutf8toutf16be($unicode, false);
                }
            }
            $txt2 = $this->_escape($txt2);
            // Get current text width (considering general font stretching and spacing).
            $txwidth = $this->getstringwidth($txt);
            $width = $txwidth;
            // Check for stretch mode.
            if ($stretch > 0) {
                // Calculate ratio between cell width and text width.
                if ($width <= 0) {
                    $ratio = 1;
                } else {
                    $ratio = (($w - $this->cellpadding['L'] - $this->cellpadding['R']) / $width);
                }
                // Check if stretching is required.
                if (($ratio < 1) OR (($ratio > 1) AND (($stretch % 2) == 0))) {
                    // The text will be stretched to fit cell width.
                    if ($stretch > 2) {
                        // Set new character spacing.
                        $this->fontspacing += ($w - $this->cellpadding['L'] - $this->cellpadding['R'] - $width) /
                                           (max(($this->getnumchars($txt) - 1), 1) * ($this->fontstretching / 100));
                    } else {
                        // Set new horizontal stretching.
                        $this->fontstretching *= $ratio;
                    }
                    // Recalculate text width (the text fills the entire cell).
                    $width = $w - $this->cellpadding['L'] - $this->cellpadding['R'];
                    // Reset alignment.
                    $align = '';
                }
            }
            if ($this->fontstretching != 100) {
                // Apply font stretching.
                $rs .= sprintf('BT %F Tz ET ', $this->fontstretching);
            }
            if ($this->fontspacing != 0) {
                // Increase/decrease font spacing.
                $rs .= sprintf('BT %F Tc ET ', ($this->fontspacing * $this->k));
            }
            if ($this->colorflag AND ($this->textrendermode < 4)) {
                $s .= 'q '.$this->textcolor.' ';
            }
            // Rendering mode.
            $s .= sprintf('BT %d Tr %F w ET ', $this->textrendermode, $this->textstrokewidth);
            // Count number of spaces.
            $ns = substr_count($txt, chr(32));
            // Justification.
            $spacewidth = 0;
            if (($align == 'J') AND ($ns > 0)) {
                if ($this->isunicodefont()) {
                    // Get string width without spaces.
                    $width = $this->getstringwidth(str_replace(' ', '', $txt));
                    // Calculate average space width.
                    $spacewidth = -1000 * ($w - $width - $this->cellpadding['L'] - $this->cellpadding['R']) /
                                          ($ns ? $ns : 1) / $this->fontsize;
                    if ($this->fontstretching != 100) {
                        // Word spacing is affected by stretching.
                        $spacewidth /= ($this->fontstretching / 100);
                    }
                    // Set word position to be used with TJ operator.
                    $txt2 = str_replace(chr(0).chr(32), ') '.sprintf('%F', $spacewidth).' (', $txt2);
                    $unicodejustification = true;
                } else {
                    // Get string width.
                    $width = $txwidth;
                    // New space width.
                    $spacewidth = (($w - $width - $this->cellpadding['L'] - $this->cellpadding['R']) /
                                  ($ns ? $ns : 1)) * $this->k;
                    if ($this->fontstretching != 100) {
                        // Word spacing (Tw) is affected by stretching.
                        $spacewidth /= ($this->fontstretching / 100);
                    }
                    // Set word spacing.
                    $rs .= sprintf('BT %F Tw ET ', $spacewidth);
                }
                $width = $w - $this->cellpadding['L'] - $this->cellpadding['R'];
            }
            // Replace carriage return characters.
            $txt2 = str_replace("\r", ' ', $txt2);
            switch ($align) {
                case 'C': {
                    $dx = ($w - $width) / 2;
                    break;
                }
                case 'R': {
                    if ($this->rtl) {
                        $dx = $this->cellpadding['R'];
                    } else {
                        $dx = $w - $width - $this->cellpadding['R'];
                    }
                    break;
                }
                case 'L': {
                    if ($this->rtl) {
                        $dx = $w - $width - $this->cellpadding['L'];
                    } else {
                        $dx = $this->cellpadding['L'];
                    }
                    break;
                }
                case 'J':
                default: {
                    if ($this->rtl) {
                        $dx = $this->cellpadding['R'];
                    } else {
                        $dx = $this->cellpadding['L'];
                    }
                    break;
                }
            }
            if ($this->rtl) {
                $xdx = $x - $dx - $width;
            } else {
                $xdx = $x + $dx;
            }
            $xdk = $xdx * $k;
            // Print text.
            $s .= sprintf('BT %F %F Td [(%s)] TJ ET', $xdk, (($this->h - $basefonty) * $k), $txt2);
            if (isset($uniblock)) {
                // Print overlapping characters as separate string.
                $xshift = 0; // Horizontal shift.
                $ty = (($this->h - $basefonty + (0.2 * $this->fontsize)) * $k);
                $spw = (($w - $txwidth - $this->cellpadding['L'] - $this->cellpadding['R']) / ($ns ? $ns : 1));
                foreach ($uniblock as $uk => $uniarr) {
                    if (($uk % 2) == 0) {
                        // X space to skip.
                        if ($spacewidth != 0) {
                            // Justification shift.
                            $xshift += (count(array_keys($uniarr, 32)) * $spw);
                        }
                        $xshift += $this->getarrstringwidth($uniarr);
                    } else {
                        // Character to print.
                        $topchr = $this->arrutf8toutf16be($uniarr, false);
                        $topchr = $this->_escape($topchr);
                        $s .= sprintf(' BT %F %F Td [(%s)] TJ ET', ($xdk + ($xshift * $k)), $ty, $topchr);
                    }
                }
            }
            if ($this->underline) {
                $s .= ' '.$this->_dounderlinew($xdx, $basefonty, $width);
            }
            if ($this->linethrough) {
                $s .= ' '.$this->_dolinethroughw($xdx, $basefonty, $width);
            }
            if ($this->overline) {
                $s .= ' '.$this->_dooverlinew($xdx, $basefonty, $width);
            }
            if ($this->colorflag AND ($this->textrendermode < 4)) {
                $s .= ' Q';
            }
            if ($link) {
                $this->link($xdx, $yt, $width, ($this->fontascent + $this->fontdescent), $link, $ns);
            }
        }
        // Output cell..
        if ($s) {
            // Output cell.
            $rs .= $s;
            if ($this->fontspacing != 0) {
                // Reset font spacing mode.
                $rs .= ' BT 0 Tc ET';
            }
            if ($this->fontstretching != 100) {
                // Reset font stretching mode.
                $rs .= ' BT 100 Tz ET';
            }
        }
        // Reset word spacing.
        if (!$this->isunicodefont() AND ($align == 'J')) {
            $rs .= ' BT 0 Tw ET';
        }
        // Reset stretching and spacing.
        $this->fontstretching = $prevfontstretching;
        $this->fontspacing = $prevfontspacing;
        $this->lasth = $h;
        if ($ln > 0) {
            // Go to the beginning of the next line.
            $this->y = $y + $h + $this->cellmargin['B'];
            if ($ln == 1) {
                if ($this->rtl) {
                    $this->x = $this->w - $this->rmargin;
                } else {
                    $this->x = $this->lmargin;
                }
            }
        } else {
            // Go left or right by case.
            if ($this->rtl) {
                $this->x = $x - $w - $this->cellmargin['L'];
            } else {
                $this->x = $x + $w + $this->cellmargin['R'];
            }
        }
        $gstyles = ''.$this->linestylewidth.' '.$this->linestylecap.' '.$this->linestylejoin.' '.$this->linestyledash.'
                    '.$this->drawcolor.' '.$this->fillcolor."\n";
        $rs = $gstyles.$rs;
        $this->cellpadding = $prevcellpadding;
        $this->cellmargin = $prevcellmargin;
        return $rs;
    }

    /**
     * Replace a char if is defined on the current font.
     * @param $oldchar (int) Integer code (unicode) of the character to replace.
     * @param $newchar (int) Integer code (unicode) of the new character.
     * @return int the replaced char or the old char in case the new char i not defined
     * @protected
     * @since 5.9.167 (2012-06-22)
     */
    protected function replacechar($oldchar, $newchar) {
        if ($this->ischardefined($newchar)) {
            // Add the new char on the subset list.
            $this->currentfont['subsetchars'][$newchar] = true;
            // Return the new character.
            return $newchar;
        }
        // Return the old char.
        return $oldchar;
    }

    /**
     * Returns the code to draw the cell border
     * @see setlinestyle()
     * @since 5.7.000 (2010-08-02)
     */
    protected function getcellborder($x, $y, $w, $h, $brd) {
        $s = ''; // String to be returned.
        if (empty($brd)) {
            return $s;
        }
        if ($brd == 1) {
            $brd = array('LRTB' => true);
        }
        // Calculate coordinates for border.
        $k = $this->k;
        if ($this->rtl) {
            $xel = ($x - $w) * $k;
            $xer = $x * $k;
        } else {
            $xel = $x * $k;
            $xer = ($x + $w) * $k;
        }
        $yel = (($this->h - ($y + $h)) * $k);
        $yet = (($this->h - $y) * $k);
        $xet = $xel;
        $xeb = $xer;
        $yer = $yet;
        $yeb = $yel;
        if (is_string($brd)) {
            // Convert string to array.
            $slen = strlen($brd);
            $newbrd = array();
            for ($i = 0; $i < $slen; ++$i) {
                $newbrd[$brd[$i]] = array('cap' => 'square', 'join' => 'miter');
            }
            $brd = $newbrd;
        }
        if (isset($brd['mode'])) {
            $mode = $brd['mode'];
            unset($brd['mode']);
        } else {
            $mode = 'normal';
        }
        foreach ($brd as $border => $style) {
            if (is_array($style) AND !empty($style)) {
                // Apply border style.
                $prevstyle = $this->linestylewidth.' '.$this->linestylecap.' '.$this->linestylejoin.'
                              '.$this->linestyledash.' '.$this->drawcolor.' ';
                $s .= $this->setlinestyle($style, true)."\n";
            }
            switch ($mode) {
                case 'ext': {
                    $off = (($this->linewidth / 2) * $k);
                    $xl = $xel - $off;
                    $xr = $xer + $off;
                    $yt = $yet + $off;
                    $yl = $yel - $off;
                    $xt = $xl;
                    $xb = $xr;
                    $yr = $yt;
                    $yb = $yl;
                    $w += $this->linewidth;
                    $h += $this->linewidth;
                    break;
                }
                case 'int': {
                    $off = ($this->linewidth / 2) * $k;
                    $xl = $xel + $off;
                    $xr = $xer - $off;
                    $yt = $yet - $off;
                    $yl = $yel + $off;
                    $xt = $xl;
                    $xb = $xr;
                    $yr = $yt;
                    $yb = $yl;
                    $w -= $this->linewidth;
                    $h -= $this->linewidth;
                    break;
                }
                case 'normal':
                default: {
                    $xl = $xel;
                    $xt = $xet;
                    $xb = $xeb;
                    $xr = $xer;
                    $yl = $yel;
                    $yt = $yet;
                    $yb = $yeb;
                    $yr = $yer;
                    break;
                }
            }
            // Draw borders by case.
            if (strlen($border) == 4) {
                $s .= sprintf('%F %F %F %F re S ', $xt, $yt, ($w * $k), (-$h * $k));
            } else if (strlen($border) == 3) {
                if (strpos($border, 'B') === false) { // LTR.
                    $s .= sprintf('%F %F m ', $xl, $yl);
                    $s .= sprintf('%F %F l ', $xt, $yt);
                    $s .= sprintf('%F %F l ', $xr, $yr);
                    $s .= sprintf('%F %F l ', $xb, $yb);
                    $s .= 'S ';
                } else if (strpos($border, 'L') === false) { // TRB.
                    $s .= sprintf('%F %F m ', $xt, $yt);
                    $s .= sprintf('%F %F l ', $xr, $yr);
                    $s .= sprintf('%F %F l ', $xb, $yb);
                    $s .= sprintf('%F %F l ', $xl, $yl);
                    $s .= 'S ';
                } else if (strpos($border, 'T') === false) { // RBL.
                    $s .= sprintf('%F %F m ', $xr, $yr);
                    $s .= sprintf('%F %F l ', $xb, $yb);
                    $s .= sprintf('%F %F l ', $xl, $yl);
                    $s .= sprintf('%F %F l ', $xt, $yt);
                    $s .= 'S ';
                } else if (strpos($border, 'R') === false) { // BLT.
                    $s .= sprintf('%F %F m ', $xb, $yb);
                    $s .= sprintf('%F %F l ', $xl, $yl);
                    $s .= sprintf('%F %F l ', $xt, $yt);
                    $s .= sprintf('%F %F l ', $xr, $yr);
                    $s .= 'S ';
                }
            } else if (strlen($border) == 2) {
                if ((strpos($border, 'L') !== false) AND (strpos($border, 'T') !== false)) { // LT.
                    $s .= sprintf('%F %F m ', $xl, $yl);
                    $s .= sprintf('%F %F l ', $xt, $yt);
                    $s .= sprintf('%F %F l ', $xr, $yr);
                    $s .= 'S ';
                } else if ((strpos($border, 'T') !== false) AND (strpos($border, 'R') !== false)) { // TR.
                    $s .= sprintf('%F %F m ', $xt, $yt);
                    $s .= sprintf('%F %F l ', $xr, $yr);
                    $s .= sprintf('%F %F l ', $xb, $yb);
                    $s .= 'S ';
                } else if ((strpos($border, 'R') !== false) AND (strpos($border, 'B') !== false)) { // RB.
                    $s .= sprintf('%F %F m ', $xr, $yr);
                    $s .= sprintf('%F %F l ', $xb, $yb);
                    $s .= sprintf('%F %F l ', $xl, $yl);
                    $s .= 'S ';
                } else if ((strpos($border, 'B') !== false) AND (strpos($border, 'L') !== false)) { // BL.
                    $s .= sprintf('%F %F m ', $xb, $yb);
                    $s .= sprintf('%F %F l ', $xl, $yl);
                    $s .= sprintf('%F %F l ', $xt, $yt);
                    $s .= 'S ';
                } else if ((strpos($border, 'L') !== false) AND (strpos($border, 'R') !== false)) { // LR.
                    $s .= sprintf('%F %F m ', $xl, $yl);
                    $s .= sprintf('%F %F l ', $xt, $yt);
                    $s .= 'S ';
                    $s .= sprintf('%F %F m ', $xr, $yr);
                    $s .= sprintf('%F %F l ', $xb, $yb);
                    $s .= 'S ';
                } else if ((strpos($border, 'T') !== false) AND (strpos($border, 'B') !== false)) { // TB.
                    $s .= sprintf('%F %F m ', $xt, $yt);
                    $s .= sprintf('%F %F l ', $xr, $yr);
                    $s .= 'S ';
                    $s .= sprintf('%F %F m ', $xb, $yb);
                    $s .= sprintf('%F %F l ', $xl, $yl);
                    $s .= 'S ';
                }
            } else {
                if (strpos($border, 'L') !== false) { // L.
                    $s .= sprintf('%F %F m ', $xl, $yl);
                    $s .= sprintf('%F %F l ', $xt, $yt);
                    $s .= 'S ';
                } else if (strpos($border, 'T') !== false) { // T.
                    $s .= sprintf('%F %F m ', $xt, $yt);
                    $s .= sprintf('%F %F l ', $xr, $yr);
                    $s .= 'S ';
                } else if (strpos($border, 'R') !== false) { // R.
                    $s .= sprintf('%F %F m ', $xr, $yr);
                    $s .= sprintf('%F %F l ', $xb, $yb);
                    $s .= 'S ';
                } else if (strpos($border, 'B') !== false) { // B.
                    $s .= sprintf('%F %F m ', $xb, $yb);
                    $s .= sprintf('%F %F l ', $xl, $yl);
                    $s .= 'S ';
                }
            }
            if (is_array($style) AND !empty($style)) {
                // Reset border style to previous value.
                $s .= "\n".$this->linestylewidth.' '.$this->linestylecap.' '.$this->linestylejoin.'
                      '.$this->linestyledash.' '.$this->drawcolor."\n";
            }
        }
        return $s;
    }

    /**
     * This method allows printing text with line breaks.
     * They can be automatic (as soon as the text reaches the right border of the cell) or explicit
       (via the \n character). As many cells as necessary are output, one below the other.<br />
     * text can be aligned, centered or justified. The cell block can be framed and the background painted.
     * @see setfont(), setdrawcolor(), setfillcolor(), settextcolor(), setlinewidth(), cell(), write(), setautopagebreak()
     */
    public function multicell($w, $h, $txt, $border = 0, $align = 'J', $fill = false, $ln = 1, $x = '', $y = '',
                              $reseth = true, $stretch = 0, $ishtml = false, $autopadding = true, $maxh = 0,
                              $valign = 'T', $fitcell = false) {
        $prevcellmargin = $this->cellmargin;
        $prevcellpadding = $this->cellpadding;
        // Adjust internal padding.
        $this->adjustcellpadding($border);
        $mcpadding = $this->cellpadding;
        $mcmargin = $this->cellmargin;
        $this->cellpadding['T'] = 0;
        $this->cellpadding['B'] = 0;
        $this->setcellmargins(0, 0, 0, 0);
        if ($this->empty_string($this->lasth) OR $reseth) {
            // Reset row height.
            $this->resetlasth();
        }
        if (!$this->empty_string($y)) {
            $this->sety($y);
        } else {
            $y = $this->gety();
        }
        $resth = 0;
        if (($h > 0) AND $this->inpagebody() AND (($y + $h + $mcmargin['T'] + $mcmargin['B']) > $this->pagebreaktrigger)) {
            // Spit cell in more pages/columns.
            $newh = ($this->pagebreaktrigger - $y);
            $resth = ($h - $newh); // Cell to be printed on the next page/column.
            $h = $newh;
        }
        // Get current page number.
        $startpage = $this->page;
        // Get current column.
        $startcolumn = $this->currentcolumn;
        if (!$this->empty_string($x)) {
            $this->setx($x);
        } else {
            $x = $this->getx();
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions(0, $x, $y);
        // Apply margins.
        $oy = $y + $mcmargin['T'];
        if ($this->rtl) {
            $ox = $this->w - $x - $mcmargin['R'];
        } else {
            $ox = $x + $mcmargin['L'];
        }
        $this->x = $ox;
        $this->y = $oy;
        // Set width.
        if ($this->empty_string($w) OR ($w <= 0)) {
            if ($this->rtl) {
                $w = $this->x - $this->lmargin - $mcmargin['L'];
            } else {
                $w = $this->w - $this->x - $this->rmargin - $mcmargin['R'];
            }
        }
        // Store original margin values.
        $lmargin = $this->lmargin;
        $rmargin = $this->rmargin;
        if ($this->rtl) {
            $this->rmargin = $this->w - $this->x;
            $this->lmargin = $this->x - $w;
        } else {
            $this->lmargin = $this->x;
            $this->rmargin = $this->w - $this->x - $w;
        }
        if ($autopadding) {
            // Add top padding.
            $this->y += $mcpadding['T'];
        }
        if ($ishtml) { // Write HTML text.
            $this->writehtml($txt, true, false, $reseth, true, $align);
            $nl = 1;
        } else { // Write simple text.
            $prevfontsizept = $this->fontsizept;
            // Vertical alignment.
            if ($maxh > 0) {
                // Get text height.
                $textheight = $this->getstringheight($w, $txt, $reseth, $autopadding, $mcpadding, $border);
                if ($fitcell) {
                    // Try to reduce font size to fit text on cell (use a quick search algorithm).
                    $fmin = 1;
                    $fmax = $this->fontsizept;
                    $prevtextheight = $textheight;
                    $maxit = 100; // Max number of iterations.
                    while ($maxit > 0) {
                        $fmid = (($fmax + $fmin) / 2);
                        $this->setfontsize($fmid, false);
                        $this->resetlasth();
                        $textheight = $this->getstringheight($w, $txt, $reseth, $autopadding, $mcpadding, $border);
                        if (($textheight == $maxh) OR (($textheight < $maxh) AND ($fmin >= ($fmax - 0.01)))) {
                            break;
                        } else if ($textheight < $maxh) {
                            $fmin = $fmid;
                        } else {
                            $fmax = $fmid;
                        }
                        --$maxit;
                    }
                    $this->setfontsize($this->fontsizept);
                }
                if ($textheight < $maxh) {
                    if ($valign == 'M') {
                        // Text vertically centered.
                        $this->y += (($maxh - $textheight) / 2);
                    } else if ($valign == 'B') {
                        // Text vertically aligned on bottom.
                        $this->y += ($maxh - $textheight);
                    }
                }
            }
            $nl = $this->write($this->lasth, $txt, '', 0, $align, true, $stretch, false, true, $maxh, 0, $mcmargin);
            if ($fitcell) {
                // Restore font size.
                $this->setfontsize($prevfontsizept);
            }
        }
        if ($autopadding) {
            // Add bottom padding.
            $this->y += $mcpadding['B'];
        }
        // Get end-of-text Y position.
        $currenty = $this->y;
        // Get latest page number.
        $endpage = $this->page;
        if ($resth > 0) {
            $skip = ($endpage - $startpage);
            $tmpresth = $resth;
            while ($tmpresth > 0) {
                if ($skip <= 0) {
                    // Add a page (or trig acceptpagebreak() for multicolumn mode).
                    $this->checkpagebreak($this->pagebreaktrigger + 1);
                }
                if ($this->numcolumns > 1) {
                    $tmpresth -= ($this->h - $this->y - $this->bmargin);
                } else {
                    $tmpresth -= ($this->h - $this->tmargin - $this->bmargin);
                }
                --$skip;
            }
            $currenty = $this->y;
            $endpage = $this->page;
        }
        // Get latest column.
        $endcolumn = $this->currentcolumn;
        if ($this->numcolumns == 0) {
            $this->numcolumns = 1;
        }
        // Get border modes.
        $borderstart = $this->getbordermode($border, $position = 'start');
        $borderend = $this->getbordermode($border, $position = 'end');
        $bordermiddle = $this->getbordermode($border, $position = 'middle');
        // Design borders around HTML cells.
        for ($page = $startpage; $page <= $endpage; ++$page) { // For each page.
            $ccode = '';
            $this->setpage($page);
            if ($this->numcolumns < 2) {
                // Single-column mode.
                $this->setx($x);
                $this->y = $this->tmargin;
            }
            // Account for margin changes.
            if ($page > $startpage) {
                if (($this->rtl) AND ($this->pagedim[$page]['orm'] != $this->pagedim[$startpage]['orm'])) {
                    $this->x -= ($this->pagedim[$page]['orm'] - $this->pagedim[$startpage]['orm']);
                } else if ((!$this->rtl) AND ($this->pagedim[$page]['olm'] != $this->pagedim[$startpage]['olm'])) {
                    $this->x += ($this->pagedim[$page]['olm'] - $this->pagedim[$startpage]['olm']);
                }
            }
            if ($startpage == $endpage) {
                // Single page.
                for ($column = $startcolumn; $column <= $endcolumn; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    if ($this->rtl) {
                        $this->x -= $mcmargin['R'];
                    } else {
                        $this->x += $mcmargin['L'];
                    }
                    if ($startcolumn == $endcolumn) { // Single column.
                        $cborder = $border;
                        $h = max($h, ($currenty - $oy));
                        $this->y = $oy;
                    } else if ($column == $startcolumn) { // First column.
                        $cborder = $borderstart;
                        $this->y = $oy;
                        $h = $this->h - $this->y - $this->bmargin;
                    } else if ($column == $endcolumn) { // End column.
                        $cborder = $borderend;
                        $h = $currenty - $this->y;
                        if ($resth > $h) {
                            $h = $resth;
                        }
                    } else { // Middle column.
                        $cborder = $bordermiddle;
                        $h = $this->h - $this->y - $this->bmargin;
                        $resth -= $h;
                    }
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            } else if ($page == $startpage) { // First page.
                for ($column = $startcolumn; $column < $this->numcolumns; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    if ($this->rtl) {
                        $this->x -= $mcmargin['R'];
                    } else {
                        $this->x += $mcmargin['L'];
                    }
                    if ($column == $startcolumn) { // First column.
                        $cborder = $borderstart;
                        $this->y = $oy;
                        $h = $this->h - $this->y - $this->bmargin;
                    } else { // Middle column.
                        $cborder = $bordermiddle;
                        $h = $this->h - $this->y - $this->bmargin;
                        $resth -= $h;
                    }
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            } else if ($page == $endpage) { // Last page.
                for ($column = 0; $column <= $endcolumn; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    if ($this->rtl) {
                        $this->x -= $mcmargin['R'];
                    } else {
                        $this->x += $mcmargin['L'];
                    }
                    if ($column == $endcolumn) {
                        // End column.
                        $cborder = $borderend;
                        $h = $currenty - $this->y;
                        if ($resth > $h) {
                            $h = $resth;
                        }
                    } else {
                        // Middle column.
                        $cborder = $bordermiddle;
                        $h = $this->h - $this->y - $this->bmargin;
                        $resth -= $h;
                    }
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            } else { // Middle page.
                for ($column = 0; $column < $this->numcolumns; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    if ($this->rtl) {
                        $this->x -= $mcmargin['R'];
                    } else {
                        $this->x += $mcmargin['L'];
                    }
                    $cborder = $bordermiddle;
                    $h = $this->h - $this->y - $this->bmargin;
                    $resth -= $h;
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            }
            if ($cborder OR $fill) {
                $offsetlen = strlen($ccode);
                // Draw border and fill.
                if ($this->inxobj) {
                    // We are inside an XObject template.
                    if (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {
                        $pagemarkkey = key($this->xobjects[$this->xobjid]['transfmrk']);
                        $pagemark = $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey];
                        $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey] += $offsetlen;
                    } else {
                        $pagemark = $this->xobjects[$this->xobjid]['intmrk'];
                        $this->xobjects[$this->xobjid]['intmrk'] += $offsetlen;
                    }
                    $pagebuff = $this->xobjects[$this->xobjid]['outdata'];
                    $pstart = substr($pagebuff, 0, $pagemark);
                    $pend = substr($pagebuff, $pagemark);
                    $this->xobjects[$this->xobjid]['outdata'] = $pstart.$ccode.$pend;
                } else {
                    if (end($this->transfmrk[$this->page]) !== false) {
                        $pagemarkkey = key($this->transfmrk[$this->page]);
                        $pagemark = $this->transfmrk[$this->page][$pagemarkkey];
                        $this->transfmrk[$this->page][$pagemarkkey] += $offsetlen;
                    } else if ($this->infooter) {
                        $pagemark = $this->footerpos[$this->page];
                        $this->footerpos[$this->page] += $offsetlen;
                    } else {
                        $pagemark = $this->intmrk[$this->page];
                        $this->intmrk[$this->page] += $offsetlen;
                    }
                    $pagebuff = $this->getpagebuffer($this->page);
                    $pstart = substr($pagebuff, 0, $pagemark);
                    $pend = substr($pagebuff, $pagemark);
                    $this->setpagebuffer($this->page, $pstart.$ccode.$pend);
                }
            }
        } // End for each page.
        // Get end-of-cell Y position.
        $currenty = $this->gety();
        // Restore previous values.
        if ($this->numcolumns > 1) {
            $this->selectcolumn();
        } else {
            // Restore original margins.
            $this->lmargin = $lmargin;
            $this->rmargin = $rmargin;
            if ($this->page > $startpage) {
                // Check for margin variations between pages (i.e. booklet mode).
                $dl = ($this->pagedim[$this->page]['olm'] - $this->pagedim[$startpage]['olm']);
                $dr = ($this->pagedim[$this->page]['orm'] - $this->pagedim[$startpage]['orm']);
                if (($dl != 0) OR ($dr != 0)) {
                    $this->lmargin += $dl;
                    $this->rmargin += $dr;
                }
            }
        }
        if ($ln > 0) {
            // Go to the beginning of the next line.
            $this->sety($currenty + $mcmargin['B']);
            if ($ln == 2) {
                $this->setx($x + $w + $mcmargin['L'] + $mcmargin['R']);
            }
        } else {
            // Go left or right by case.
            $this->setpage($startpage);
            $this->y = $y;
            $this->setx($x + $w + $mcmargin['L'] + $mcmargin['R']);
        }
        $this->setcontentmark();
        $this->cellpadding = $prevcellpadding;
        $this->cellmargin = $prevcellmargin;
        return $nl;
    }

    /**
     * Get the border mode accounting for multicell position (opens bottom side of multicell crossing pages)
     */
    protected function getbordermode($brd, $position = 'start') {
        if ((!$this->opencell) OR empty($brd)) {
            return $brd;
        }
        if ($brd == 1) {
            $brd = 'LTRB';
        }
        if (is_string($brd)) {
            // Convert string to array.
            $slen = strlen($brd);
            $newbrd = array();
            for ($i = 0; $i < $slen; ++$i) {
                $newbrd[$brd[$i]] = array('cap' => 'square', 'join' => 'miter');
            }
            $brd = $newbrd;
        }
        foreach ($brd as $border => $style) {
            switch ($position) {
                case 'start': {
                    if (strpos($border, 'B') !== false) {
                        // Remove bottom line.
                        $newkey = str_replace('B', '', $border);
                        if (strlen($newkey) > 0) {
                            $brd[$newkey] = $style;
                        }
                        unset($brd[$border]);
                    }
                    break;
                }
                case 'middle': {
                    if (strpos($border, 'B') !== false) {
                        // Remove bottom line.
                        $newkey = str_replace('B', '', $border);
                        if (strlen($newkey) > 0) {
                            $brd[$newkey] = $style;
                        }
                        unset($brd[$border]);
                        $border = $newkey;
                    }
                    if (strpos($border, 'T') !== false) {
                        // Remove bottom line.
                        $newkey = str_replace('T', '', $border);
                        if (strlen($newkey) > 0) {
                            $brd[$newkey] = $style;
                        }
                        unset($brd[$border]);
                    }
                    break;
                }
                case 'end': {
                    if (strpos($border, 'T') !== false) {
                        // Remove bottom line.
                        $newkey = str_replace('T', '', $border);
                        if (strlen($newkey) > 0) {
                            $brd[$newkey] = $style;
                        }
                        unset($brd[$border]);
                    }
                    break;
                }
            }
        }
        return $brd;
    }

    /**
     * This method returns the estimated number of lines for print a simple text string using multicell() method.
     */
    public function getnumlines($txt, $w = 0, $reseth = false, $autopadding = true, $cellpadding = '', $border = 0) {
        if ($txt === '') {
            // Empty string.
            return 1;
        }
        // Adjust internal padding.
        $prevcellpadding = $this->cellpadding;
        $prevlasth = $this->lasth;
        if (is_array($cellpadding)) {
            $this->cellpadding = $cellpadding;
        }
        $this->adjustcellpadding($border);
        if ($this->empty_string($w) OR ($w <= 0)) {
            if ($this->rtl) {
                $w = $this->x - $this->lmargin;
            } else {
                $w = $this->w - $this->rmargin - $this->x;
            }
        }
        $wmax = $w - $this->cellpadding['L'] - $this->cellpadding['R'];
        if ($reseth) {
            // Reset row height.
            $this->resetlasth();
        }
        $lines = 1;
        $sum = 0;
        $chars = $this->utf8bidi($this->utf8stringtoarray($txt), $txt, $this->tmprtl);
        $charswidth = $this->getarrstringwidth($chars, '', '', 0, true);
        $length = count($chars);
        $lastseparator = -1;
        for ($i = 0; $i < $length; ++$i) {
            $charwidth = $charswidth[$i];
            if (preg_match($this->respaces, $this->unichr($chars[$i]))) {
                $lastseparator = $i;
            }
            if ((($sum + $charwidth) > $wmax) OR ($chars[$i] == 10)) {
                ++$lines;
                if ($chars[$i] == 10) {
                    $lastseparator = -1;
                    $sum = 0;
                } else if ($lastseparator != -1) {
                    $i = $lastseparator;
                    $lastseparator = -1;
                    $sum = 0;
                } else {
                    $sum = $charwidth;
                }
            } else {
                $sum += $charwidth;
            }
        }
        if ($chars[($length - 1)] == 10) {
            --$lines;
        }
        $this->cellpadding = $prevcellpadding;
        $this->lasth = $prevlasth;
        return $lines;
    }

    /**
     * This method return the estimated height needed for printing a simple text string using the multicell() method.
     * Generally, if you want to know the exact height for a block of content you can use the following alternative technique:
     */
    public function getstringheight($w, $txt, $reseth = false, $autopadding = true, $cellpadding = '', $border = 0) {
        // Adjust internal padding.
        $prevcellpadding = $this->cellpadding;
        $prevlasth = $this->lasth;
        if (is_array($cellpadding)) {
            $this->cellpadding = $cellpadding;
        }
        $this->adjustcellpadding($border);
        $lines = $this->getnumlines($txt, $w, $reseth, $autopadding, $cellpadding, $border);
        $height = $lines * ($this->fontsize * $this->cellheightratio);
        if ($autopadding) {
            // Add top and bottom padding.
            $height += ($this->cellpadding['T'] + $this->cellpadding['B']);
        }
        $this->cellpadding = $prevcellpadding;
        $this->lasth = $prevlasth;
        return $height;
    }

    /**
     * This method prints text from the current position.<br />
     */
    public function write($h, $txt, $link = '', $fill = false, $align = '', $ln = false, $stretch = 0,
                          $firstline = false, $firstblock = false, $maxh = 0, $wadj = 0, $margin = '') {
        // Check page for no-write regions and adapt page margins if necessary.
        list($this->x, $this->y) = $this->checkpageregions($h, $this->x, $this->y);
        if (strlen($txt) == 0) {
            // Fix empty text.
            $txt = ' ';
        }
        if ($margin === '') {
            // Set default margins.
            $margin = $this->cellmargin;
        }
        // Remove carriage returns.
        $s = str_replace("\r", '', $txt);
        // Check if string contains arabic text.
        if (preg_match($this->unicode->uni_RE_PATTERN_ARABIC, $s)) {
            $arabic = true;
        } else {
            $arabic = false;
        }
        // Check if string contains RTL text.
        if ($arabic OR ($this->tmprtl == 'R') OR preg_match($this->unicode->uni_RE_PATTERN_RTL, $s)) {
            $rtlmode = true;
        } else {
            $rtlmode = false;
        }
        // Get a char width.
        $chrwidth = $this->getcharwidth(46); // Dot character.
        // Get array of unicode values.
        $chars = $this->utf8stringtoarray($s);
        // Get array of chars.
        $uchars = $this->utf8arraytouniarray($chars);
        // Get the number of characters.
        $nb = count($chars);
        // Replacement for SHY character (minus symbol).
        $shyreplacement = 45;
        $shyreplacementchar = $this->unichr($shyreplacement);
        // Width for SHY replacement.
        $shyreplacementwidth = $this->getcharwidth($shyreplacement);
        // Max Y.
        $maxy = $this->y + $maxh - $h - $this->cellpadding['T'] - $this->cellpadding['B'];
        // Page width.
        $pw = $w = $this->w - $this->lmargin - $this->rmargin;
        // Calculate remaining line width ($w).
        if ($this->rtl) {
            $w = $this->x - $this->lmargin;
        } else {
            $w = $this->w - $this->rmargin - $this->x;
        }
        // Max column width.
        $wmax = ($w - $wadj);
        if (!$firstline) {
            $wmax -= ($this->cellpadding['L'] + $this->cellpadding['R']);
        }
        if ((!$firstline) AND (($chrwidth > $wmax) OR ($this->getcharwidth($chars[0]) > $wmax))) {
            // A single character do not fit on column.
            return '';
        }
        // Minimum row height.
        $rowheight = max($h, $this->fontsize * $this->cellheightratio);
        $startpage = $this->page;
        $i = 0; // Character position.
        $j = 0; // Current starting position.
        $sep = -1; // Position of the last blank space.
        $shy = false; // True if the last blank is a soft hypen (SHY).
        $l = 0; // Current string length.
        $nl = 0; // Number of lines.
        $linebreak = false;
        $pc = 0; // Previous character.
        // For each character.
        while ($i < $nb) {
            if (($maxh > 0) AND ($this->y >= $maxy) ) {
                break;
            }
            // Get the current character.
            $c = $chars[$i];
            if ($c == 10) {
                // Explicit line break.
                if ($align == 'J') {
                    if ($this->rtl) {
                        $talign = 'R';
                    } else {
                        $talign = 'L';
                    }
                } else {
                    $talign = $align;
                }
                $tmpstr = $this->uniarrsubstring($uchars, $j, $i);
                if ($firstline) {
                    $startx = $this->x;
                    $tmparr = array_slice($chars, $j, ($i - $j));
                    if ($rtlmode) {
                        $tmparr = $this->utf8bidi($tmparr, $tmpstr, $this->tmprtl);
                    }
                    $linew = $this->getarrstringwidth($tmparr);
                    unset($tmparr);
                    if ($this->rtl) {
                        $this->endlinex = $startx - $linew;
                    } else {
                        $this->endlinex = $startx + $linew;
                    }
                    $w = $linew;
                    $tmpcellpadding = $this->cellpadding;
                    if ($maxh == 0) {
                        $this->setcellpadding(0);
                    }
                }
                if ($firstblock AND $this->isrtltextdir()) {
                    $tmpstr = $this->stringrighttrim($tmpstr);
                }
                // Skip newlines at the begining of a page or column.
                if (!empty($tmpstr) OR ($this->y < ($this->pagebreaktrigger - $rowheight))) {
                    $this->cell($w, $h, $tmpstr, 0, 1, $talign, $fill, $link, $stretch);
                }
                unset($tmpstr);
                if ($firstline) {
                    $this->cellpadding = $tmpcellpadding;
                    return ($this->uniarrsubstring($uchars, $i));
                }
                ++$nl;
                $j = $i + 1;
                $l = 0;
                $sep = -1;
                $shy = false;
                // Account for margin changes.
                if ((($this->y + $this->lasth) > $this->pagebreaktrigger) AND ($this->inpagebody())) {
                    $this->acceptpagebreak();
                    if ($this->rtl) {
                        $this->x -= $margin['R'];
                    } else {
                        $this->x += $margin['L'];
                    }
                    $this->lmargin += $margin['L'];
                    $this->rmargin += $margin['R'];
                }
                $w = $this->getremainingwidth();
                $wmax = ($w - $this->cellpadding['L'] - $this->cellpadding['R']);
            } else {
                if (($c != 160) AND (($c == 173) OR preg_match($this->respaces, $this->unichr($c)))) {
                    // Update last blank space position.
                    $sep = $i;
                    // Check if is a SHY.
                    if ($c == 173) {
                        $shy = true;
                        if ($pc == 45) {
                            $tmpshyreplacementwidth = 0;
                            $tmpshyreplacementchar = '';
                        } else {
                            $tmpshyreplacementwidth = $shyreplacementwidth;
                            $tmpshyreplacementchar = $shyreplacementchar;
                        }
                    } else {
                        $shy = false;
                    }
                }
                // Update string length.
                if ($this->isunicodefont() AND ($arabic)) {
                    // With bidirectional algorithm some chars may be changed affecting the line length.
                    $l = $this->getarrstringwidth($this->utf8bidi(array_slice($chars, $j, ($i - $j)), '', $this->tmprtl));
                } else {
                    $l += $this->getcharwidth($c);
                }
                if (($l > $wmax) OR (($c == 173) AND (($l + $tmpshyreplacementwidth) > $wmax)) ) {
                    // We have reached the end of column.
                    if ($sep == -1) {
                        // Check if the line was already started.
                        if (($this->rtl AND ($this->x <= ($this->w - $this->rmargin - $this->cellpadding['R'] -
                             $margin['R'] - $chrwidth)))
                            OR ((!$this->rtl) AND ($this->x >= ($this->lmargin + $this->cellpadding['L'] +
                                 $margin['L'] + $chrwidth)))) {
                            // Print a void cell and go to next line.
                            $this->cell($w, $h, '', 0, 1);
                            $linebreak = true;
                            if ($firstline) {
                                return ($this->uniarrsubstring($uchars, $j));
                            }
                        } else {
                            // Truncate the word because do not fit on column.
                            $tmpstr = $this->uniarrsubstring($uchars, $j, $i);
                            if ($firstline) {
                                $startx = $this->x;
                                $tmparr = array_slice($chars, $j, ($i - $j));
                                if ($rtlmode) {
                                    $tmparr = $this->utf8bidi($tmparr, $tmpstr, $this->tmprtl);
                                }
                                $linew = $this->getarrstringwidth($tmparr);
                                unset($tmparr);
                                if ($this->rtl) {
                                    $this->endlinex = $startx - $linew;
                                } else {
                                    $this->endlinex = $startx + $linew;
                                }
                                $w = $linew;
                                $tmpcellpadding = $this->cellpadding;
                                if ($maxh == 0) {
                                    $this->setcellpadding(0);
                                }
                            }
                            if ($firstblock AND $this->isrtltextdir()) {
                                $tmpstr = $this->stringrighttrim($tmpstr);
                            }
                            $this->cell($w, $h, $tmpstr, 0, 1, $align, $fill, $link, $stretch);
                            unset($tmpstr);
                            if ($firstline) {
                                $this->cellpadding = $tmpcellpadding;
                                return ($this->uniarrsubstring($uchars, $i));
                            }
                            $j = $i;
                            --$i;
                        }
                    } else {
                        // Word wrapping.
                        if ($this->rtl AND (!$firstblock) AND ($sep < $i)) {
                            $endspace = 1;
                        } else {
                            $endspace = 0;
                        }
                        // Check the length of the next string.
                        $strrest = $this->uniarrsubstring($uchars, ($sep + $endspace));
                        $nextstr = preg_split('/'.$this->respace['p'].'/'.$this->respace['m'], $this->stringtrim($strrest));
                        if (isset($nextstr[0]) AND ($this->getstringwidth($nextstr[0]) > $pw)) {
                            // Truncate the word because do not fit on a full page width.
                            $tmpstr = $this->uniarrsubstring($uchars, $j, $i);
                            if ($firstline) {
                                $startx = $this->x;
                                $tmparr = array_slice($chars, $j, ($i - $j));
                                if ($rtlmode) {
                                    $tmparr = $this->utf8bidi($tmparr, $tmpstr, $this->tmprtl);
                                }
                                $linew = $this->getarrstringwidth($tmparr);
                                unset($tmparr);
                                if ($this->rtl) {
                                    $this->endlinex = $startx - $linew;
                                } else {
                                    $this->endlinex = $startx + $linew;
                                }
                                $w = $linew;
                                $tmpcellpadding = $this->cellpadding;
                                if ($maxh == 0) {
                                    $this->setcellpadding(0);
                                }
                            }
                            if ($firstblock AND $this->isrtltextdir()) {
                                $tmpstr = $this->stringrighttrim($tmpstr);
                            }
                            $this->cell($w, $h, $tmpstr, 0, 1, $align, $fill, $link, $stretch);
                            unset($tmpstr);
                            if ($firstline) {
                                $this->cellpadding = $tmpcellpadding;
                                return ($this->uniarrsubstring($uchars, $i));
                            }
                            $j = $i;
                            --$i;
                        } else {
                            // Word wrapping.
                            if ($shy) {
                                // Add hypen (minus symbol) at the end of the line.
                                $shywidth = $tmpshyreplacementwidth;
                                if ($this->rtl) {
                                    $shycharleft = $tmpshyreplacementchar;
                                    $shycharright = '';
                                } else {
                                    $shycharleft = '';
                                    $shycharright = $tmpshyreplacementchar;
                                }
                            } else {
                                $shywidth = 0;
                                $shycharleft = '';
                                $shycharright = '';
                            }
                            $tmpstr = $this->uniarrsubstring($uchars, $j, ($sep + $endspace));
                            if ($firstline) {
                                $startx = $this->x;
                                $tmparr = array_slice($chars, $j, (($sep + $endspace) - $j));
                                if ($rtlmode) {
                                    $tmparr = $this->utf8bidi($tmparr, $tmpstr, $this->tmprtl);
                                }
                                $linew = $this->getarrstringwidth($tmparr);
                                unset($tmparr);
                                if ($this->rtl) {
                                    $this->endlinex = $startx - $linew - $shywidth;
                                } else {
                                    $this->endlinex = $startx + $linew + $shywidth;
                                }
                                $w = $linew;
                                $tmpcellpadding = $this->cellpadding;
                                if ($maxh == 0) {
                                    $this->setcellpadding(0);
                                }
                            }
                            // Print the line.
                            if ($firstblock AND $this->isrtltextdir()) {
                                $tmpstr = $this->stringrighttrim($tmpstr);
                            }
                            $this->cell($w, $h, $shycharleft.$tmpstr.$shycharright, 0, 1, $align, $fill, $link, $stretch);
                            unset($tmpstr);
                            if ($firstline) {
                                // Return the remaining text.
                                $this->cellpadding = $tmpcellpadding;
                                return ($this->uniarrsubstring($uchars, ($sep + $endspace)));
                            }
                            $i = $sep;
                            $sep = -1;
                            $shy = false;
                            $j = ($i + 1);
                        }
                    }
                    // Account for margin changes.
                    if ((($this->y + $this->lasth) > $this->pagebreaktrigger) AND ($this->inpagebody())) {
                        $this->acceptpagebreak();
                        if ($this->rtl) {
                            $this->x -= $margin['R'];
                        } else {
                            $this->x += $margin['L'];
                        }
                        $this->lmargin += $margin['L'];
                        $this->rmargin += $margin['R'];
                    }
                    $w = $this->getremainingwidth();
                    $wmax = $w - $this->cellpadding['L'] - $this->cellpadding['R'];
                    if ($linebreak) {
                        $linebreak = false;
                    } else {
                        ++$nl;
                        $l = 0;
                    }
                }
            }
            // Save last character.
            $pc = $c;
            ++$i;
        } // End while i < nb.
        // Print last substring (if any).
        if ($l > 0) {
            switch ($align) {
                case 'J':
                case 'C': {
                    $w = $w;
                    break;
                }
                case 'L': {
                    if ($this->rtl) {
                        $w = $w;
                    } else {
                        $w = $l;
                    }
                    break;
                }
                case 'R': {
                    if ($this->rtl) {
                        $w = $l;
                    } else {
                        $w = $w;
                    }
                    break;
                }
                default: {
                    $w = $l;
                    break;
                }
            }
            $tmpstr = $this->uniarrsubstring($uchars, $j, $nb);
            if ($firstline) {
                $startx = $this->x;
                $tmparr = array_slice($chars, $j, ($nb - $j));
                if ($rtlmode) {
                    $tmparr = $this->utf8bidi($tmparr, $tmpstr, $this->tmprtl);
                }
                $linew = $this->getarrstringwidth($tmparr);
                unset($tmparr);
                if ($this->rtl) {
                    $this->endlinex = $startx - $linew;
                } else {
                    $this->endlinex = $startx + $linew;
                }
                $w = $linew;
                $tmpcellpadding = $this->cellpadding;
                if ($maxh == 0) {
                    $this->setcellpadding(0);
                }
            }
            if ($firstblock AND $this->isrtltextdir()) {
                $tmpstr = $this->stringrighttrim($tmpstr);
            }
            $this->cell($w, $h, $tmpstr, 0, $ln, $align, $fill, $link, $stretch);
            unset($tmpstr);
            if ($firstline) {
                $this->cellpadding = $tmpcellpadding;
                return ($this->uniarrsubstring($uchars, $nb));
            }
            ++$nl;
        }
        if ($firstline) {
            return '';
        }
        return $nl;
    }

    /**
     * Returns the remaining width between the current position and margins.
     * @return int Return the remaining width
     * @protected
     */
    protected function getremainingwidth() {
        list($this->x, $this->y) = $this->checkpageregions(0, $this->x, $this->y);
        if ($this->rtl) {
            return ($this->x - $this->lmargin);
        } else {
            return ($this->w - $this->rmargin - $this->x);
        }
    }

    /**
     * Extract a slice of the $strarr array and return it as string.
     * @param $strarr (string) The input array of characters.
     * @param $start (int) the starting element of $strarr.
     * @param $end (int) first element that will not be returned.
     * @return Return part of a string
     * @public
     */
    public function utf8arrsubstring($strarr, $start='', $end='') {
        if (strlen($start) == 0) {
            $start = 0;
        }
        if (strlen($end) == 0) {
            $end = count($strarr);
        }
        $string = '';
        for ($i = $start; $i < $end; ++$i) {
            $string .= $this->unichr($strarr[$i]);
        }
        return $string;
    }

    /**
     * Extract a slice of the $uniarr array and return it as string.
     * @param $uniarr (string) The input array of characters.
     * @param $start (int) the starting element of $strarr.
     * @param $end (int) first element that will not be returned.
     * @return Return part of a string
     * @public
     * @since 4.5.037 (2009-04-07)
     */
    public function uniarrsubstring($uniarr, $start = '', $end = '') {
        if (strlen($start) == 0) {
            $start = 0;
        }
        if (strlen($end) == 0) {
            $end = count($uniarr);
        }
        $string = '';
        for ($i = $start; $i < $end; ++$i) {
            $string .= $uniarr[$i];
        }
        return $string;
    }

    /**
     * Convert an array of UTF8 values to array of unicode characters
     * @param $ta (string) The input array of UTF8 values.
     * @return Return array of unicode characters
     * @public
     * @since 4.5.037 (2009-04-07)
     */
    public function utf8arraytouniarray($ta) {
        return array_map(array($this, 'unichr'), $ta);
    }

    /**
     * Returns the unicode caracter specified by UTF-8 value
     * @param $c (int) UTF-8 value
     * @return Returns the specified character.
     * @public
     * @since 2.3.000 (2008-03-05)
     */
    public function unichr($c) {
        if (!$this->isunicode) {
            return chr($c);
        } else if ($c <= 0x7F) {
            // One byte.
            return chr($c);
        } else if ($c <= 0x7FF) {
            // Two bytes.
            return chr(0xC0 | $c >> 6).chr(0x80 | $c & 0x3F);
        } else if ($c <= 0xFFFF) {
            // Three bytes.
            return chr(0xE0 | $c >> 12).chr(0x80 | $c >> 6 & 0x3F).chr(0x80 | $c & 0x3F);
        } else if ($c <= 0x10FFFF) {
            // Four bytes.
            return chr(0xF0 | $c >> 18).chr(0x80 | $c >> 12 & 0x3F).chr(0x80 | $c >> 6 & 0x3F).chr(0x80 | $c & 0x3F);
        } else {
            return '';
        }
    }

    /**
     * Return the image type given the file name or array returned by getimagesize() function.
     * @param $imgfile (string) image file name
     * @param $iminfo (array) array of image information returned by getimagesize() function.
     * @return string image type
     * @since 4.8.017 (2009-11-27)
     */
    public function getimagefiletype($imgfile, $iminfo = array()) {
        $type = '';
        if (isset($iminfo['mime']) AND !empty($iminfo['mime'])) {
            $mime = explode('/', $iminfo['mime']);
            if ((count($mime) > 1) AND ($mime[0] == 'image') AND (!empty($mime[1]))) {
                $type = strtolower(trim($mime[1]));
            }
        }
        if (empty($type)) {
            $fileinfo = pathinfo($imgfile);
            if (isset($fileinfo['extension']) AND (!$this->empty_string($fileinfo['extension']))) {
                $type = strtolower(trim($fileinfo['extension']));
            }
        }
        if ($type == 'jpg') {
            $type = 'jpeg';
        }
        return $type;
    }

    /**
     * Set the block dimensions accounting for page breaks and page/column fitting
     * @param $w (float) width
     * @param $h (float) height
     * @param $x (float) X coordinate
     * @param $y (float) Y coodiante
     * @param $fitonpage (boolean) if true the block is resized to not exceed page dimensions.
     * @return array($w, $h, $x, $y)
     * @protected
     * @since 5.5.009 (2010-07-05)
     */
    protected function fitblock($w, $h, $x, $y, $fitonpage = false) {
        if ($w <= 0) {
            // Set maximum width.
            $w = ($this->w - $this->lmargin - $this->rmargin);
        }
        if ($h <= 0) {
            // Set maximum height.
            $h = ($this->pagebreaktrigger - $this->tmargin);
        }
        // Resize the block to be vertically contained on a single page or single column.
        if ($fitonpage OR $this->autopagebreak) {
            $ratiowh = ($w / $h);
            if ($h > ($this->pagebreaktrigger - $this->tmargin)) {
                $h = $this->pagebreaktrigger - $this->tmargin;
                $w = ($h * $ratiowh);
            }
            // Resize the block to be horizontally contained on a single page or single column.
            if ($fitonpage) {
                $maxw = ($this->w - $this->lmargin - $this->rmargin);
                if ($w > $maxw) {
                    $w = $maxw;
                    $h = ($w / $ratiowh);
                }
            }
        }
        // Check whether we need a new page or new column first as this does not fit.
        $prevx = $this->x;
        $prevy = $this->y;
        if ($this->checkpagebreak($h, $y) OR ($this->y < $prevy)) {
            $y = $this->y;
            if ($this->rtl) {
                $x += ($prevx - $this->x);
            } else {
                $x += ($this->x - $prevx);
            }
            $this->newline = true;
        }
        // Resize the block to be contained on the remaining available page or column space.
        if ($fitonpage) {
            $ratiowh = ($w / $h);
            if (($y + $h) > $this->pagebreaktrigger) {
                $h = $this->pagebreaktrigger - $y;
                $w = ($h * $ratiowh);
            }
            if ((!$this->rtl) AND (($x + $w) > ($this->w - $this->rmargin))) {
                $w = $this->w - $this->rmargin - $x;
                $h = ($w / $ratiowh);
            } else if (($this->rtl) AND (($x - $w) < ($this->lmargin))) {
                $w = $x - $this->lmargin;
                $h = ($w / $ratiowh);
            }
        }
        return array($w, $h, $x, $y);
    }

    /**
     * Puts an image in the page.
     * The upper-left corner must be given.
     * The dimensions can be specified in different ways:<ul>
     */
    public function imageq($file, $x = '', $y = '', $w = 0, $h = 0, $type = '', $link = '', $align = '', $resize = false,
                          $dpi = 300, $palign = '', $ismask = false, $imgmask = false, $border = 0, $fitbox = false,
                          $hidden = false, $fitonpage = false, $alt = false, $altimgs = array()) {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        $cachedfile = false; // True when the file is cached.
        $exurl = ''; // External streams.
        // Check if we are passing an image as file or string.
        if ($file[0] === '@') {
            // Image from string.
            $imgdata = substr($file, 1);
            $file = $this->getobjfilename('img');
            $fp = fopen($file, 'w');
            fwrite($fp, $imgdata);
            fclose($fp);
            unset($imgdata);
            $cachedfile = true;
            $imsize = @getimagesize($file);
            if ($imsize === false) {
                unlink($file);
                $cachedfile = false;
            }
        } else {
            if ($file{0} === '*') {
                // Image as external stream.
                $file = substr($file, 1);
                $exurl = $file;
            }
            // Check if is local file.
            if (!@file_exists($file)) {
                // Encode spaces on filename (file is probably an URL).
                $file = str_replace(' ', '%20', $file);
            }
            if (@file_exists($file)) {
                // Get image dimensions.
                $imsize = @getimagesize($file);
            } else {
                $imsize = false;
            }
            if ($imsize === false) {
                if (function_exists('curl_init')) {
                    // Try to get remote file data using cURL.
                    $cs = curl_init(); // Curl session.
                    curl_setopt($cs, CURLOPT_URL, $file);
                    curl_setopt($cs, CURLOPT_BINARYTRANSFER, true);
                    curl_setopt($cs, CURLOPT_FAILONERROR, true);
                    curl_setopt($cs, CURLOPT_RETURNTRANSFER, true);
                    curl_setopt($cs, CURLOPT_FOLLOWLOCATION, true);
                    curl_setopt($cs, CURLOPT_CONNECTTIMEOUT, 5);
                    curl_setopt($cs, CURLOPT_TIMEOUT, 30);
                    curl_setopt($cs, CURLOPT_SSL_VERIFYPEER, false);
                    curl_setopt($cs, CURLOPT_SSL_VERIFYHOST, false);
                    curl_setopt($cs, CURLOPT_USERAGENT, 'TCPDF');
                    $imgdata = curl_exec($cs);
                    curl_close($cs);
                    if ($imgdata !== false) {
                        // Copy image to cache.
                        $file = $this->getobjfilename('img');
                        $fp = fopen($file, 'w');
                        fwrite($fp, $imgdata);
                        fclose($fp);
                        unset($imgdata);
                        $cachedfile = true;
                        $imsize = @getimagesize($file);
                        if ($imsize === false) {
                            unlink($file);
                            $cachedfile = false;
                        }
                    }
                } else if (($w > 0) AND ($h > 0)) {
                    // Get measures from specified data.
                    $pw = $this->gethtmlunittounits($w, 0, $this->pdfunit, true) * $this->imgscale * $this->k;
                    $ph = $this->gethtmlunittounits($h, 0, $this->pdfunit, true) * $this->imgscale * $this->k;
                    $imsize = array($pw, $ph);
                }
            }
        }
        if ($imsize === false) {
            if (substr($file, 0, -34) == K_PATH_CACHE.'msk') { // Mask file.
                // Get measures from specified data.
                $pw = $this->gethtmlunittounits($w, 0, $this->pdfunit, true) * $this->imgscale * $this->k;
                $ph = $this->gethtmlunittounits($h, 0, $this->pdfunit, true) * $this->imgscale * $this->k;
                $imsize = array($pw, $ph);
            } else {
                $this->errord('[Image] Unable to get image: '.$file);
            }
        }
        // File hash.
        $filehash = md5($this->fileid.$file);
        // Get original image width and height in pixels.
        list($pixw, $pixh) = $imsize;
        // Calculate image width and height on document.
        if (($w <= 0) AND ($h <= 0)) {
            // Convert image size to document unit.
            $w = $this->pixelstounits($pixw);
            $h = $this->pixelstounits($pixh);
        } else if ($w <= 0) {
            $w = $h * $pixw / $pixh;
        } else if ($h <= 0) {
            $h = $w * $pixh / $pixw;
        } else if (($fitbox !== false) AND ($w > 0) AND ($h > 0)) {
            if (strlen($fitbox) !== 2) {
                // Set default alignment.
                $fitbox = '--';
            }
            // Scale image dimensions proportionally to fit within the ($w, $h) box.
            if ((($w * $pixh) / ($h * $pixw)) < 1) {
                // Store current height.
                $oldh = $h;
                // Calculate new height.
                $h = $w * $pixh / $pixw;
                // Height difference.
                $hdiff = ($oldh - $h);
                // Vertical alignment.
                switch (strtoupper($fitbox{1})) {
                    case 'T': {
                        break;
                    }
                    case 'M': {
                        $y += ($hdiff / 2);
                        break;
                    }
                    case 'B': {
                        $y += $hdiff;
                        break;
                    }
                }
            } else {
                // Store current width.
                $oldw = $w;
                // Calculate new width.
                $w = $h * $pixw / $pixh;
                // Width difference.
                $wdiff = ($oldw - $w);
                // Horizontal alignment.
                switch (strtoupper($fitbox{0})) {
                    case 'L': {
                        if ($this->rtl) {
                            $x -= $wdiff;
                        }
                        break;
                    }
                    case 'C': {
                        if ($this->rtl) {
                            $x -= ($wdiff / 2);
                        } else {
                            $x += ($wdiff / 2);
                        }
                        break;
                    }
                    case 'R': {
                        if (!$this->rtl) {
                            $x += $wdiff;
                        }
                        break;
                    }
                }
            }
        }
        // Fit the image on available space.
        list($w, $h, $x, $y) = $this->fitblock($w, $h, $x, $y, $fitonpage);
        // Calculate new minimum dimensions in pixels.
        $neww = round($w * $this->k * $dpi / $this->dpi);
        $newh = round($h * $this->k * $dpi / $this->dpi);
        // Check if resize is necessary (resize is used only to reduce the image).
        $newsize = ($neww * $newh);
        $pixsize = ($pixw * $pixh);
        if (intval($resize) == 2) {
            $resize = true;
        } else if ($newsize >= $pixsize) {
            $resize = false;
        }
        // Check if image has been already added on document.
        $newimage = true;
        if (in_array($file, $this->imagekeys)) {
            $newimage = false;
            // Get existing image data.
            $info = $this->getimagebuffer($file);
            if (substr($file, 0, -34) != K_PATH_CACHE.'msk') {
                // Check if the newer image is larger.
                $oldsize = ($info['w'] * $info['h']);
                if ((($oldsize < $newsize) AND ($resize)) OR (($oldsize < $pixsize) AND (!$resize))) {
                    $newimage = true;
                }
            }
        } else if (substr($file, 0, -34) != K_PATH_CACHE.'msk') {
            // Check for cached images with alpha channel.
            $tempfileplain = K_PATH_CACHE.'mskp_'.$filehash;
            $tempfilealpha = K_PATH_CACHE.'mska_'.$filehash;
            if (in_array($tempfileplain, $this->imagekeys)) {
                // Get existing image data.
                $info = $this->getimagebuffer($tempfileplain);
                // Check if the newer image is larger.
                $oldsize = ($info['w'] * $info['h']);
                if ((($oldsize < $newsize) AND ($resize)) OR (($oldsize < $pixsize) AND (!$resize))) {
                    $newimage = true;
                } else {
                    $newimage = false;
                    // Embed mask image.
                    $imgmask = $this->imageq($tempfilealpha, $x, $y, $w, $h, 'PNG', '', '', $resize, $dpi, '', true,
                                            false);
                    // Embed image, masked with previously embedded mask.
                    return $this->imageq($tempfileplain, $x, $y, $w, $h, $type, $link, $align, $resize, $dpi, $palign,
                                        false, $imgmask);
                }
            }
        }
        if ($newimage) {
            // First use of image, get info.
            $type = strtolower($type);
            if ($type == '') {
                $type = $this->getimagefiletype($file, $imsize);
            } else if ($type == 'jpg') {
                $type = 'jpeg';
            }
            $mqr = $this->get_mqr();
            $this->set_mqr(false);
            // Specific image handlers.
            $mtd = '_parse'.$type;
            // GD image handler function.
            $gdfunction = 'imagecreatefrom'.$type;
            $info = false;
            if ((method_exists($this, $mtd)) AND (!($resize AND (function_exists($gdfunction) OR
                 extension_loaded('imagick'))))) {
                // TCPDF image functions.
                $info = $this->$mtd($file);
                if ($info == 'pngalpha') {
                    return $this->imagepngalpha($file, $x, $y, $pixw, $pixh, $w, $h, 'PNG', $link, $align,
                                                $resize, $dpi, $palign, $filehash);
                }
            }
            if (!$info) {
                if (function_exists($gdfunction)) {
                    // GD library.
                    $img = $gdfunction($file);
                    if ($resize) {
                        $imgr = imagecreatetruecolor($neww, $newh);
                        if (($type == 'gif') OR ($type == 'png')) {
                            $imgr = $this->_setgdimagetransparency($imgr, $img);
                        }
                        imagecopyresampled($imgr, $img, 0, 0, 0, 0, $neww, $newh, $pixw, $pixh);
                        if (($type == 'gif') OR ($type == 'png')) {
                            $info = $this->_topng($imgr);
                        } else {
                            $info = $this->_tojpeg($imgr);
                        }
                    } else {
                        if (($type == 'gif') OR ($type == 'png')) {
                            $info = $this->_topng($img);
                        } else {
                            $info = $this->_tojpeg($img);
                        }
                    }
                } else if (extension_loaded('imagick')) {
                    // ImageMagick library.
                    $img = new Imagick();
                    if ($type == 'SVG') {
                        // Get SVG file content.
                        $svgimg = file_get_contents($file);
                        // Get width and height.
                        $regs = array();
                        if (preg_match('/<svg([^\>]*)>/si', $svgimg, $regs)) {
                            $svgtag = $regs[1];
                            $tmp = array();
                            if (preg_match('/[\s]+width[\s]*=[\s]*"([^"]*)"/si', $svgtag, $tmp)) {
                                $ow = $this->gethtmlunittounits($tmp[1], 1, $this->svgunit, false);
                                $owu = sprintf('%F', ($ow * $dpi / 72)).$this->pdfunit;
                                $svgtag = preg_replace('/[\s]+width[\s]*=[\s]*"[^"]*"/si', ' width="'.$owu.'"', $svgtag, 1);
                            } else {
                                $ow = $w;
                            }
                            $tmp = array();
                            if (preg_match('/[\s]+height[\s]*=[\s]*"([^"]*)"/si', $svgtag, $tmp)) {
                                $oh = $this->gethtmlunittounits($tmp[1], 1, $this->svgunit, false);
                                $ohu = sprintf('%F', ($oh * $dpi / 72)).$this->pdfunit;
                                $svgtag = preg_replace('/[\s]+height[\s]*=[\s]*"[^"]*"/si', ' height="'.$ohu.'"', $svgtag, 1);
                            } else {
                                $oh = $h;
                            }
                            $tmp = array();
                            if (!preg_match('/[\s]+viewBox[\s]*=[\s]*"[\s]*([0-9\.]+)[\s]+([0-9\.]+)[\s]+([0-9\.]+)
                                             [\s]+([0-9\.]+)[\s]*"/si', $svgtag, $tmp)) {
                                $vbw = ($ow * $this->imgscale * $this->k);
                                $vbh = ($oh * $this->imgscale * $this->k);
                                $vbox = sprintf(' viewBox="0 0 %F %F" ', $vbw, $vbh);
                                $svgtag = $vbox.$svgtag;
                            }
                            $svgimg = preg_replace('/<svg([^\>]*)>/si', '<svg'.$svgtag.'>', $svgimg, 1);
                        }
                        $img->readImageBlob($svgimg);
                    } else {
                        $img->readImage($file);
                    }
                    if ($resize) {
                        $img->resizeImage($neww, $newh, 10, 1, false);
                    }
                    $img->setCompressionQuality($this->jpegquality);
                    $img->setImageFormat('jpeg');
                    $tempname = tempnam(K_PATH_CACHE, 'jpg_');
                    $img->writeImage($tempname);
                    $info = $this->_parsejpeg($tempname);
                    unlink($tempname);
                    $img->destroy();
                } else {
                    return;
                }
            }
            if ($info === false) {
                // If false, we cannot process image.
                return;
            }
            $this->set_mqr($mqr);
            if ($ismask) {
                // Force grayscale.
                $info['cs'] = 'DeviceGray';
            }
            $info['i'] = $this->numimages;
            if (!in_array($file, $this->imagekeys)) {
                ++$info['i'];
            }
            if ($imgmask !== false) {
                $info['masked'] = $imgmask;
            }
            if (!empty($exurl)) {
                $info['exurl'] = $exurl;
            }
            // Array of alternative images.
            $info['altimgs'] = $altimgs;
            // Add image to document.
            $this->setimagebuffer($file, $info);
        }
        if ($cachedfile) {
            // Remove cached file.
            unlink($file);
        }
        // Set alignment.
        $this->imgrby = $y + $h;
        // Set alignment.
        if ($this->rtl) {
            if ($palign == 'L') {
                $ximg = $this->lmargin;
            } else if ($palign == 'C') {
                $ximg = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $ximg = $this->w - $this->rmargin - $w;
            } else {
                $ximg = $x - $w;
            }
            $this->imgrbx = $ximg;
        } else {
            if ($palign == 'L') {
                $ximg = $this->lmargin;
            } else if ($palign == 'C') {
                $ximg = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $ximg = $this->w - $this->rmargin - $w;
            } else {
                $ximg = $x;
            }
            $this->imgrbx = $ximg + $w;
        }
        if ($ismask OR $hidden) {
            // Image is not displayed.
            return $info['i'];
        }
        $xkimg = $ximg * $this->k;
        if (!$alt) {
            // Only non-alternative immages will be set.
            $this->_out(sprintf('q %F 0 0 %F %F %F cm /I%u Do Q', ($w * $this->k), ($h * $this->k), $xkimg,
                        (($this->h - ($y + $h)) * $this->k), $info['i']));
        }
        if (!empty($border)) {
            $bx = $this->x;
            $by = $this->y;
            $this->x = $ximg;
            if ($this->rtl) {
                $this->x += $w;
            }
            $this->y = $y;
            $this->cell($w, $h, '', $border, 0, '', 0, '', 0, true);
            $this->x = $bx;
            $this->y = $by;
        }
        if ($link) {
            $this->link($ximg, $y, $w, $h, $link, 0);
        }
        // Set pointer to align the next text/objects.
        switch($align) {
            case 'T': {
                $this->y = $y;
                $this->x = $this->imgrbx;
                break;
            }
            case 'M': {
                $this->y = $y + round($h / 2);
                $this->x = $this->imgrbx;
                break;
            }
            case 'B': {
                $this->y = $this->imgrby;
                $this->x = $this->imgrbx;
                break;
            }
            case 'N': {
                $this->sety($this->imgrby);
                break;
            }
            default:{
                break;
            }
        }
        $this->endlinex = $this->imgrbx;
        if ($this->inxobj) {
            // We are inside an XObject template.
            $this->xobjects[$this->xobjid]['images'][] = $info['i'];
        }
        return $info['i'];
    }

    /**
     * Sets the current active configuration setting of magic_quotes_runtime (if the set_magic_quotes_runtime function exist)
     * @param $mqr (boolean) false for off, TRUE for on.
     * @since 4.6.025 (2009-08-17)
     */
    public function set_mqr($mqr) {
        if (!defined('PHP_VERSION_ID')) {
            $version = PHP_VERSION;
            define('PHP_VERSION_ID', (($version{0} * 10000) + ($version{2} * 100) + $version{4}));
        }
    }

    /**
     * Gets the current active configuration setting of magic_quotes_runtime (if the get_magic_quotes_runtime function exist)
     * @return Returns 0 if magic quotes runtime is off or get_magic_quotes_runtime doesn't exist, 1 otherwise.
     * @since 4.6.025 (2009-08-17)
     */
    public function get_mqr() {
        if (!defined('PHP_VERSION_ID')) {
            $version = PHP_VERSION;
            define('PHP_VERSION_ID', (($version{0} * 10000) + ($version{2} * 100) + $version{4}));
        }
        if (PHP_VERSION_ID < 50300) {
            return @get_magic_quotes_runtime();
        }
        return 0;
    }

    /**
     * Convert the loaded image to a JPEG and then return a structure for the PDF creator.
     * This function requires GD library and write access to the directory defined on K_PATH_CACHE constant.
     * @param $image (image) Image object.
     * return image JPEG image object.
     * @protected
     */
    protected function _tojpeg($image) {
        $tempname = tempnam(K_PATH_CACHE, 'jpg_');
        imagejpeg($image, $tempname, $this->jpegquality);
        imagedestroy($image);
        $retvars = $this->_parsejpeg($tempname);
        // Tidy up by removing temporary image.
        unlink($tempname);
        return $retvars;
    }

    /**
     * Convert the loaded image to a PNG and then return a structure for the PDF creator.
     * This function requires GD library and write access to the directory defined on K_PATH_CACHE constant.
     * @param $image (image) Image object.
     * return image PNG image object.
     * @protected
     * @since 4.9.016 (2010-04-20)
     */
    protected function _topng($image) {
        // Set temporary image file name.
        $tempname = tempnam(K_PATH_CACHE, 'jpg_');
        // Turn off interlaced mode.
        imageinterlace($image, 0);
        // Create temporary PNG image.
        imagepng($image, $tempname);
        // Remove image from memory.
        imagedestroy($image);
        // Get PNG image data.
        $retvars = $this->_parsepng($tempname);
        // Tidy up by removing temporary image.
        unlink($tempname);
        return $retvars;
    }

    /**
     * Set the transparency for the given GD image.
     * @param $newimage (image) GD image object
     * @param $image (image) GD image object.
     * return GD image object.
     * @protected
     * @since 4.9.016 (2010-04-20)
     */
    protected function _setgdimagetransparency($newimage, $image) {
        // Transparency index.
        $tid = imagecolortransparent($image);
        // Default transparency color.
        $tcol = array('red' => 255, 'green' => 255, 'blue' => 255);
        if ($tid >= 0) {
            // Get the colors for the transparency index.
            $tcol = imagecolorsforindex($image, $tid);
        }
        $tid = imagecolorallocate($newimage, $tcol['red'], $tcol['green'], $tcol['blue']);
        imagefill($newimage, 0, 0, $tid);
        imagecolortransparent($newimage, $tid);
        return $newimage;
    }

    /**
     * Extract info from a JPEG file without using the GD library.
     * @param $file (string) image file to parse
     * @return array structure containing the image data
     * @protected
     */
    protected function _parsejpeg($file) {
        $a = getimagesize($file);
        if (empty($a)) {
            $this->errord('Missing or incorrect image file: '.$file);
        }
        if ($a[2] != 2) {
            $this->errord('Not a JPEG file: '.$file);
        }
        // Bits per pixel.
        $bpc = isset($a['bits']) ? intval($a['bits']) : 8;
        // Number of image channels.
        if (!isset($a['channels'])) {
            $channels = 3;
        } else {
            $channels = intval($a['channels']);
        }
        // Default colour space.
        switch ($channels) {
            case 1: {
                $colspace = 'DeviceGray';
                break;
            }
            case 3: {
                $colspace = 'DeviceRGB';
                break;
            }
            case 4: {
                $colspace = 'DeviceCMYK';
                break;
            }
            default: {
                $channels = 3;
                $colspace = 'DeviceRGB';
                break;
            }
        }
        // Get file content.
        $data = file_get_contents($file);
        // Check for embedded ICC profile.
        $icc = array();
        $offset = 0;
        while (($pos = strpos($data, "ICC_PROFILE\0", $offset)) !== false) {
            // Get ICC sequence length.
            $length = ($this->_getushort($data, ($pos - 2)) - 16);
            // Marker sequence number.
            $msn = max(1, ord($data[($pos + 12)]));
            // Number of markers (total of APP2 used).
            $nom = max(1, ord($data[($pos + 13)]));
            // Get sequence segment.
            $icc[($msn - 1)] = substr($data, ($pos + 14), $length);
            // Move forward to next sequence.
            $offset = ($pos + 14 + $length);
        }
        // Order and compact ICC segments.
        if (count($icc) > 0) {
            ksort($icc);
            $icc = implode('', $icc);
            if ((ord($icc{36}) != 0x61) OR (ord($icc{37}) != 0x63) OR (ord($icc{38}) != 0x73) OR (ord($icc{39}) != 0x70)) {
                // Invalid ICC profile.
                $icc = false;
            }
        } else {
            $icc = false;
        }
        return array('w' => $a[0], 'h' => $a[1], 'ch' => $channels, 'icc' => $icc, 'cs' => $colspace, 'bpc' => $bpc,
                     'f' => 'DCTDecode', 'data' => $data);
    }

    /**
     * Extract info from a PNG file without using the GD library.
     * @param $file (string) image file to parse
     * @return array structure containing the image data
     * @protected
     */
    protected function _parsepng($file) {
        $f = fopen($file, 'rb');
        if ($f === false) {
            $this->errord('Can\'t open image file: '.$file);
        }
        // Check signature.
        if (fread($f, 8) != chr(137).'PNG'.chr(13).chr(10).chr(26).chr(10)) {
            $this->errord('Not a PNG file: '.$file);
        }
        // Read header chunk.
        fread($f, 4);
        if (fread($f, 4) != 'IHDR') {
            $this->errord('Incorrect PNG file: '.$file);
        }
        $w = $this->_freadint($f);
        $h = $this->_freadint($f);
        $bpc = ord(fread($f, 1));
        if ($bpc > 8) {
            fclose($f);
            return false;
        }
        $ct = ord(fread($f, 1));
        if ($ct == 0) {
            $colspace = 'DeviceGray';
        } else if ($ct == 2) {
            $colspace = 'DeviceRGB';
        } else if ($ct == 3) {
            $colspace = 'Indexed';
        } else {
            // Alpha channel.
            fclose($f);
            return 'pngalpha';
        }
        if (ord(fread($f, 1)) != 0) {
            fclose($f);
            return false;
        }
        if (ord(fread($f, 1)) != 0) {
            fclose($f);
            return false;
        }
        if (ord(fread($f, 1)) != 0) {
            fclose($f);
            return false;
        }
        fread($f, 4);
        $channels = ($ct == 2 ? 3 : 1);
        $parms = '/DecodeParms << /Predictor 15 /Colors '.$channels.' /BitsPerComponent '.$bpc.' /Columns '.$w.' >>';
        // Scan chunks looking for palette, transparency and image data.
        $pal = '';
        $trns = '';
        $data = '';
        $icc = false;
        do {
            $n = $this->_freadint($f);
            $type = fread($f, 4);
            if ($type == 'PLTE') {
                // Read palette.
                $pal = $this->rfread($f, $n);
                fread($f, 4);
            } else if ($type == 'tRNS') {
                // Read transparency info.
                $t = $this->rfread($f, $n);
                if ($ct == 0) {
                    $trns = array(ord($t{1}));
                } else if ($ct == 2) {
                    $trns = array(ord($t{1}), ord($t{3}), ord($t{5}));
                } else {
                    $pos = strpos($t, chr(0));
                    if ($pos !== false) {
                        $trns = array($pos);
                    }
                }
                fread($f, 4);
            } else if ($type == 'IDAT') {
                // Read image data block.
                $data .= $this->rfread($f, $n);
                fread($f, 4);
            } else if ($type == 'iCCP') {
                // Skip profile name.
                $len = 0;
                while ((ord(fread($f, 1)) > 0) AND ($len < 80)) {
                    ++$len;
                }
                // Skip null separator.
                fread($f, 1);
                // Get compression method.
                if (ord(fread($f, 1)) != 0) {
                    fclose($f);
                    return false;
                }
                // Read ICC Color Profile.
                $icc = $this->rfread($f, ($n - $len - 2));
                // Decompress profile.
                $icc = gzuncompress($icc);
                fread($f, 4);
            } else if ($type == 'IEND') {
                break;
            } else {
                $this->rfread($f, $n + 4);
            }
        } while ($n);
        if (($colspace == 'Indexed') AND (empty($pal))) {
            fclose($f);
            return false;
        }
        fclose($f);
        return array('w' => $w, 'h' => $h, 'ch' => $channels, 'icc' => $icc, 'cs' => $colspace, 'bpc' => $bpc,
                     'f' => 'FlateDecode', 'parms' => $parms, 'pal' => $pal, 'trns' => $trns, 'data' => $data);
    }

    /**
     * Binary-safe and URL-safe file read.
     * Reads up to length bytes from the file pointer referenced by handle. Reading stops as soon as one of the following
       conditions is met: length bytes have been read; EOF (end of file) is reached.
     */
    protected function rfread($handle, $length) {
        $data = fread($handle, $length);
        if ($data === false) {
            return false;
        }
        $rest = $length - strlen($data);
        if ($rest > 0) {
            $data .= $this->rfread($handle, $rest);
        }
        return $data;
    }

    /**
     * Extract info from a PNG image with alpha channel using the GD library.
     * @see imageq()
     */
    protected function imagepngalpha($file, $x, $y, $wpx, $hpx, $w, $h, $type, $link, $align, $resize, $dpi, $palign,
                                     $filehash = '') {
        if (empty($filehash)) {
            $filehash = md5($this->fileid.$file);
        }
        // Create temp image file (without alpha channel).
        $tempfileplain = K_PATH_CACHE.'mskp_'.$filehash;
        // Create temp alpha file.
        $tempfilealpha = K_PATH_CACHE.'mska_'.$filehash;
        if (extension_loaded('imagick')) { // ImageMagick extension
            // ImageMagick library.
            $img = new Imagick();
            $img->readImage($file);
            // Clone image object.
            $imga = $this->objclone($img);
            // Extract alpha channel.
            $img->separateImageChannel(8);
            $img->negateImage(true);
            $img->setImageFormat('png');
            $img->writeImage($tempfilealpha);
            // Remove alpha channel.
            $imga->separateImageChannel(39);
            $imga->setImageFormat('png');
            $imga->writeImage($tempfileplain);
        } else if (function_exists('imagecreatefrompng')) { // GD extension.
            // Generate images.
            $img = imagecreatefrompng($file);
            $imgalpha = imagecreate($wpx, $hpx);
            // Generate gray scale palette (0 -> 255).
            for ($c = 0; $c < 256; ++$c) {
                imagecolorallocate($imgalpha, $c, $c, $c);
            }
            // Extract alpha channel.
            for ($xpx = 0; $xpx < $wpx; ++$xpx) {
                for ($ypx = 0; $ypx < $hpx; ++$ypx) {
                    $color = imagecolorat($img, $xpx, $ypx);
                    $alpha = $this->getgdgamma($color); // Correct gamma.
                    imagesetpixel($imgalpha, $xpx, $ypx, $alpha);
                }
            }
            imagepng($imgalpha, $tempfilealpha);
            imagedestroy($imgalpha);
            // Extract image without alpha channel.
            $imgplain = imagecreatetruecolor($wpx, $hpx);
            imagecopy($imgplain, $img, 0, 0, 0, 0, $wpx, $hpx);
            imagepng($imgplain, $tempfileplain);
            imagedestroy($imgplain);
        } else {
            $this->errord('TCPDF requires the Imagick or GD extension to handle PNG images with alpha channel.');
        }
        // Embed mask image.
        $imgmask = $this->imageq($tempfilealpha, $x, $y, $w, $h, 'PNG', '', '', $resize, $dpi, '', true, false);
        // Embed image, masked with previously embedded mask.
        $this->imageq($tempfileplain, $x, $y, $w, $h, $type, $link, $align, $resize, $dpi, $palign, false, $imgmask);
        // Remove temp files.
        unlink($tempfilealpha);
        unlink($tempfileplain);
    }

    /**
     * Get the GD-corrected PNG gamma value from alpha color
     * @param $c (int) alpha color
     * @protected
     */
    protected function getgdgamma($c) {
        if (!isset($this->gdgammacache["'".$c."'"])) {
            // Shifts off the first 24 bits (where 8x3 are used for each color).
            // And returns the remaining 7 allocated bits (commonly used for alpha).
            $alpha = ($c >> 24);
            // GD alpha is only 7 bit (0 -> 127).
            $alpha = (((127 - $alpha) / 127) * 255);
            // Correct gamma.
            $this->gdgammacache["'".$c."'"] = (pow(($alpha / 255), 2.2) * 255);
            // Store the latest values on cache to improve performances.
            if (count($this->gdgammacache) > 8) {
                // Remove one element from the cache array.
                array_shift($this->gdgammacache);
            }
        }
        return $this->gdgammacache["'".$c."'"];
    }

    /**
     * Performs a line break.
     * The current abscissa goes back to the left margin and the ordinate increases by the amount passed in parameter.
     * @param $h (float) The height of the break. By default, the value equals the height of the last printed cell.
     * @see cell()
     */
    public function ln($h='', $cell = false) {
        if (($this->numcolumns > 1) AND ($this->y == $this->columns[$this->currentcolumn]['y']) AND
            isset($this->columns[$this->currentcolumn]['x']) AND ($this->x == $this->columns[$this->currentcolumn]['x'])) {
            // Remove vertical space from the top of the column.
            return;
        }
        if ($cell) {
            if ($this->rtl) {
                $cellpadding = $this->cellpadding['R'];
            } else {
                $cellpadding = $this->cellpadding['L'];
            }
        } else {
            $cellpadding = 0;
        }
        if ($this->rtl) {
            $this->x = $this->w - $this->rmargin - $cellpadding;
        } else {
            $this->x = $this->lmargin + $cellpadding;
        }
        if (is_string($h)) {
            $this->y += $this->lasth;
        } else {
            $this->y += $h;
        }
        $this->newline = true;
    }

    /**
     * Returns the relative X value of current position.
     * The value is relative to the left border for LTR languages and to the right border for RTL languages.
     * @see setx(), gety(), sety()
     */
    public function getx() {
        // Get x position.
        if ($this->rtl) {
            return ($this->w - $this->x);
        } else {
            return $this->x;
        }
    }

    /**
     * Returns the absolute X value of current position.
     * @see setx(), gety(), sety()
     */
    public function getabsx() {
        return $this->x;
    }

    /**
     * Returns the ordinate of the current position.
     * @see sety(), getx(), setx()
     */
    public function gety() {
        return $this->y;
    }

    /**
     * Defines the abscissa of the current position.
     * If the passed value is negative, it is relative to the right of the page (or left if language is RTL).
     * @see getx(), gety(), sety(), setxy()
     */
    public function setx($x, $rtloff=false) {
        if (!$rtloff AND $this->rtl) {
            if ($x >= 0) {
                $this->x = $this->w - $x;
            } else {
                $this->x = abs($x);
            }
        } else {
            if ($x >= 0) {
                $this->x = $x;
            } else {
                $this->x = $this->w + $x;
            }
        }
        if ($this->x < 0) {
            $this->x = 0;
        }
        if ($this->x > $this->w) {
            $this->x = $this->w;
        }
    }

    /**
     * Moves the current abscissa back to the left margin and sets the ordinate.
     * If the passed value is negative, it is relative to the bottom of the page.
     * @see getx(), gety(), sety(), setxy()
     */
    public function sety($y, $resetx=true, $rtloff=false) {
        if ($resetx) {
            // Reset x.
            if (!$rtloff AND $this->rtl) {
                $this->x = $this->w - $this->rmargin;
            } else {
                $this->x = $this->lmargin;
            }
        }
        if ($y >= 0) {
            $this->y = $y;
        } else {
            $this->y = $this->h + $y;
        }
        if ($this->y < 0) {
            $this->y = 0;
        }
        if ($this->y > $this->h) {
            $this->y = $this->h;
        }
    }

    /**
     * Defines the abscissa and ordinate of the current position.
     * If the passed values are negative, they are relative respectively to the right and bottom of the page.
     * @see setx(), sety()
     */
    public function setxy($x, $y, $rtloff=false) {
        $this->sety($y, false, $rtloff);
        $this->setx($x, $rtloff);
    }

    /**
     * Ouput input data and compress it if possible.
     */
    protected function sendoutputdata($data, $length) {
        if (!isset($_SERVER['HTTP_ACCEPT_ENCODING']) OR empty($_SERVER['HTTP_ACCEPT_ENCODING'])) {
            // The content length may vary if the server is using compression.
            header('Content-Length: '.$length);
        }
        echo $data;
    }

    /**
     * Send the document to a given destination: string, local file or browser.
     * In the last case, the plug-in may be used (if present) or a download
       ("Save as" dialog box) may be forced.<br />
     * The method first calls close() if necessary to terminate the document.
     * @see close()
     */
    public function output($name = 'doc.pdf', $dest = 'I') {
        // Output PDF to some destination.
        // Finish document if necessary.
        if ($this->state < 3) {
            $this->close();
        }
        // Normalize parameters.
        if (is_bool($dest)) {
            $dest = $dest ? 'D' : 'F';
        }
        $dest = strtoupper($dest);
        if ($dest{0} != 'F') {
            $name = preg_replace('/[\s]+/', '_', $name);
            $name = preg_replace('/[^a-zA-Z0-9_\.-]/', '', $name);
        }
        if ($this->sign) {
            // Apply digital signature to the document.
            // Get the document content.
            $pdfdoc = $this->getbuffer();
            // Remove last newline.
            $pdfdoc = substr($pdfdoc, 0, -1);
            // Remove the original buffer.
            if (isset($this->diskcache) AND $this->diskcache) {
                // Remove buffer file from cache.
                unlink($this->buffer);
            }
            unset($this->buffer);
            // Remove filler space.
            $byterangestringlen = strlen($this->byterangestring);
            // Define the ByteRange.
            $byterange = array();
            $byterange[0] = 0;
            $byterange[1] = strpos($pdfdoc, $this->byterangestring) + $byterangestringlen + 10;
            $byterange[2] = $byterange[1] + $this->signaturemaxlength + 2;
            $byterange[3] = strlen($pdfdoc) - $byterange[2];
            $pdfdoc = substr($pdfdoc, 0, $byterange[1]).substr($pdfdoc, $byterange[2]);
            // Replace the ByteRange.
            $byterange = sprintf('/ByteRange[0 %u %u %u]', $byterange[1], $byterange[2], $byterange[3]);
            $byterange .= str_repeat(' ', ($byterangestringlen - strlen($byterange)));
            $pdfdoc = str_replace($this->byterangestring, $byterange, $pdfdoc);
            // Write the document to a temporary folder.
            $tempdoc = tempnam(K_PATH_CACHE, 'tmppdf_');
            $f = fopen($tempdoc, 'wb');
            if (!$f) {
                $this->errord('Unable to create temporary file: '.$tempdoc);
            }
            $pdfdoclength = strlen($pdfdoc);
            fwrite($f, $pdfdoc, $pdfdoclength);
            fclose($f);
            // Get digital signature via openssl library.
            $tempsign = tempnam(K_PATH_CACHE, 'tmpsig_');
            if (empty($this->signaturedata['extracerts'])) {
                openssl_pkcs7_sign($tempdoc, $tempsign, $this->signaturedata['signcert'],
                array($this->signaturedata['privkey'], $this->signaturedata['password']), array(),
                PKCS7_BINARY | PKCS7_DETACHED);
            } else {
                openssl_pkcs7_sign($tempdoc, $tempsign, $this->signaturedata['signcert'],
                array($this->signaturedata['privkey'], $this->signaturedata['password']), array(),
                PKCS7_BINARY | PKCS7_DETACHED, $this->signaturedata['extracerts']);
            }
            unlink($tempdoc);
            // Read signature.
            $signature = file_get_contents($tempsign);
            unlink($tempsign);
            // Extract signature.
            $signature = substr($signature, $pdfdoclength);
            $signature = substr($signature, (strpos($signature, "%%EOF\n\n------") + 13));
            $tmparr = explode("\n\n", $signature);
            $signature = $tmparr[1];
            unset($tmparr);
            // Decode signature.
            $signature = base64_decode(trim($signature));
            // Convert signature to hex.
            $signature = current(unpack('H*', $signature));
            $signature = str_pad($signature, $this->signaturemaxlength, '0');
            // Disable disk caching.
            $this->diskcache = false;
            // Add signature to the document.
            $this->buffer = substr($pdfdoc, 0, $byterange[1]).'<'.$signature.'>'.substr($pdfdoc, $byterange[1]);
            $this->bufferlen = strlen($this->buffer);
        }
        switch($dest) {
            case 'I': {
                // Send PDF to the standard output.
                if (ob_get_contents()) {
                    $this->errord('Some data has already been output, can\'t send PDF file');
                }
                if (php_sapi_name() != 'cli') {
                    // Send output to a browser.
                    header('Content-Type: application/pdf');
                    if (headers_sent()) {
                        $this->errord('Some data has already been output to browser, can\'t send PDF file');
                    }
                    header('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');
                    header('Pragma: public');
                    header('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past.
                    header('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');
                    header('Content-Disposition: inline; filename="'.basename($name).'";');
                    $this->sendoutputdata($this->getbuffer(), $this->bufferlen);
                } else {
                    echo $this->getbuffer();
                }
                break;
            }
            case 'D': {
                // Download PDF as file.
                if (ob_get_contents()) {
                    $this->errord('Some data has already been output, can\'t send PDF file');
                }
                header('Content-Description: File Transfer');
                if (headers_sent()) {
                    $this->errord('Some data has already been output to browser, can\'t send PDF file');
                }
                header('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');
                header('Pragma: public');
                header('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past.
                header('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');
                // Force download dialog.
                if (strpos(php_sapi_name(), 'cgi') === false) {
                    header('Content-Type: application/force-download');
                    header('Content-Type: application/octet-stream', false);
                    header('Content-Type: application/download', false);
                    header('Content-Type: application/pdf', false);
                } else {
                    header('Content-Type: application/pdf');
                }
                // Use the Content-Disposition header to supply a recommended filename.
                header('Content-Disposition: attachment; filename="'.basename($name).'";');
                header('Content-Transfer-Encoding: binary');
                $this->sendoutputdata($this->getbuffer(), $this->bufferlen);
                break;
            }
            case 'F':
            case 'FI':
            case 'FD': {
                // Save PDF to a local file.
                if ($this->diskcache) {
                    copy($this->buffer, $name);
                } else {
                    $f = fopen($name, 'wb');
                    if (!$f) {
                        $this->errord('Unable to create output file: '.$name);
                    }
                    fwrite($f, $this->getbuffer(), $this->bufferlen);
                    fclose($f);
                }
                if ($dest == 'FI') {
                    // Send headers to browser.
                    header('Content-Type: application/pdf');
                    header('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');
                    header('Pragma: public');
                    header('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past.
                    header('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');
                    header('Content-Disposition: inline; filename="'.basename($name).'";');
                    $this->sendoutputdata(file_get_contents($name), filesize($name));
                } else if ($dest == 'FD') {
                    // Send headers to browser.
                    if (ob_get_contents()) {
                        $this->errord('Some data has already been output, can\'t send PDF file');
                    }
                    header('Content-Description: File Transfer');
                    if (headers_sent()) {
                        $this->errord('Some data has already been output to browser, can\'t send PDF file');
                    }
                    header('Cache-Control: private, must-revalidate, post-check=0, pre-check=0, max-age=1');
                    header('Pragma: public');
                    header('Expires: Sat, 26 Jul 1997 05:00:00 GMT'); // Date in the past.
                    header('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');
                    // Force download dialog.
                    if (strpos(php_sapi_name(), 'cgi') === false) {
                        header('Content-Type: application/force-download');
                        header('Content-Type: application/octet-stream', false);
                        header('Content-Type: application/download', false);
                        header('Content-Type: application/pdf', false);
                    } else {
                        header('Content-Type: application/pdf');
                    }
                    // Use the Content-Disposition header to supply a recommended filename.
                    header('Content-Disposition: attachment; filename="'.basename($name).'";');
                    header('Content-Transfer-Encoding: binary');
                    $this->sendoutputdata(file_get_contents($name), filesize($name));
                }
                break;
            }
            case 'E': {
                // Return PDF as base64 mime multi-part email attachment (RFC 2045).
                $retval = 'Content-Type: application/pdf;'."\r\n";
                $retval .= ' name="'.$name.'"'."\r\n";
                $retval .= 'Content-Transfer-Encoding: base64'."\r\n";
                $retval .= 'Content-Disposition: attachment;'."\r\n";
                $retval .= ' filename="'.$name.'"'."\r\n\r\n";
                $retval .= chunk_split(base64_encode($this->getbuffer()), 76, "\r\n");
                return $retval;
            }
            case 'S': {
                // Returns PDF as a string.
                return $this->getbuffer();
            }
            default: {
                $this->errord('Incorrect output destination: '.$dest);
            }
        }
            return '';
    }

    /**
     * Unset all class variables except the following critical variables: internalencoding, state, bufferlen,
       buffer and diskcache.
     */
    public function _destroy($destroyall=false, $preserveobjcopy=false) {
        if ($destroyall AND isset($this->diskcache) AND $this->diskcache AND (!$preserveobjcopy) AND
           (!$this->empty_string($this->buffer))) {
            // Remove buffer file from cache.
            unlink($this->buffer);
        }
        foreach (array_keys(get_object_vars($this)) as $val) {
            if ($destroyall OR (
                ($val != 'internalencoding')
                AND ($val != 'state')
                AND ($val != 'bufferlen')
                AND ($val != 'buffer')
                AND ($val != 'diskcache')
                AND ($val != 'sign')
                AND ($val != 'signaturedata')
                AND ($val != 'signaturemaxlength')
                AND ($val != 'byterangestring')
                )) {
                if ((!$preserveobjcopy OR ($val != 'objcopy')) AND isset($this->$val)) {
                    unset($this->$val);
                }
            }
        }
    }

    /**
     * Check for locale-related bug
     * @protected
     */
    protected function _dochecks() {
        // Check for locale-related bug.
        if (1.1 == 1) {
            $this->errord('Don\'t alter the locale before including class file');
        }
        // Check for decimal separator.
        if (sprintf('%.1F', 1.0) != '1.0') {
            setlocale(LC_NUMERIC, 'C');
        }
    }

    /**
     * Return fonts path
     * @return string
     * @protected
     */
    protected function _getfontpath() {
        if (!defined('K_PATH_FONTS') AND is_dir(dirname(__FILE__).'/fonts')) {
            define('K_PATH_FONTS', dirname(__FILE__).'/fonts/');
        }
        return defined('K_PATH_FONTS') ? K_PATH_FONTS : '';
    }

    /**
     * Return an array containing variations for the basic page number alias.
     * @param $a (string) Base alias.
     * @return array of page number aliases
     * @protected
     */
    protected function getinternalpagenumberaliases($a= '') {
        $alias = array();
        // Build array of Unicode + ASCII variants (the order is important).
        $alias = array('u' => array(), 'a' => array());
        $u = '{'.$a.'}';
        $alias['u'][] = $this->_escape($u);
        if ($this->isunicode) {
            $alias['u'][] = $this->_escape($this->utf8tolatin1($u));
            $alias['u'][] = $this->_escape($this->utf8strrev($u, false, $this->tmprtl));
            $alias['a'][] = $this->_escape($this->utf8tolatin1($a));
            $alias['a'][] = $this->_escape($this->utf8strrev($a, false, $this->tmprtl));
        }
        $alias['a'][] = $this->_escape($a);
        return $alias;
    }

    /**
     * Return an array containing all internal page aliases.
     * @return array of page number aliases
     * @protected
     */
    protected function getallinternalpagenumberaliases() {
        $basicalias = array($this->aliastotpages, $this->aliasnumpage, $this->aliasgrouptotpages,
                             $this->aliasgroupnumpage, $this->aliasrightshift);
        $pnalias = array();
        foreach ($basicalias as $k => $a) {
            $pnalias[$k] = $this->getinternalpagenumberaliases($a);
        }
        return $pnalias;
    }

    /**
     * Replace page number aliases with number.
     */
    protected function replacepagenumaliases($page, $replace, $diff = 0) {
        foreach ($replace as $rep) {
            foreach ($rep[3] as $a) {
                if (strpos($page, $a) !== false) {
                    $page = str_replace($a, $rep[0], $page);
                    $diff += ($rep[2] - $rep[1]);
                }
            }
        }
        return array($page, $diff);
    }

    /**
     * Replace right shift page number aliases with spaces to correct right alignment.
     * This works perfectly only when using monospaced fonts.
     * @param $page (string) Page content.
     * @param $aliases (array) Array of page aliases.
     * @param $diff (int) initial difference to add.
     * @return replaced page content.
     * @protected
     */
    protected function replacerightshiftpagenumaliases($page, $aliases, $diff) {
        foreach ($aliases as $type => $alias) {
            foreach ($alias as $a) {
                // Find position of compensation factor.
                $startnum = (strpos($a, ':') + 1);
                $a = substr($a, 0, $startnum);
                if (($pos = strpos($page, $a)) !== false) {
                    // End of alias.
                    $endnum = strpos($page, '}', $pos);
                    // String to be replaced.
                    $aa = substr($page, $pos, ($endnum - $pos + 1));
                    // Get compensation factor.
                    $ratio = substr($page, ($pos + $startnum), ($endnum - $pos - $startnum));
                    $ratio = preg_replace('/[^0-9\.]/', '', $ratio);
                    $ratio = floatval($ratio);
                    if ($type == 'u') {
                        $chrdiff = floor(($diff + 12) * $ratio);
                        $shift = str_repeat(' ', $chrdiff);
                        $shift = $this->utf8toutf16be($shift, false);
                    } else {
                        $chrdiff = floor(($diff + 11) * $ratio);
                        $shift = str_repeat(' ', $chrdiff);
                    }
                    $page = str_replace($aa, $shift, $page);
                }
            }
        }
        return $page;
    }

    /**
     * Set page boxes to be included on page descriptions.
     * @param $boxes (array) Array of page boxes to set on document: ('MediaBox', 'CropBox', 'BleedBox', 'TrimBox', 'ArtBox').
     * @protected
     */
    protected function setpageboxtypes($boxes) {
        $validboxes = array('MediaBox', 'CropBox', 'BleedBox', 'TrimBox', 'ArtBox');
        $this->pageboxes = array();
        foreach ($boxes as $box) {
            if (in_array($box, $validboxes)) {
                $this->pageboxes[] = $box;
            }
        }
    }

    /**
     * output pages (and replace page number aliases).
     * @protected
     */
    protected function _putpages() {
        $filter = ($this->compress) ? '/Filter /FlateDecode ' : '';
        // Get internal aliases for page numbers.
        $pnalias = $this->getallinternalpagenumberaliases();
        $numpages = $this->numpages;
        $ptpa = $this->formatpagenumber(($this->startingpagenumber + $numpages - 1));
        $ptpu = $this->utf8toutf16be($ptpa, false);
        $ptpnumchars = $this->getnumchars($ptpa);
        $pagegroupnum = 0;
        $groupnum = 0;
        $ptgu = 1;
        $ptga = 1;
        for ($n = 1; $n <= $numpages; ++$n) {
            // Get current page.
            $temppage = $this->getpagebuffer($n);
            $pagelen = strlen($temppage);
            // Set replacements for total pages number.
            $pnpa = $this->formatpagenumber(($this->startingpagenumber + $n - 1));
            $pnpu = $this->utf8toutf16be($pnpa, false);
            $pnpnumchars = $this->getnumchars($pnpa);
            $pdiff = 0; // Difference used for right shift alignment of page numbers.
            $gdiff = 0; // Difference used for right shift alignment of page group numbers.
            if (!empty($this->pagegroups)) {
                if (isset($this->newpagegroup[$n])) {
                    $pagegroupnum = 0;
                    ++$groupnum;
                    $ptga = $this->formatpagenumber($this->pagegroups[$groupnum]);
                    $ptgu = $this->utf8toutf16be($ptga, false);
                    $ptgnumchars = $this->getnumchars($ptga);
                }
                ++$pagegroupnum;
                $pnga = $this->formatpagenumber($pagegroupnum);
                $pngu = $this->utf8toutf16be($pnga, false);
                $pngnumchars = $this->getnumchars($pnga);
                // Replace page numbers.
                $replace = array();
                $replace[] = array($ptgu, $ptgnumchars, 9, $pnalias[2]['u']);
                $replace[] = array($ptga, $ptgnumchars, 7, $pnalias[2]['a']);
                $replace[] = array($pngu, $pngnumchars, 9, $pnalias[3]['u']);
                $replace[] = array($pnga, $pngnumchars, 7, $pnalias[3]['a']);
                list($temppage, $gdiff) = $this->replacepagenumaliases($temppage, $replace, $gdiff);
            }
            // Replace page numbers.
            $replace = array();
            $replace[] = array($ptpu, $ptpnumchars, 9, $pnalias[0]['u']);
            $replace[] = array($ptpa, $ptpnumchars, 7, $pnalias[0]['a']);
            $replace[] = array($pnpu, $pnpnumchars, 9, $pnalias[1]['u']);
            $replace[] = array($pnpa, $pnpnumchars, 7, $pnalias[1]['a']);
            list($temppage, $pdiff) = $this->replacepagenumaliases($temppage, $replace, $pdiff);
            // Replace right shift alias.
            $temppage = $this->replacerightshiftpagenumaliases($temppage, $pnalias[4], max($pdiff, $gdiff));
            // Replace EPS marker.
            $temppage = str_replace($this->epsmarker, '', $temppage);
            // Page.
            $this->pageobjid[$n] = $this->_newobj();
            $out = '<<';
            $out .= ' /Type /Page';
            $out .= ' /Parent 1 0 R';
            $out .= ' /LastModified '.$this->_datestring(0, $this->docmodificationtimestamp);
            $out .= ' /Resources 2 0 R';
            foreach ($this->pageboxes as $box) {
                $out .= ' /'.$box;
                $out .= sprintf(' [%F %F %F %F]', $this->pagedim[$n][$box]['llx'], $this->pagedim[$n][$box]['lly'],
                                $this->pagedim[$n][$box]['urx'], $this->pagedim[$n][$box]['ury']);
            }
            if (isset($this->pagedim[$n]['BoxColorInfo']) AND !empty($this->pagedim[$n]['BoxColorInfo'])) {
                $out .= ' /BoxColorInfo <<';
                foreach ($this->pageboxes as $box) {
                    if (isset($this->pagedim[$n]['BoxColorInfo'][$box])) {
                        $out .= ' /'.$box.' <<';
                        if (isset($this->pagedim[$n]['BoxColorInfo'][$box]['C'])) {
                            $color = $this->pagedim[$n]['BoxColorInfo'][$box]['C'];
                            $out .= ' /C [';
                            $out .= sprintf(' %F %F %F', ($color[0] / 255), ($color[1] / 255), ($color[2] / 255));
                            $out .= ' ]';
                        }
                        if (isset($this->pagedim[$n]['BoxColorInfo'][$box]['W'])) {
                            $out .= ' /W '.($this->pagedim[$n]['BoxColorInfo'][$box]['W'] * $this->k);
                        }
                        if (isset($this->pagedim[$n]['BoxColorInfo'][$box]['S'])) {
                            $out .= ' /S /'.$this->pagedim[$n]['BoxColorInfo'][$box]['S'];
                        }
                        if (isset($this->pagedim[$n]['BoxColorInfo'][$box]['D'])) {
                            $dashes = $this->pagedim[$n]['BoxColorInfo'][$box]['D'];
                            $out .= ' /D [';
                            foreach ($dashes as $dash) {
                                $out .= sprintf(' %F', ($dash * $this->k));
                            }
                            $out .= ' ]';
                        }
                        $out .= ' >>';
                    }
                }
                $out .= ' >>';
            }
            $out .= ' /Contents '.($this->n + 1).' 0 R';
            $out .= ' /rotate '.$this->pagedim[$n]['rotate'];
            if (!$this->pdfamode) {
                $out .= ' /Group << /Type /Group /S /Transparency /CS /DeviceRGB >>';
            }
            if (isset($this->pagedim[$n]['trans']) AND !empty($this->pagedim[$n]['trans'])) {
                // Page transitions.
                if (isset($this->pagedim[$n]['trans']['Dur'])) {
                    $out .= ' /Dur '.$this->pagedim[$n]['trans']['Dur'];
                }
                $out .= ' /Trans <<';
                $out .= ' /Type /Trans';
                if (isset($this->pagedim[$n]['trans']['S'])) {
                    $out .= ' /S /'.$this->pagedim[$n]['trans']['S'];
                }
                if (isset($this->pagedim[$n]['trans']['D'])) {
                    $out .= ' /D '.$this->pagedim[$n]['trans']['D'];
                }
                if (isset($this->pagedim[$n]['trans']['Dm'])) {
                    $out .= ' /Dm /'.$this->pagedim[$n]['trans']['Dm'];
                }
                if (isset($this->pagedim[$n]['trans']['M'])) {
                    $out .= ' /M /'.$this->pagedim[$n]['trans']['M'];
                }
                if (isset($this->pagedim[$n]['trans']['Di'])) {
                    $out .= ' /Di '.$this->pagedim[$n]['trans']['Di'];
                }
                if (isset($this->pagedim[$n]['trans']['SS'])) {
                    $out .= ' /SS '.$this->pagedim[$n]['trans']['SS'];
                }
                if (isset($this->pagedim[$n]['trans']['B'])) {
                    $out .= ' /B '.$this->pagedim[$n]['trans']['B'];
                }
                $out .= ' >>';
            }
            $out .= $this->_getannotsrefs($n);
            $out .= ' /PZ '.$this->pagedim[$n]['PZ'];
            $out .= ' >>';
            $out .= "\n".'endobj';
            $this->_out($out);
            // Page content.
            $p = ($this->compress) ? gzcompress($temppage) : $temppage;
            $this->_newobj();
            $p = $this->_getrawstream($p);
            $this->_out('<<'.$filter.'/Length '.strlen($p).'>> stream'."\n".$p."\n".'endstream'."\n".'endobj');
            if ($this->diskcache) {
                // Remove temporary files.
                unlink($this->pages[$n]);
            }
        }
        // Pages root.
        $out = $this->_getobj(1)."\n";
        $out .= '<< /Type /Pages /Kids [';
        foreach ($this->pageobjid as $pageobj) {
            $out .= ' '.$pageobj.' 0 R';
        }
        $out .= ' ] /Count '.$numpages.' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
    }

    /**
     * output references to page annotations
     */
    protected function _putannotsrefs($n) {
        $this->_out($this->_getannotsrefs($n));
    }

    /**
     * Get references to page annotations.
     */
    protected function _getannotsrefs($n) {
        if (!(isset($this->pageannots[$n]) OR ($this->sign AND isset($this->signaturedata['certtype'])))) {
            return '';
        }
        $out = ' /Annots [';
        if (isset($this->pageannots[$n])) {
            foreach ($this->pageannots[$n] as $key => $val) {
                if (!in_array($val['n'], $this->radiogroups)) {
                    $out .= ' '.$val['n'].' 0 R';
                }
            }
            // Add radiobutton groups.
            if (isset($this->radiobuttongroups[$n])) {
                foreach ($this->radiobuttongroups[$n] as $key => $data) {
                    if (isset($data['n'])) {
                        $out .= ' '.$data['n'].' 0 R';
                    }
                }
            }
        }
        if ($this->sign AND ($n == $this->signatureappearance['page']) AND isset($this->signaturedata['certtype'])) {
            // Set reference for signature object.
            $out .= ' '.$this->sigobjid.' 0 R';
        }
        if (!empty($this->emptysignatureappearance)) {
            foreach ($this->emptysignatureappearance as $esa) {
                if ($esa['page'] == $n) {
                    // Set reference for empty signature objects.
                    $out .= ' '.$esa['objid'].' 0 R';
                }
            }
        }
        $out .= ' ]';
        return $out;
    }

    /**
     * output annotations objects for all pages.
     * !!! THIS METHOD IS NOT YET COMPLETED !!!
     */
    protected function _putannotsobjs() {
        // Reset object counter.
        for ($n = 1; $n <= $this->numpages; ++$n) {
            if (isset($this->pageannots[$n])) {
                // Set page annotations.
                foreach ($this->pageannots[$n] as $key => $pl) {
                    $annotobjid = $this->pageannots[$n][$key]['n'];
                    // Create annotation object for grouping radiobuttons.
                    if (isset($this->radiobuttongroups[$n][$pl['txt']]) AND is_array($this->radiobuttongroups[$n][$pl['txt']])) {
                        $radiobuttonobjid = $this->radiobuttongroups[$n][$pl['txt']]['n'];
                        $annots = '<<';
                        $annots .= ' /Type /Annot';
                        $annots .= ' /Subtype /Widget';
                        $annots .= ' /rect [0 0 0 0]';
                        if ($this->radiobuttongroups[$n][$pl['txt']]['#readonly#']) {
                            // Read only.
                            $annots .= ' /F 68';
                            $annots .= ' /Ff 49153';
                        } else {
                            $annots .= ' /F 4'; // Default print for PDF/A.
                            $annots .= ' /Ff 49152';
                        }
                        $annots .= ' /T '.$this->_datastring($pl['txt'], $radiobuttonobjid);
                        $annots .= ' /FT /Btn';
                        $annots .= ' /Kids [';
                        $defval = '';
                        foreach ($this->radiobuttongroups[$n][$pl['txt']] as $key => $data) {
                            if (isset($data['kid'])) {
                                $annots .= ' '.$data['kid'].' 0 R';
                                if ($data['def'] !== 'Off') {
                                    $defval = $data['def'];
                                }
                            }
                        }
                        $annots .= ' ]';
                        if (!empty($defval)) {
                            $annots .= ' /V /'.$defval;
                        }
                        $annots .= ' >>';
                        $this->_out($this->_getobj($radiobuttonobjid)."\n".$annots."\n".'endobj');
                        $this->formobjid[] = $radiobuttonobjid;
                        // Store object id to be used on Parent entry of Kids.
                        $this->radiobuttongroups[$n][$pl['txt']] = $radiobuttonobjid;
                    }
                    $formfield = false;
                    $pl['opt'] = array_change_key_case($pl['opt'], CASE_LOWER);
                    $a = $pl['x'] * $this->k;
                    $b = $this->pagedim[$n]['h'] - (($pl['y'] + $pl['h']) * $this->k);
                    $c = $pl['w'] * $this->k;
                    $d = $pl['h'] * $this->k;
                    $rect = sprintf('%F %F %F %F', $a, $b, $a + $c, $b + $d);
                    // Create new annotation object.
                    $annots = '<</Type /Annot';
                    $annots .= ' /Subtype /'.$pl['opt']['subtype'];
                    $annots .= ' /rect ['.$rect.']';
                    $ft = array('Btn', 'Tx', 'Ch', 'Sig');
                    if (isset($pl['opt']['ft']) AND in_array($pl['opt']['ft'], $ft)) {
                        $annots .= ' /FT /'.$pl['opt']['ft'];
                        $formfield = true;
                    }
                    $annots .= ' /Contents '.$this->_textstring($pl['txt'], $annotobjid);
                    $annots .= ' /P '.$this->pageobjid[$n].' 0 R';
                    $annots .= ' /NM '.$this->_datastring(sprintf('%04u-%04u', $n, $key), $annotobjid);
                    $annots .= ' /M '.$this->_datestring($annotobjid, $this->docmodificationtimestamp);
                    if (isset($pl['opt']['f'])) {
                        $fval = 0;
                        if (is_array($pl['opt']['f'])) {
                            foreach ($pl['opt']['f'] as $f) {
                                switch (strtolower($f)) {
                                    case 'invisible': {
                                        $fval += 1 << 0;
                                        break;
                                    }
                                    case 'hidden': {
                                        $fval += 1 << 1;
                                        break;
                                    }
                                    case 'print': {
                                        $fval += 1 << 2;
                                        break;
                                    }
                                    case 'nozoom': {
                                        $fval += 1 << 3;
                                        break;
                                    }
                                    case 'norotate': {
                                        $fval += 1 << 4;
                                        break;
                                    }
                                    case 'noview': {
                                        $fval += 1 << 5;
                                        break;
                                    }
                                    case 'readonly': {
                                        $fval += 1 << 6;
                                        break;
                                    }
                                    case 'locked': {
                                        $fval += 1 << 8;
                                        break;
                                    }
                                    case 'togglenoview': {
                                        $fval += 1 << 9;
                                        break;
                                    }
                                    case 'lockedcontents': {
                                        $fval += 1 << 10;
                                        break;
                                    }
                                    default: {
                                        break;
                                    }
                                }
                            }
                        } else {
                            $fval = intval($pl['opt']['f']);
                        }
                    } else {
                        $fval = 4;
                    }
                    if ($this->pdfamode) {
                        // Force print flag for PDF/A mode.
                        $fval |= 4;
                    }
                    $annots .= ' /F '.intval($fval);
                    if (isset($pl['opt']['as']) AND is_string($pl['opt']['as'])) {
                        $annots .= ' /AS /'.$pl['opt']['as'];
                    }
                    if (isset($pl['opt']['ap'])) {
                        // Appearance stream.
                        $annots .= ' /AP <<';
                        if (is_array($pl['opt']['ap'])) {
                            foreach ($pl['opt']['ap'] as $apmode => $apdef) {
                                $annots .= ' /'.strtoupper($apmode);
                                if (is_array($apdef)) {
                                    $annots .= ' <<';
                                    foreach ($apdef as $apstate => $stream) {
                                        // Reference to XObject that define the appearance for this mode-state.
                                        $apsobjid = $this->_putapxobject($c, $d, $stream);
                                        $annots .= ' /'.$apstate.' '.$apsobjid.' 0 R';
                                    }
                                    $annots .= ' >>';
                                } else {
                                    // Reference to XObject that define the appearance for this mode.
                                    $apsobjid = $this->_putapxobject($c, $d, $apdef);
                                    $annots .= ' '.$apsobjid.' 0 R';
                                }
                            }
                        } else {
                            $annots .= $pl['opt']['ap'];
                        }
                        $annots .= ' >>';
                    }
                    if (isset($pl['opt']['bs']) AND (is_array($pl['opt']['bs']))) {
                        $annots .= ' /BS <<';
                        $annots .= ' /Type /Border';
                        if (isset($pl['opt']['bs']['w'])) {
                            $annots .= ' /W '.intval($pl['opt']['bs']['w']);
                        }
                        $bstyles = array('S', 'D', 'B', 'I', 'U');
                        if (isset($pl['opt']['bs']['s']) AND in_array($pl['opt']['bs']['s'], $bstyles)) {
                            $annots .= ' /S /'.$pl['opt']['bs']['s'];
                        }
                        if (isset($pl['opt']['bs']['d']) AND (is_array($pl['opt']['bs']['d']))) {
                            $annots .= ' /D [';
                            foreach ($pl['opt']['bs']['d'] as $cord) {
                                $annots .= ' '.intval($cord);
                            }
                            $annots .= ']';
                        }
                        $annots .= ' >>';
                    } else {
                        $annots .= ' /Border [';
                        if (isset($pl['opt']['border']) AND (count($pl['opt']['border']) >= 3)) {
                            $annots .= intval($pl['opt']['border'][0]).' ';
                            $annots .= intval($pl['opt']['border'][1]).' ';
                            $annots .= intval($pl['opt']['border'][2]);
                            if (isset($pl['opt']['border'][3]) AND is_array($pl['opt']['border'][3])) {
                                $annots .= ' [';
                                foreach ($pl['opt']['border'][3] as $dash) {
                                    $annots .= intval($dash).' ';
                                }
                                $annots .= ']';
                            }
                        } else {
                            $annots .= '0 0 0';
                        }
                        $annots .= ']';
                    }
                    if (isset($pl['opt']['be']) AND (is_array($pl['opt']['be']))) {
                        $annots .= ' /BE <<';
                        $bstyles = array('S', 'C');
                        if (isset($pl['opt']['be']['s']) AND in_array($pl['opt']['be']['s'], $markups)) {
                            $annots .= ' /S /'.$pl['opt']['bs']['s'];
                        } else {
                            $annots .= ' /S /S';
                        }
                        if (isset($pl['opt']['be']['i']) AND ($pl['opt']['be']['i'] >= 0) AND ($pl['opt']['be']['i'] <= 2)) {
                            $annots .= ' /I '.sprintf(' %F', $pl['opt']['be']['i']);
                        }
                        $annots .= '>>';
                    }
                    if (isset($pl['opt']['c']) AND (is_array($pl['opt']['c'])) AND !empty($pl['opt']['c'])) {
                        $annots .= ' /C '.$this->getcolorstringfromarray($pl['opt']['c']);
                    }
                    $markups = array('text', 'freetext', 'line', 'square', 'circle', 'polygon', 'polyline',
                                     'highlight', 'underline', 'squiggly', 'strikeout', 'stamp', 'caret', 'ink',
                                     'fileattachment', 'sound');
                    if (in_array(strtolower($pl['opt']['subtype']), $markups)) {
                        // This is a markup type.
                        if (isset($pl['opt']['t']) AND is_string($pl['opt']['t'])) {
                            $annots .= ' /T '.$this->_textstring($pl['opt']['t'], $annotobjid);
                        }
                        if (isset($pl['opt']['ca'])) {
                            $annots .= ' /CA '.sprintf('%F', floatval($pl['opt']['ca']));
                        }
                        if (isset($pl['opt']['rc'])) {
                            $annots .= ' /RC '.$this->_textstring($pl['opt']['rc'], $annotobjid);
                        }
                        $annots .= ' /CreationDate '.$this->_datestring($annotobjid, $this->doccreationtimestamp);
                        if (isset($pl['opt']['subj'])) {
                            $annots .= ' /Subj '.$this->_textstring($pl['opt']['subj'], $annotobjid);
                        }
                    }
                    $lineendings = array('Square', 'circle', 'Diamond', 'Openarrow', 'Closedarrow', 'None',
                                         'Butt', 'ROpenarrow', 'RClosedarrow', 'Slash');
                    // Annotation types.
                    switch (strtolower($pl['opt']['subtype'])) {
                        case 'text': {
                            if (isset($pl['opt']['open'])) {
                                $annots .= ' /open '. (strtolower($pl['opt']['open']) == 'true' ? 'true' : 'false');
                            }
                            $iconsapp = array('Comment', 'Help', 'Insert', 'Key', 'NewParagraph', 'Note', 'Paragraph');
                            if (isset($pl['opt']['name']) AND in_array($pl['opt']['name'], $iconsapp)) {
                                $annots .= ' /Name /'.$pl['opt']['name'];
                            } else {
                                $annots .= ' /Name /Note';
                            }
                            $statemodels = array('Marked', 'Review');
                            if (isset($pl['opt']['statemodel']) AND in_array($pl['opt']['statemodel'], $statemodels)) {
                                $annots .= ' /StateModel /'.$pl['opt']['statemodel'];
                            } else {
                                $pl['opt']['statemodel'] = 'Marked';
                                $annots .= ' /StateModel /'.$pl['opt']['statemodel'];
                            }
                            if ($pl['opt']['statemodel'] == 'Marked') {
                                $states = array('Accepted', 'Unmarked');
                            } else {
                                $states = array('Accepted', 'Rejected', 'Cancelled', 'Completed', 'None');
                            }
                            if (isset($pl['opt']['state']) AND in_array($pl['opt']['state'], $states)) {
                                $annots .= ' /State /'.$pl['opt']['state'];
                            } else {
                                if ($pl['opt']['statemodel'] == 'Marked') {
                                    $annots .= ' /State /Unmarked';
                                } else {
                                    $annots .= ' /State /None';
                                }
                            }
                            break;
                        }
                        case 'link': {
                            if (is_string($pl['txt'])) {
                                // External URI link.
                                $annots .= ' /A <</S /URI /URI '.$this->_datastring($this->unhtmlentities($pl['txt']),
                                           $annotobjid).'>>';
                            } else {
                                // Internal link.
                                if (isset($this->links[$pl['txt']])) {
                                    $l = $this->links[$pl['txt']];
                                    if (isset($this->pageobjid[($l[0])])) {
                                        $annots .= sprintf(' /Dest [%u 0 R /XYZ 0 %F null]', $this->pageobjid[($l[0])],
                                                          ($this->pagedim[$l[0]]['h'] - ($l[1] * $this->k)));
                                    }
                                }
                            }
                            $hmodes = array('N', 'I', 'O', 'P');
                            if (isset($pl['opt']['h']) AND in_array($pl['opt']['h'], $hmodes)) {
                                $annots .= ' /H /'.$pl['opt']['h'];
                            } else {
                                $annots .= ' /H /I';
                            }
                            break;
                        }
                        case 'freetext': {
                            if (isset($pl['opt']['da']) AND !empty($pl['opt']['da'])) {
                                $annots .= ' /DA ('.$pl['opt']['da'].')';
                            }
                            if (isset($pl['opt']['q']) AND ($pl['opt']['q'] >= 0) AND ($pl['opt']['q'] <= 2)) {
                                $annots .= ' /Q '.intval($pl['opt']['q']);
                            }
                            if (isset($pl['opt']['rc'])) {
                                $annots .= ' /RC '.$this->_textstring($pl['opt']['rc'], $annotobjid);
                            }
                            if (isset($pl['opt']['ds'])) {
                                $annots .= ' /DS '.$this->_textstring($pl['opt']['ds'], $annotobjid);
                            }
                            if (isset($pl['opt']['cl']) AND is_array($pl['opt']['cl'])) {
                                $annots .= ' /CL [';
                                foreach ($pl['opt']['cl'] as $cl) {
                                    $annots .= sprintf('%F ', $cl * $this->k);
                                }
                                $annots .= ']';
                            }
                            $tfit = array('Freetext', 'FreetextCallout', 'FreetextTypewriter');
                            if (isset($pl['opt']['it']) AND in_array($pl['opt']['it'], $tfit)) {
                                $annots .= ' /IT /'.$pl['opt']['it'];
                            }
                            if (isset($pl['opt']['rd']) AND is_array($pl['opt']['rd'])) {
                                $l = $pl['opt']['rd'][0] * $this->k;
                                $r = $pl['opt']['rd'][1] * $this->k;
                                $t = $pl['opt']['rd'][2] * $this->k;
                                $b = $pl['opt']['rd'][3] * $this->k;
                                $annots .= ' /RD ['.sprintf('%F %F %F %F', $l, $r, $t, $b).']';
                            }
                            if (isset($pl['opt']['le']) AND in_array($pl['opt']['le'], $lineendings)) {
                                $annots .= ' /LE /'.$pl['opt']['le'];
                            }
                            break;
                        }
                        case 'line': {
                            break;
                        }
                        case 'square': {
                            break;
                        }
                        case 'circle': {
                            break;
                        }
                        case 'polygon': {
                            break;
                        }
                        case 'polyline': {
                            break;
                        }
                        case 'highlight': {
                            break;
                        }
                        case 'underline': {
                            break;
                        }
                        case 'squiggly': {
                            break;
                        }
                        case 'strikeout': {
                            break;
                        }
                        case 'stamp': {
                            break;
                        }
                        case 'caret': {
                            break;
                        }
                        case 'ink': {
                            break;
                        }
                        case 'popup': {
                            break;
                        }
                        case 'fileattachment': {
                            if ($this->pdfamode) {
                                // Embedded files are not allowed in PDF/A mode.
                                break;
                            }
                            if (!isset($pl['opt']['fs'])) {
                                break;
                            }
                            $filename = basename($pl['opt']['fs']);
                            if (isset($this->embeddedfiles[$filename]['n'])) {
                                $annots .= ' /FS <</Type /Filespec /F '.$this->_datastring($filename, $annotobjid).
                                           ' /EF <</F '.$this->embeddedfiles[$filename]['n'].' 0 R>> >>';
                                $iconsapp = array('Graph', 'Paperclip', 'PushPin', 'Tag');
                                if (isset($pl['opt']['name']) AND in_array($pl['opt']['name'], $iconsapp)) {
                                    $annots .= ' /Name /'.$pl['opt']['name'];
                                } else {
                                    $annots .= ' /Name /PushPin';
                                }
                            }
                            break;
                        }
                        case 'sound': {
                            if (!isset($pl['opt']['fs'])) {
                                break;
                            }
                            $filename = basename($pl['opt']['fs']);
                            if (isset($this->embeddedfiles[$filename]['n'])) {
                                // TO BE COMPLETED.
                                $annots .= ' /Sound <</Type /Filespec /F '.$this->_datastring($filename, $annotobjid).'
                                             /EF <</F '.$this->embeddedfiles[$filename]['n'].' 0 R>> >>';
                                $iconsapp = array('Speaker', 'Mic');
                                if (isset($pl['opt']['name']) AND in_array($pl['opt']['name'], $iconsapp)) {
                                    $annots .= ' /Name /'.$pl['opt']['name'];
                                } else {
                                    $annots .= ' /Name /Speaker';
                                }
                            }
                            break;
                        }
                        case 'movie': {
                            break;
                        }
                        case 'widget': {
                            $hmode = array('N', 'I', 'O', 'P', 'T');
                            if (isset($pl['opt']['h']) AND in_array($pl['opt']['h'], $hmode)) {
                                $annots .= ' /H /'.$pl['opt']['h'];
                            }
                            if (isset($pl['opt']['mk']) AND (is_array($pl['opt']['mk'])) AND !empty($pl['opt']['mk'])) {
                                $annots .= ' /MK <<';
                                if (isset($pl['opt']['mk']['r'])) {
                                    $annots .= ' /R '.$pl['opt']['mk']['r'];
                                }
                                if (isset($pl['opt']['mk']['bc']) AND (is_array($pl['opt']['mk']['bc']))) {
                                    $annots .= ' /BC '.$this->getcolorstringfromarray($pl['opt']['mk']['bc']);
                                }
                                if (isset($pl['opt']['mk']['bg']) AND (is_array($pl['opt']['mk']['bg']))) {
                                    $annots .= ' /BG '.$this->getcolorstringfromarray($pl['opt']['mk']['bg']);
                                }
                                if (isset($pl['opt']['mk']['ca'])) {
                                    $annots .= ' /CA '.$pl['opt']['mk']['ca'];
                                }
                                if (isset($pl['opt']['mk']['rc'])) {
                                    $annots .= ' /RC '.$pl['opt']['mk']['rc'];
                                }
                                if (isset($pl['opt']['mk']['ac'])) {
                                    $annots .= ' /AC '.$pl['opt']['mk']['ac'];
                                }
                                if (isset($pl['opt']['mk']['i'])) {
                                    $info = $this->getimagebuffer($pl['opt']['mk']['i']);
                                    if ($info !== false) {
                                        $annots .= ' /I '.$info['n'].' 0 R';
                                    }
                                }
                                if (isset($pl['opt']['mk']['ri'])) {
                                    $info = $this->getimagebuffer($pl['opt']['mk']['ri']);
                                    if ($info !== false) {
                                        $annots .= ' /RI '.$info['n'].' 0 R';
                                    }
                                }
                                if (isset($pl['opt']['mk']['ix'])) {
                                    $info = $this->getimagebuffer($pl['opt']['mk']['ix']);
                                    if ($info !== false) {
                                        $annots .= ' /IX '.$info['n'].' 0 R';
                                    }
                                }
                                if (isset($pl['opt']['mk']['if']) AND (is_array($pl['opt']['mk']['if'])) AND
                                    !empty($pl['opt']['mk']['if'])) {
                                    $annots .= ' /IF <<';
                                    $ifsw = array('A', 'B', 'S', 'N');
                                    if (isset($pl['opt']['mk']['if']['sw']) AND in_array($pl['opt']['mk']['if']['sw'], $ifsw)) {
                                        $annots .= ' /SW /'.$pl['opt']['mk']['if']['sw'];
                                    }
                                    $ifs = array('A', 'P');
                                    if (isset($pl['opt']['mk']['if']['s']) AND in_array($pl['opt']['mk']['if']['s'], $ifs)) {
                                        $annots .= ' /S /'.$pl['opt']['mk']['if']['s'];
                                    }
                                    if (isset($pl['opt']['mk']['if']['a']) AND (is_array($pl['opt']['mk']['if']['a'])) AND
                                    !empty($pl['opt']['mk']['if']['a'])) {
                                        $annots .= sprintf(' /A [%F %F]', $pl['opt']['mk']['if']['a'][0],
                                        $pl['opt']['mk']['if']['a'][1]);
                                    }
                                    if (isset($pl['opt']['mk']['if']['fb']) AND ($pl['opt']['mk']['if']['fb'])) {
                                        $annots .= ' /FB true';
                                    }
                                    $annots .= '>>';
                                }
                                if (isset($pl['opt']['mk']['tp']) AND ($pl['opt']['mk']['tp'] >= 0) AND
                                ($pl['opt']['mk']['tp'] <= 6)) {
                                    $annots .= ' /TP '.intval($pl['opt']['mk']['tp']);
                                }
                                $annots .= '>>';
                            } // End MK.
                            // Entries for field dictionaries.
                            if (isset($this->radiobuttongroups[$n][$pl['txt']])) {
                                // Set parent.
                                $annots .= ' /Parent '.$this->radiobuttongroups[$n][$pl['txt']].' 0 R';
                            }
                            if (isset($pl['opt']['t']) AND is_string($pl['opt']['t'])) {
                                $annots .= ' /T '.$this->_datastring($pl['opt']['t'], $annotobjid);
                            }
                            if (isset($pl['opt']['tu']) AND is_string($pl['opt']['tu'])) {
                                $annots .= ' /TU '.$this->_datastring($pl['opt']['tu'], $annotobjid);
                            }
                            if (isset($pl['opt']['tm']) AND is_string($pl['opt']['tm'])) {
                                $annots .= ' /TM '.$this->_datastring($pl['opt']['tm'], $annotobjid);
                            }
                            if (isset($pl['opt']['ff'])) {
                                if (is_array($pl['opt']['ff'])) {
                                    // Array of bit settings.
                                    $flag = 0;
                                    foreach ($pl['opt']['ff'] as $val) {
                                        $flag += 1 << ($val - 1);
                                    }
                                } else {
                                    $flag = intval($pl['opt']['ff']);
                                }
                                $annots .= ' /Ff '.$flag;
                            }
                            if (isset($pl['opt']['maxlen'])) {
                                $annots .= ' /MaxLen '.intval($pl['opt']['maxlen']);
                            }
                            if (isset($pl['opt']['v'])) {
                                $annots .= ' /V';
                                if (is_array($pl['opt']['v'])) {
                                    foreach ($pl['opt']['v'] as $optval) {
                                        if (is_float($optval)) {
                                            $optval = sprintf('%F', $optval);
                                        }
                                        $annots .= ' '.$optval;
                                    }
                                } else {
                                    $annots .= ' '.$this->_textstring($pl['opt']['v'], $annotobjid);
                                }
                            }
                            if (isset($pl['opt']['dv'])) {
                                $annots .= ' /DV';
                                if (is_array($pl['opt']['dv'])) {
                                    foreach ($pl['opt']['dv'] as $optval) {
                                        if (is_float($optval)) {
                                            $optval = sprintf('%F', $optval);
                                        }
                                        $annots .= ' '.$optval;
                                    }
                                } else {
                                    $annots .= ' '.$this->_textstring($pl['opt']['dv'], $annotobjid);
                                }
                            }
                            if (isset($pl['opt']['rv'])) {
                                $annots .= ' /RV';
                                if (is_array($pl['opt']['rv'])) {
                                    foreach ($pl['opt']['rv'] as $optval) {
                                        if (is_float($optval)) {
                                            $optval = sprintf('%F', $optval);
                                        }
                                        $annots .= ' '.$optval;
                                    }
                                } else {
                                    $annots .= ' '.$this->_textstring($pl['opt']['rv'], $annotobjid);
                                }
                            }
                            if (isset($pl['opt']['a']) AND !empty($pl['opt']['a'])) {
                                $annots .= ' /A << '.$pl['opt']['a'].' >>';
                            }
                            if (isset($pl['opt']['aa']) AND !empty($pl['opt']['aa'])) {
                                $annots .= ' /AA << '.$pl['opt']['aa'].' >>';
                            }
                            if (isset($pl['opt']['da']) AND !empty($pl['opt']['da'])) {
                                $annots .= ' /DA ('.$pl['opt']['da'].')';
                            }
                            if (isset($pl['opt']['q']) AND ($pl['opt']['q'] >= 0) AND ($pl['opt']['q'] <= 2)) {
                                $annots .= ' /Q '.intval($pl['opt']['q']);
                            }
                            if (isset($pl['opt']['opt']) AND (is_array($pl['opt']['opt'])) AND
                                !empty($pl['opt']['opt'])) {
                                $annots .= ' /Opt [';
                                foreach ($pl['opt']['opt'] as $copt) {
                                    if (is_array($copt)) {
                                        $annots .= ' ['.$this->_textstring($copt[0], $annotobjid).'
                                                      '.$this->_textstring($copt[1], $annotobjid).']';
                                    } else {
                                        $annots .= ' '.$this->_textstring($copt, $annotobjid);
                                    }
                                }
                                $annots .= ']';
                            }
                            if (isset($pl['opt']['ti'])) {
                                $annots .= ' /TI '.intval($pl['opt']['ti']);
                            }
                            if (isset($pl['opt']['i']) AND (is_array($pl['opt']['i'])) AND !empty($pl['opt']['i'])) {
                                $annots .= ' /I [';
                                foreach ($pl['opt']['i'] as $copt) {
                                    $annots .= intval($copt).' ';
                                }
                                $annots .= ']';
                            }
                            break;
                        }
                        case 'screen': {
                            break;
                        }
                        case 'printermark': {
                            break;
                        }
                        case 'trapnet': {
                            break;
                        }
                        case 'watermark': {
                            break;
                        }
                        case '3d': {
                            break;
                        }
                        default: {
                            break;
                        }
                    }
                    $annots .= '>>';
                    // Create new annotation object.
                    $this->_out($this->_getobj($annotobjid)."\n".$annots."\n".'endobj');
                    if ($formfield AND !isset($this->radiobuttongroups[$n][$pl['txt']])) {
                        // Store reference of form object.
                        $this->formobjid[] = $annotobjid;
                    }
                }
            }
        } // End for each page.
    }

    /**
     * Put appearance streams XObject used to define annotation's appearance states.
     */
    protected function _putapxobject($w=0, $h=0, $stream='') {
        $stream = trim($stream);
        $out = $this->_getobj()."\n";
        $this->xobjects['AX'.$this->n] = array('n' => $this->n);
        $out .= '<<';
        $out .= ' /Type /XObject';
        $out .= ' /Subtype /Form';
        $out .= ' /FormType 1';
        if ($this->compress) {
            $stream = gzcompress($stream);
            $out .= ' /Filter /FlateDecode';
        }
        $rect = sprintf('%F %F', $w, $h);
        $out .= ' /BBox [0 0 '.$rect.']';
        $out .= ' /Matrix [1 0 0 1 0 0]';
        $out .= ' /Resources 2 0 R';
        $stream = $this->_getrawstream($stream);
        $out .= ' /Length '.strlen($stream);
        $out .= ' >>';
        $out .= ' stream'."\n".$stream."\n".'endstream';
        $out .= "\n".'endobj';
        $this->_out($out);
        return $this->n;
    }

    /**
     * Get ULONG from string (Big Endian 32-bit unsigned integer).
     */
    protected function _getulong($str, $offset) {
        $v = unpack('Ni', substr($str, $offset, 4));
        return $v['i'];
    }

    /**
     * Get USHORT from string (Big Endian 16-bit unsigned integer).
     */
    protected function _getushort($str, $offset) {
        $v = unpack('ni', substr($str, $offset, 2));
        return $v['i'];
    }

    /**
     * Get SHORT from string (Big Endian 16-bit signed integer).
     */
    protected function _getshort($str, $offset) {
        $v = unpack('si', substr($str, $offset, 2));
        return $v['i'];
    }

    /**
     * Get FWORD from string (Big Endian 16-bit signed integer).
     */
    protected function _getfword($str, $offset) {
        $v = $this->_getushort($str, $offset);
        if ($v > 0x7fff) {
            $v -= 0x10000;
        }
        return $v;
    }

    /**
     * Get UFWORD from string (Big Endian 16-bit unsigned integer).
     */
    protected function _getufword($str, $offset) {
        $v = $this->_getushort($str, $offset);
        return $v;
    }

    /**
     * Get FIXED from string (32-bit signed fixed-point number (16.16).
     */
    protected function _getfixed($str, $offset) {
        // Mantissa.
        $m = $this->_getfword($str, $offset);
        // Fraction.
        $f = $this->_getushort($str, ($offset + 2));
        $v = floatval(''.$m.'.'.$f.'');
        return $v;
    }

    /**
     * Get BYTE from string (8-bit unsigned integer).
     */
    protected function _getbyte($str, $offset) {
        $v = unpack('Ci', substr($str, $offset, 1));
        return $v['i'];
    }
    /**
     * Update the CIDToGIDMap string with a new value.
     */
    protected function updatecidtogidmap($map, $cid, $gid) {
        if (($cid >= 0) AND ($cid <= 0xFFFF) AND ($gid >= 0)) {
            if ($gid > 0xFFFF) {
                $gid -= 0x10000;
            }
            $map[($cid * 2)] = chr($gid >> 8);
            $map[(($cid * 2) + 1)] = chr($gid & 0xFF);
        }
        return $map;
    }

    /**
     * Convert and add the selected TrueType or Type1 font to the fonts folder (that must be writeable).
     */
    public function addttffont($fontfile, $fonttype = '', $enc = '', $flags = 32, $outpath = '', $platid = 3, $encid = 1) {
        if (!file_exists($fontfile)) {
            $this->errord('Could not find file: '.$fontfile.'');
        }
        // Font metrics.
        $fmetric = array();
        // Build new font name for TCPDF compatibility.
        $fontpathparts = pathinfo($fontfile);
        if (!isset($fontpathparts['filename'])) {
            $fontpathparts['filename'] = substr($fontpathparts['basename'], 0, -(strlen($fontpathparts['extension']) + 1));
        }
        $fontname = strtolower($fontpathparts['filename']);
        $fontname = preg_replace('/[^a-z0-9_]/', '', $fontname);
        $search  = array('bold', 'oblique', 'italic', 'regular');
        $replace = array('b', 'i', 'i', '');
        $fontname = str_replace($search, $replace, $fontname);
        if (empty($fontname)) {
            // Set generic name.
            $fontname = 'tcpdffont';
        }
        // Set output path.
        if (empty($outpath)) {
            $outpath = $this->_getfontpath();
        }
        // Check if this font already exist.
        if (file_exists($outpath.$fontname.'.php')) {
            // This font already exist (delete it from fonts folder to rebuild it).
            return $fontname;
        }
        $fmetric['file'] = $fontname.'.z';
        $fmetric['ctg'] = $fontname.'.ctg.z';
        // Get font data.
        $font = file_get_contents($fontfile);
        $fmetric['originalsize'] = strlen($font);
        // Autodetect font type.
        if (empty($fonttype)) {
            if ($this->_getulong($font, 0) == 0x10000) {
                // True Type (Unicode or not).
                $fonttype = 'TrueTypeUnicode';
            } else if (substr($font, 0, 4) == 'OTTO') {
                // Open Type (Unicode or not).
                $this->errord('Unsupported font format: OpenType with CFF data.');
            } else {
                // Type 1.
                $fonttype = 'Type1';
            }
        }
        // Set font type.
        switch ($fonttype) {
            case 'CID0CT':
            case 'CID0CS':
            case 'CID0KR':
            case 'CID0JP': {
                $fmetric['type'] = 'cidfont0';
                break;
            }
            case 'Type1': {
                $fmetric['type'] = 'Type1';
                if (empty($enc) AND (($flags & 4) == 0)) {
                    $enc = 'cp1252';
                }
                break;
            }
            case 'TrueType': {
                $fmetric['type'] = 'TrueType';
                break;
            }
            case 'TrueTypeUnicode':
            default: {
                $fmetric['type'] = 'TrueTypeUnicode';
                break;
            }
        }
        // Set encoding maps (if any).
        $fmetric['enc'] = preg_replace('/[^A-Za-z0-9_\-]/', '', $enc);
        $fmetric['diff'] = '';
        if (($fmetric['type'] == 'TrueType') OR ($fmetric['type'] == 'Type1')) {
            if (!empty($enc) AND ($enc != 'cp1252') AND isset($this->encmaps->encmap[$enc])) {
                // Build differences from reference encoding.
                $encref = $this->encmaps->encmap['cp1252'];
                $enctarget = $this->encmaps->encmap[$enc];
                $last = 0;
                for ($i = 32; $i <= 255; ++$i) {
                    if ($enctarget != $encref[$i]) {
                        if ($i != ($last + 1)) {
                            $fmetric['diff'] .= $i.' ';
                        }
                        $last = $i;
                        $fmetric['diff'] .= '/'.$enctarget[$i].' ';
                    }
                }
            }
        }
        // Parse the font by type.
        if ($fmetric['type'] == 'Type1') {
            // TYPE 1.
            // Read first segment.
            $a = unpack('Cmarker/Ctype/Vsize', substr($font, 0, 6));
            if ($a['marker'] != 128) {
                $this->errord('Font file is not a valid binary Type1');
            }
            $fmetric['size1'] = $a['size'];
            $data = substr($font, 6, $fmetric['size1']);
            // Read second segment.
            $a = unpack('Cmarker/Ctype/Vsize', substr($font, (6 + $fmetric['size1']), 6));
            if ($a['marker'] != 128) {
                $this->errord('Font file is not a valid binary Type1');
            }
            $fmetric['size2'] = $a['size'];
            $encrypted = substr($font, (12 + $fmetric['size1']), $fmetric['size2']);
            $data .= $encrypted;
            // Store compressed font.
            $fp = fopen($outpath.$fmetric['file'], 'wb');
            fwrite($fp, gzcompress($data));
            fclose($fp);
            // Get font info.
            $fmetric['Flags'] = $flags;
            preg_match ('#/FullName[\s]*\(([^\)]*)#', $font, $matches);
            $fmetric['name'] = preg_replace('/[^a-zA-Z0-9_\-]/', '', $matches[1]);
            preg_match('#/FontBBox[\s]*{([^}]*)#', $font, $matches);
            $fmetric['bbox'] = trim($matches[1]);
            $bv = explode(' ', $fmetric['bbox']);
            $fmetric['Ascent'] = intval($bv[3]);
            $fmetric['Descent'] = intval($bv[1]);
            preg_match('#/ItalicAngle[\s]*([0-9\+\-]*)#', $font, $matches);
            $fmetric['italicAngle'] = intval($matches[1]);
            if ($fmetric['italicAngle'] != 0) {
                $fmetric['Flags'] |= 64;
            }
            preg_match('#/UnderlinePosition[\s]*([0-9\+\-]*)#', $font, $matches);
            $fmetric['underlinePosition'] = intval($matches[1]);
            preg_match('#/UnderlineThickness[\s]*([0-9\+\-]*)#', $font, $matches);
            $fmetric['underlineThickness'] = intval($matches[1]);
            preg_match('#/isfixedpitch[\s]*([^\s]*)#', $font, $matches);
            if ($matches[1] == 'true') {
                $fmetric['Flags'] |= 1;
            }
            // Get internal map.
            $imap = array();
            if (preg_match_all('#dup[\s]([0-9]+)[\s]*/([^\s]*)[\s]put#sU', $font, $fmap, PREG_SET_ORDER) > 0) {
                foreach ($fmap as $v) {
                    $imap[$v[2]] = $v[1];
                }
            }
            // Decrypt eexec encrypted part.
            $r = 55665; // Eexec encryption constant.
            $c1 = 52845;
            $c2 = 22719;
            $elen = strlen($encrypted);
            $eplain = '';
            for ($i = 0; $i < $elen; ++$i) {
                $chr = ord($encrypted[$i]);
                $eplain .= chr($chr ^ ($r >> 8));
                $r = ((($chr + $r) * $c1 + $c2) % 65536);
            }
            if (preg_match('#/ForceBold[\s]*([^\s]*)#', $eplain, $matches) > 0) {
                if ($matches[1] == 'true') {
                    $fmetric['Flags'] |= 0x40000;
                }
            }
            if (preg_match('#/StdVW[\s]*\[([^\]]*)#', $eplain, $matches) > 0) {
                $fmetric['StemV'] = intval($matches[1]);
            } else {
                $fmetric['StemV'] = 70;
            }
            if (preg_match('#/StdHW[\s]*\[([^\]]*)#', $eplain, $matches) > 0) {
                $fmetric['StemH'] = intval($matches[1]);
            } else {
                $fmetric['StemH'] = 30;
            }
            if (preg_match('#/BlueValues[\s]*\[([^\]]*)#', $eplain, $matches) > 0) {
                $bv = explode(' ', $matches[1]);
                if (count($bv) >= 6) {
                    $v1 = intval($bv[2]);
                    $v2 = intval($bv[4]);
                    if ($v1 <= $v2) {
                        $fmetric['XHeight'] = $v1;
                        $fmetric['CapHeight'] = $v2;
                    } else {
                        $fmetric['XHeight'] = $v2;
                        $fmetric['CapHeight'] = $v1;
                    }
                } else {
                    $fmetric['XHeight'] = 450;
                    $fmetric['CapHeight'] = 700;
                }
            } else {
                $fmetric['XHeight'] = 450;
                $fmetric['CapHeight'] = 700;
            }
            // Get the number of random bytes at the beginning of charstrings.
            if (preg_match('#/leniv[\s]*([0-9]*)#', $eplain, $matches) > 0) {
                $leniv = intval($matches[1]);
            } else {
                $leniv = 4;
            }
            $fmetric['Leading'] = 0;
            // Get charstring data.
            $eplain = substr($eplain, (strpos($eplain, '/CharStrings') + 1));
            preg_match_all('#/([A-Za-z0-9\.]*)[\s][0-9]+[\s]RD[\s](.*)[\s]ND#sU', $eplain, $matches, PREG_SET_ORDER);
            if (!empty($enc) AND isset($this->encmaps->encmap[$enc])) {
                $encmap = $this->encmaps->encmap[$enc];
            } else {
                $encmap = false;
            }
            $fmetric['cw'] = '';
            $fmetric['MaxWidth'] = 0;
            $cwidths = array();
            foreach ($matches as $k => $v) {
                $cid = 0;
                if (isset($imap[$v[1]])) {
                    $cid = $imap[$v[1]];
                } else if ($encmap !== false) {
                    $cid = array_search($v[1], $encmap);
                    if ($cid === false) {
                        $cid = 0;
                    } else if ($cid > 1000) {
                        $cid -= 1000;
                    }
                }
                // Decrypt charstring encrypted part.
                $r = 4330; // Charstring encryption constant.
                $c1 = 52845;
                $c2 = 22719;
                $cd = $v[2];
                $clen = strlen($cd);
                $ccom = array();
                for ($i = 0; $i < $clen; ++$i) {
                    $chr = ord($cd[$i]);
                    $ccom[] = ($chr ^ ($r >> 8));
                    $r = ((($chr + $r) * $c1 + $c2) % 65536);
                }
                // Decode numbers.
                $cdec = array();
                $ck = 0;
                $i = $leniv;
                while ($i < $clen) {
                    if ($ccom[$i] < 32) {
                        $cdec[$ck] = $ccom[$i];
                        if (($ck > 0) AND ($cdec[$ck] == 13)) {
                            // Hsbw command: update width.
                            $cwidths[$cid] = $cdec[($ck - 1)];
                        }
                        ++$i;
                    } else if (($ccom[$i] >= 32) AND ($ccom[$i] <= 246)) {
                        $cdec[$ck] = ($ccom[$i] - 139);
                        ++$i;
                    } else if (($ccom[$i] >= 247) AND ($ccom[$i] <= 250)) {
                        $cdec[$ck] = ((($ccom[$i] - 247) * 256) + $ccom[($i + 1)] + 108);
                        $i += 2;
                    } else if (($ccom[$i] >= 251) AND ($ccom[$i] <= 254)) {
                        $cdec[$ck] = ((-($ccom[$i] - 251) * 256) - $ccom[($i + 1)] - 108);
                        $i += 2;
                    } else if ($ccom[$i] == 255) {
                        $sval = chr($ccom[($i + 1)]).chr($ccom[($i + 2)]).chr($ccom[($i + 3)]).chr($ccom[($i + 4)]);
                        $vsval = unpack('li', $sval);
                        $cdec[$ck] = $vsval['i'];
                        $i += 5;
                    }
                    ++$ck;
                }
            } // End for each matches.
            $fmetric['MissingWidth'] = $cwidths[0];
            $fmetric['MaxWidth'] = $fmetric['MissingWidth'];
            $fmetric['AvgWidth'] = 0;
            // Set chars widths.
            for ($cid = 0; $cid <= 255; ++$cid) {
                if (isset($cwidths[$cid])) {
                    if ($cwidths[$cid] > $fmetric['MaxWidth']) {
                        $fmetric['MaxWidth'] = $cwidths[$cid];
                    }
                    $fmetric['AvgWidth'] += $cwidths[$cid];
                    $fmetric['cw'] .= ','.$cid.'=>'.$cwidths[$cid];
                } else {
                    $fmetric['cw'] .= ','.$cid.'=>'.$fmetric['MissingWidth'];
                }
            }
            $fmetric['AvgWidth'] = round($fmetric['AvgWidth'] / count($cwidths));
        } else {
            // TRUE TYPE.
            if ($fmetric['type'] != 'cidfont0') {
                // Store compressed font.
                $fp = fopen($outpath.$fmetric['file'], 'wb');
                fwrite($fp, gzcompress($font));
                fclose($fp);
            }
            $offset = 0; // Offset position of the font data.
            if ($this->_getulong($font, $offset) != 0x10000) {
                // Sfnt version must be 0x00010000 for TrueType version 1.0.
                return $font;
            }
            $offset += 4;
            // Get number of tables.
            $numtables = $this->_getushort($font, $offset);
            $offset += 2;
            // Skip searchrange, entryselector and rangeshift.
            $offset += 6;
            // Tables array.
            $table = array();
            // Get tables.
            for ($i = 0; $i < $numtables; ++$i) {
                // Get table info.
                $tag = substr($font, $offset, 4);
                $offset += 4;
                $table[$tag] = array();
                $table[$tag]['checkSum'] = $this->_getulong($font, $offset);
                $offset += 4;
                $table[$tag]['offset'] = $this->_getulong($font, $offset);
                $offset += 4;
                $table[$tag]['length'] = $this->_getulong($font, $offset);
                $offset += 4;
            }
            // Check magicNumber.
            $offset = $table['head']['offset'] + 12;
            if ($this->_getulong($font, $offset) != 0x5F0F3CF5) {
                // MagicNumber must be 0x5F0F3CF5.
                return $font;
            }
            $offset += 4;
            $offset += 2; // Skip flags.
            // Get FUnits.
            $fmetric['unitsPerEm'] = $this->_getushort($font, $offset);
            $offset += 2;
            // Units ratio constant.
            $urk = (1000 / $fmetric['unitsPerEm']);
            $offset += 16; // Skip created, modified.
            $xmin = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            $ymin = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            $xmax = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            $ymax = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            $fmetric['bbox'] = ''.$xmin.' '.$ymin.' '.$xmax.' '.$ymax.'';
            $macstyle = $this->_getushort($font, $offset);
            $offset += 2;
            // PDF font flags.
            $fmetric['Flags'] = $flags;
            if (($macstyle & 2) == 2) {
                // Italic flag.
                $fmetric['Flags'] |= 64;
            }
            // Get offset mode (indextolocFormat : 0 = short, 1 = long).
            $offset = $table['head']['offset'] + 50;
            $shortoffset = ($this->_getshort($font, $offset) == 0);
            $offset += 2;
            // Get the offsets to the locations of the glyphs in the font, relative to the beginning of
            // the glyphData table.
            $indextoloc = array();
            $offset = $table['loca']['offset'];
            if ($shortoffset) {
                // Short version.
                $totnumglyphs = ($table['loca']['length'] / 2);
                for ($i = 0; $i < $totnumglyphs; ++$i) {
                    $indextoloc[$i] = $this->_getushort($font, $offset) * 2;
                    $offset += 2;
                }
            } else {
                // Long version.
                $totnumglyphs = ($table['loca']['length'] / 4);
                for ($i = 0; $i < $totnumglyphs; ++$i) {
                    $indextoloc[$i] = $this->_getulong($font, $offset);
                    $offset += 4;
                }
            }
            // Get glyphs indexes of chars from cmap table.
            $offset = $table['cmap']['offset'] + 2;
            $numencodingtables = $this->_getushort($font, $offset);
            $offset += 2;
            $encodingtables = array();
            for ($i = 0; $i < $numencodingtables; ++$i) {
                $encodingtables[$i]['platformID'] = $this->_getushort($font, $offset);
                $offset += 2;
                $encodingtables[$i]['encodingID'] = $this->_getushort($font, $offset);
                $offset += 2;
                $encodingtables[$i]['offset'] = $this->_getulong($font, $offset);
                $offset += 4;
            }
            // Get os/2 metrics.
            $offset = $table['OS/2']['offset'];
            $offset += 2; // Skip version.
            // XAvgCharWidth.
            $fmetric['AvgWidth'] = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            // UsWeightClass.
            $usweightclass = round($this->_getufword($font, $offset) * $urk);
            // Estimate StemV and StemH (400 = usweightclass for Normal - Regular font).
            $fmetric['StemV'] = round((70 * $usweightclass) / 400);
            $fmetric['StemH'] = round((30 * $usweightclass) / 400);
            $offset += 2;
            $offset += 2; // UsWidthClass.
            $fstype = $this->_getshort($font, $offset);
            $offset += 2;
            if ($fstype == 2) {
                $this->errord('This Font cannot be modified, embedded or exchanged in any manner without first
                               obtaining permission of the legal owner.');
            }
            // Get font name.
            $fmetric['name'] = '';
            $offset = $table['name']['offset'];
            $offset += 2; // Skip Format selector (=0).
            // Number of NameRecords that follow n.
            $numnamerecords = $this->_getushort($font, $offset);
            $offset += 2;
            // Offset to start of string storage (from start of table).
            $stringstorageoffset = $this->_getushort($font, $offset);
            $offset += 2;
            for ($i = 0; $i < $numnamerecords; ++$i) {
                $offset += 6; // Skip Platform ID, Platform-specific encoding ID, Language ID.
                // Name ID.
                $nameid = $this->_getushort($font, $offset);
                $offset += 2;
                if ($nameid == 6) {
                    // String length (in bytes).
                    $stringlength = $this->_getushort($font, $offset);
                    $offset += 2;
                    // String offset from start of storage area (in bytes).
                    $stringoffset = $this->_getushort($font, $offset);
                    $offset += 2;
                    $offset = ($table['name']['offset'] + $stringstorageoffset + $stringoffset);
                    $fmetric['name'] = substr($font, $offset, $stringlength);
                    $fmetric['name'] = preg_replace('/[^a-zA-Z0-9_\-]/', '', $fmetric['name']);
                    break;
                } else {
                    $offset += 4; // Skip String length, String offset.
                }
            }
            if (empty($fmetric['name'])) {
                $fmetric['name'] = $fontname;
            }
            // Get post data.
            $offset = $table['post']['offset'];
            $offset += 4; // Skip Format Type.
            $fmetric['italicAngle'] = $this->_getfixed($font, $offset);
            $offset += 4;
            $fmetric['underlinePosition'] = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            $fmetric['underlineThickness'] = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            $isfixedpitch = ($this->_getulong($font, $offset) == 0) ? false : true;
            $offset += 2;
            if ($isfixedpitch) {
                $fmetric['Flags'] |= 1;
            }
            // Get hhea data.
            $offset = $table['hhea']['offset'];
            $offset += 4; // Skip Table version number.
            // Ascender.
            $fmetric['Ascent'] = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            // Descender.
            $fmetric['Descent'] = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            // LineGap.
            $fmetric['Leading'] = round($this->_getfword($font, $offset) * $urk);
            $offset += 2;
            // AdvanceWidthMax.
            $fmetric['MaxWidth'] = round($this->_getufword($font, $offset) * $urk);
            $offset += 2;
            $offset += 22; // Skip some values.
            // Get the number of hMetric entries in hmtx table.
            $numberofhmetrics = $this->_getushort($font, $offset);
            // Get maxp data.
            $offset = $table['maxp']['offset'];
            $offset += 4; // Skip Table version number.
            // Get the the number of glyphs in the font.
            $numglyphs = $this->_getushort($font, $offset);
            // Get CIDToGIDMap.
            $ctg = array();
            foreach ($encodingtables as $enctable) {
                // Get only specified Platform ID and Encoding ID.
                if (($enctable['platformID'] == $platid) AND ($enctable['encodingID'] == $encid)) {
                    $offset = $table['cmap']['offset'] + $enctable['offset'];
                    $format = $this->_getushort($font, $offset);
                    $offset += 2;
                    switch ($format) {
                        case 0: { // Format 0: Byte encoding table.
                            $offset += 4; // Skip length and version/language.
                            for ($c = 0; $c < 256; ++$c) {
                                $g = $this->_getbyte($font, $offset);
                                $ctg[$c] = $g;
                                ++$offset;
                            }
                            break;
                        }
                        case 2: { // Format 2: High-byte mapping through table.
                            $offset += 4; // Skip length and version/language.
                            $numsubheaders = 0;
                            for ($i = 0; $i < 256; ++$i) {
                                // Array that maps high bytes to subheaders: value is subHeader index * 8.
                                $subheaderkeys[$i] = ($this->_getushort($font, $offset) / 8);
                                $offset += 2;
                                if ($numsubheaders < $subheaderkeys[$i]) {
                                    $numsubheaders = $subheaderkeys[$i];
                                }
                            }
                            // The number of subheaders is equal to the max of subheaderkeys + 1.
                            ++$numsubheaders;
                            // Read subHeader structures.
                            $subheaders = array();
                            $numglyphindexarray = 0;
                            for ($k = 0; $k < $numsubheaders; ++$k) {
                                $subheaders[$k]['firstcode'] = $this->_getushort($font, $offset);
                                $offset += 2;
                                $subheaders[$k]['entrycount'] = $this->_getushort($font, $offset);
                                $offset += 2;
                                $subheaders[$k]['iddelta'] = $this->_getushort($font, $offset);
                                $offset += 2;
                                $subheaders[$k]['idrangeoffset'] = $this->_getushort($font, $offset);
                                $offset += 2;
                                $subheaders[$k]['idrangeoffset'] -= (2 + (($numsubheaders - $k - 1) * 8));
                                $subheaders[$k]['idrangeoffset'] /= 2;
                                $numglyphindexarray += $subheaders[$k]['entrycount'];
                            }
                            for ($k = 0; $k < $numglyphindexarray; ++$k) {
                                $glyphindexarray[$k] = $this->_getushort($font, $offset);
                                $offset += 2;
                            }
                            for ($i = 0; $i < 256; ++$i) {
                                $k = $subheaderkeys[$i];
                                if ($k == 0) {
                                    // One byte code.
                                    $c = $i;
                                    $g = $glyphindexarray[0];
                                    $ctg[$c] = $g;
                                } else {
                                    // Two bytes code.
                                    $startbyte = $subheaders[$k]['firstcode'];
                                    $endbyte = $startbyte + $subheaders[$k]['entrycount'];
                                    for ($j = $startbyte; $j < $endbyte; ++$j) {
                                        // Combine high and low bytes.
                                        $c = (($i << 8) + $j);
                                        $idrangeoffset = ($subheaders[$k]['idrangeoffset'] + $j -
                                                          $subheaders[$k]['firstcode']);
                                        $g = ($glyphindexarray[$idrangeoffset] + $iddelta[$k]) % 65536;
                                        if ($g < 0) {
                                            $g = 0;
                                        }
                                        $ctg[$c] = $g;
                                    }
                                }
                            }
                            break;
                        }
                        case 4: { // Format 4: Segment mapping to delta values.
                            $length = $this->_getushort($font, $offset);
                            $offset += 2;
                            $offset += 2; // Skip version/language.
                            $segcount = ($this->_getushort($font, $offset) / 2);
                            $offset += 2;
                            $offset += 6; // Skip searchrange, entryselector, rangeshift.
                            $endcount = array(); // Array of end character codes for each segment.
                            for ($k = 0; $k < $segcount; ++$k) {
                                $endcount[$k] = $this->_getushort($font, $offset);
                                $offset += 2;
                            }
                            $offset += 2; // Skip reservedPad.
                            $startcount = array(); // Array of start character codes for each segment.
                            for ($k = 0; $k < $segcount; ++$k) {
                                $startcount[$k] = $this->_getushort($font, $offset);
                                $offset += 2;
                            }
                            $iddelta = array(); // Delta for all character codes in segment.
                            for ($k = 0; $k < $segcount; ++$k) {
                                $iddelta[$k] = $this->_getushort($font, $offset);
                                $offset += 2;
                            }
                            $idrangeoffset = array(); // Offsets into glyphidarray or 0.
                            for ($k = 0; $k < $segcount; ++$k) {
                                $idrangeoffset[$k] = $this->_getushort($font, $offset);
                                $offset += 2;
                            }
                            $gidlen = ($length / 2) - 8 - (4 * $segcount);
                            $glyphidarray = array(); // Glyph index array.
                            for ($k = 0; $k < $gidlen; ++$k) {
                                $glyphidarray[$k] = $this->_getushort($font, $offset);
                                $offset += 2;
                            }
                            for ($k = 0; $k < $segcount; ++$k) {
                                for ($c = $startcount[$k]; $c <= $endcount[$k]; ++$c) {
                                    if ($idrangeoffset[$k] == 0) {
                                        $g = ($iddelta[$k] + $c) % 65536;
                                    } else {
                                        $gid = (($idrangeoffset[$k] / 2) + ($c - $startcount[$k]) - ($segcount - $k));
                                        $g = ($glyphidarray[$gid] + $iddelta[$k]) % 65536;
                                    }
                                    if ($g < 0) {
                                        $g = 0;
                                    }
                                    $ctg[$c] = $g;
                                }
                            }
                            break;
                        }
                        case 6: { // Format 6: Trimmed table mapping.
                            $offset += 4; // Skip length and version/language.
                            $firstcode = $this->_getushort($font, $offset);
                            $offset += 2;
                            $entrycount = $this->_getushort($font, $offset);
                            $offset += 2;
                            for ($k = 0; $k < $entrycount; ++$k) {
                                $c = ($k + $firstcode);
                                $g = $this->_getushort($font, $offset);
                                $offset += 2;
                                $ctg[$c] = $g;
                            }
                            break;
                        }
                        case 8: { // Format 8: Mixed 16-bit and 32-bit coverage.
                            $offset += 10; // Skip reserved, length and version/language.
                            for ($k = 0; $k < 8192; ++$k) {
                                $is32[$k] = $this->_getbyte($font, $offset);
                                ++$offset;
                            }
                            $ngroups = $this->_getulong($font, $offset);
                            $offset += 4;
                            for ($i = 0; $i < $ngroups; ++$i) {
                                $startcharcode = $this->_getulong($font, $offset);
                                $offset += 4;
                                $endcharcode = $this->_getulong($font, $offset);
                                $offset += 4;
                                $startglyphid = $this->_getulong($font, $offset);
                                $offset += 4;
                                for ($k = $startcharcode; $k <= $endcharcode; ++$k) {
                                    $is32idx = floor($c / 8);
                                    if ((isset($is32[$is32idx])) AND (($is32[$is32idx] & (1 << (7 - ($c % 8)))) == 0)) {
                                        $c = $k;
                                    } else {
                                        $c = ((55232 + ($k >> 10)) << 10) + (0xDC00 + ($k & 0x3FF)) - 56613888;
                                    }
                                    $ctg[$c] = 0;
                                    ++$startglyphid;
                                }
                            }
                            break;
                        }
                        case 10: { // Format 10: Trimmed array.
                            $offset += 10; // Skip reserved, length and version/language.
                            $startcharcode = $this->_getulong($font, $offset);
                            $offset += 4;
                            $numchars = $this->_getulong($font, $offset);
                            $offset += 4;
                            for ($k = 0; $k < $numchars; ++$k) {
                                $c = ($k + $startcharcode);
                                $g = $this->_getushort($font, $offset);
                                $ctg[$c] = $g;
                                $offset += 2;
                            }
                            break;
                        }
                        case 12: { // Format 12: Segmented coverage
                            $offset += 10; // Skip length and version/language.
                            $ngroups = $this->_getulong($font, $offset);
                            $offset += 4;
                            for ($k = 0; $k < $ngroups; ++$k) {
                                $startcharcode = $this->_getulong($font, $offset);
                                $offset += 4;
                                $endcharcode = $this->_getulong($font, $offset);
                                $offset += 4;
                                $startglyphcode = $this->_getulong($font, $offset);
                                $offset += 4;
                                for ($c = $startcharcode; $c <= $endcharcode; ++$c) {
                                    $ctg[$c] = $startglyphcode;
                                    ++$startglyphcode;
                                }
                            }
                            break;
                        }
                        case 13: { // Format 13: Many-to-one range mappings.
                            // To be implemented.
                            break;
                        }
                        case 14: { // Format 14: Unicode Variation Sequences.
                            // To be implemented.
                            break;
                        }
                    }
                }
            }
            if (!isset($ctg[0])) {
                $ctg[0] = 0;
            }
            // Get xHeight (height of x).
            $offset = ($table['glyf']['offset'] + $indextoloc[$ctg[120]] + 4);
            $ymin = $this->_getfword($font, $offset);
            $offset += 4;
            $ymax = $this->_getfword($font, $offset);
            $offset += 2;
            $fmetric['XHeight'] = round(($ymax - $ymin) * $urk);
            // Get CapHeight (height of H).
            $offset = ($table['glyf']['offset'] + $indextoloc[$ctg[72]] + 4);
            $ymin = $this->_getfword($font, $offset);
            $offset += 4;
            $ymax = $this->_getfword($font, $offset);
            $offset += 2;
            $fmetric['CapHeight'] = round(($ymax - $ymin) * $urk);
            // Create widths array.
            $cw = array();
            $offset = $table['hmtx']['offset'];
            for ($i = 0; $i < $numberofhmetrics; ++$i) {
                $cw[$i] = round($this->_getufword($font, $offset) * $urk);
                $offset += 4; // Skip lsb.
            }
            if ($numberofhmetrics < $numglyphs) {
                // Fill missing widths with the last value.
                $cw = array_pad($cw, $numglyphs, $cw[($numberofhmetrics - 1)]);
            }
            $fmetric['MissingWidth'] = $cw[0];
            $fmetric['cw'] = '';
            for ($cid = 0; $cid <= 65535; ++$cid) {
                if (isset($ctg[$cid]) AND isset($cw[$ctg[$cid]])) {
                    $fmetric['cw'] .= ','.$cid.'=>'.$cw[$ctg[$cid]];
                }
            }
        } // End of true type.
        if (($fmetric['type'] == 'TrueTypeUnicode') AND (count($ctg) == 256)) {
            $fmetric['type'] == 'TrueType';
        }
        // Create php font file.
        $pfile = '<'.'?'.'php'."\n";
        $pfile .= '// TCPDF FONT FILE DESCRIPTION'."\n";
        $pfile .= '$type=\''.$fmetric['type'].'\';'."\n";
        $pfile .= '$name=\''.$fmetric['name'].'\';'."\n";
        $pfile .= '$up='.$fmetric['underlinePosition'].';'."\n";
        $pfile .= '$ut='.$fmetric['underlineThickness'].';'."\n";
        if ($fmetric['MissingWidth'] > 0) {
            $pfile .= '$dw='.$fmetric['MissingWidth'].';'."\n";
        } else {
            $pfile .= '$dw='.$fmetric['AvgWidth'].';'."\n";
        }
        $pfile .= '$diff=\''.$fmetric['diff'].'\';'."\n";
        if ($fmetric['type'] == 'Type1') {
            // Type 1.
            $pfile .= '$enc=\''.$fmetric['enc'].'\';'."\n";
            $pfile .= '$file=\''.$fmetric['file'].'\';'."\n";
            $pfile .= '$size1='.$fmetric['size1'].';'."\n";
            $pfile .= '$size2='.$fmetric['size2'].';'."\n";
        } else {
            $pfile .= '$originalsize='.$fmetric['originalsize'].';'."\n";
            if ($fmetric['type'] == 'cidfont0') {
                // CID-0.
                switch ($fonttype) {
                    case 'CID0JP': {
                        $pfile .= '// Japanese'."\n";
                        $pfile .= '$enc=\'UniJIS-UTF16-H\';'."\n";
                        $pfile .= '$cidinfo=array(\'Registry\'=>\'Adobe\', \'Ordering\'=>\'Japan1\',\'Supplement\'=>5);'."\n";
                        $pfile .= 'include(dirname(__FILE__).\'/uni2cid_aj16.php\');'."\n";
                        break;
                    }
                    case 'CID0KR': {
                        $pfile .= '// Korean'."\n";
                        $pfile .= '$enc=\'UniKS-UTF16-H\';'."\n";
                        $pfile .= '$cidinfo=array(\'Registry\'=>\'Adobe\', \'Ordering\'=>\'Korea1\',\'Supplement\'=>0);'."\n";
                        $pfile .= 'include(dirname(__FILE__).\'/uni2cid_ak12.php\');'."\n";
                        break;
                    }
                    case 'CID0CS': {
                        $pfile .= '// Chinese Simplified'."\n";
                        $pfile .= '$enc=\'UniGB-UTF16-H\';'."\n";
                        $pfile .= '$cidinfo=array(\'Registry\'=>\'Adobe\', \'Ordering\'=>\'GB1\',\'Supplement\'=>2);'."\n";
                        $pfile .= 'include(dirname(__FILE__).\'/uni2cid_ag15.php\');'."\n";
                        break;
                    }
                    case 'CID0CT':
                    default: {
                        $pfile .= '// Chinese Traditional'."\n";
                        $pfile .= '$enc=\'UniCNS-UTF16-H\';'."\n";
                        $pfile .= '$cidinfo=array(\'Registry\'=>\'Adobe\', \'Ordering\'=>\'CNS1\',\'Supplement\'=>0);'."\n";
                        $pfile .= 'include(dirname(__FILE__).\'/uni2cid_aj16.php\');'."\n";
                        break;
                    }
                }
            } else {
                // TrueType.
                $pfile .= '$enc=\''.$fmetric['enc'].'\';'."\n";
                $pfile .= '$file=\''.$fmetric['file'].'\';'."\n";
                $pfile .= '$ctg=\''.$fmetric['ctg'].'\';'."\n";
                // Create CIDToGIDMap.
                $cidtogidmap = str_pad('', 131072, "\x00");
                foreach ($ctg as $cid => $gid) {
                    $cidtogidmap = $this->updatecidtogidmap($cidtogidmap, $cid, $ctg[$cid]);
                }
                // Store compressed CIDToGIDMap.
                $fp = fopen($outpath.$fmetric['ctg'], 'wb');
                fwrite($fp, gzcompress($cidtogidmap));
                fclose($fp);
            }
        }
        $pfile .= '$desc=array(';
        $pfile .= '\'Flags\'=>'.$fmetric['Flags'].',';
        $pfile .= '\'FontBBox\'=>\'['.$fmetric['bbox'].']\',';
        $pfile .= '\'ItalicAngle\'=>'.$fmetric['italicAngle'].',';
        $pfile .= '\'Ascent\'=>'.$fmetric['Ascent'].',';
        $pfile .= '\'Descent\'=>'.$fmetric['Descent'].',';
        $pfile .= '\'Leading\'=>'.$fmetric['Leading'].',';
        $pfile .= '\'CapHeight\'=>'.$fmetric['CapHeight'].',';
        $pfile .= '\'XHeight\'=>'.$fmetric['XHeight'].',';
        $pfile .= '\'StemV\'=>'.$fmetric['StemV'].',';
        $pfile .= '\'StemH\'=>'.$fmetric['StemH'].',';
        $pfile .= '\'AvgWidth\'=>'.$fmetric['AvgWidth'].',';
        $pfile .= '\'MaxWidth\'=>'.$fmetric['MaxWidth'].',';
        $pfile .= '\'MissingWidth\'=>'.$fmetric['MissingWidth'].'';
        $pfile .= ');'."\n";
        $pfile .= '$cw=array('.substr($fmetric['cw'], 1).');'."\n";
        $pfile .= '// EOF ---'."\n";
        // Store file.
        $fp = fopen($outpath.$fontname.'.php', 'w');
        fwrite($fp, $pfile);
        fclose($fp);
        // Return TCPDF font name.
        return $fontname;
    }

    /**
     * Returns a subset of the TrueType font data without the unused glyphs.
     */
    protected function _gettruetypefontsubset($font, $subsetchars) {
        ksort($subsetchars);
        $offset = 0; // Offset position of the font data.
        if ($this->_getulong($font, $offset) != 0x10000) {
            // Sfnt version must be 0x00010000 for TrueType version 1.0.
            return $font;
        }
        $offset += 4;
        // Get number of tables.
        $numtables = $this->_getushort($font, $offset);
        $offset += 2;
        // Skip searchrange, entryselector and rangeshift.
        $offset += 6;
        // Tables array.
        $table = array();
        // For each table.
        for ($i = 0; $i < $numtables; ++$i) {
            // Get table info.
            $tag = substr($font, $offset, 4);
            $offset += 4;
            $table[$tag] = array();
            $table[$tag]['checkSum'] = $this->_getulong($font, $offset);
            $offset += 4;
            $table[$tag]['offset'] = $this->_getulong($font, $offset);
            $offset += 4;
            $table[$tag]['length'] = $this->_getulong($font, $offset);
            $offset += 4;
        }
        // Check magicNumber.
        $offset = $table['head']['offset'] + 12;
        if ($this->_getulong($font, $offset) != 0x5F0F3CF5) {
            // MagicNumber must be 0x5F0F3CF5.
            return $font;
        }
        $offset += 4;
        // Get offset mode (indextolocFormat : 0 = short, 1 = long).
        $offset = $table['head']['offset'] + 50;
        $shortoffset = ($this->_getshort($font, $offset) == 0);
        $offset += 2;
        // Get the offsets to the locations of the glyphs in the font, relative to the beginning of the glyphData table.
        $indextoloc = array();
        $offset = $table['loca']['offset'];
        if ($shortoffset) {
            // Short version.
            $totnumglyphs = ($table['loca']['length'] / 2);
            for ($i = 0; $i < $totnumglyphs; ++$i) {
                $indextoloc[$i] = $this->_getushort($font, $offset) * 2;
                $offset += 2;
            }
        } else {
            // Long version.
            $totnumglyphs = ($table['loca']['length'] / 4);
            for ($i = 0; $i < $totnumglyphs; ++$i) {
                $indextoloc[$i] = $this->_getulong($font, $offset);
                $offset += 4;
            }
        }
        // Get glyphs indexes of chars from cmap table.
        $subsetglyphs = array(); // Glyph IDs on key.
        $subsetglyphs[0] = true;
        // Character codes that do not correspond to any glyph in the font should be mapped to glyph index 0.
        $offset = $table['cmap']['offset'] + 2;
        $numencodingtables = $this->_getushort($font, $offset);
        $offset += 2;
        $encodingtables = array();
        for ($i = 0; $i < $numencodingtables; ++$i) {
            $encodingtables[$i]['platformID'] = $this->_getushort($font, $offset);
            $offset += 2;
            $encodingtables[$i]['encodingID'] = $this->_getushort($font, $offset);
            $offset += 2;
            $encodingtables[$i]['offset'] = $this->_getulong($font, $offset);
            $offset += 4;
        }
        foreach ($encodingtables as $enctable) {
            // Get all platforms and encodings.
            $offset = $table['cmap']['offset'] + $enctable['offset'];
            $format = $this->_getushort($font, $offset);
            $offset += 2;
            switch ($format) {
                case 0: { // Format 0: Byte encoding table.
                    $offset += 4; // Skip length and version/language.
                    for ($c = 0; $c < 256; ++$c) {
                        if (isset($subsetchars[$c])) {
                            $g = $this->_getbyte($font, $offset);
                            $subsetglyphs[$g] = true;
                        }
                        ++$offset;
                    }
                    break;
                }
                case 2: { // Format 2: High-byte mapping through table.
                    $offset += 4; // Skip length and version/language.
                    $numsubheaders = 0;
                    for ($i = 0; $i < 256; ++$i) {
                        // Array that maps high bytes to subheaders: value is subHeader index * 8.
                        $subheaderkeys[$i] = ($this->_getushort($font, $offset) / 8);
                        $offset += 2;
                        if ($numsubheaders < $subheaderkeys[$i]) {
                            $numsubheaders = $subheaderkeys[$i];
                        }
                    }
                    // The number of subheaders is equal to the max of subheaderkeys + 1.
                    ++$numsubheaders;
                    // Read subHeader structures.
                    $subheaders = array();
                    $numglyphindexarray = 0;
                    for ($k = 0; $k < $numsubheaders; ++$k) {
                        $subheaders[$k]['firstcode'] = $this->_getushort($font, $offset);
                        $offset += 2;
                        $subheaders[$k]['entrycount'] = $this->_getushort($font, $offset);
                        $offset += 2;
                        $subheaders[$k]['iddelta'] = $this->_getushort($font, $offset);
                        $offset += 2;
                        $subheaders[$k]['idrangeoffset'] = $this->_getushort($font, $offset);
                        $offset += 2;
                        $subheaders[$k]['idrangeoffset'] -= (2 + (($numsubheaders - $k - 1) * 8));
                        $subheaders[$k]['idrangeoffset'] /= 2;
                        $numglyphindexarray += $subheaders[$k]['entrycount'];
                    }
                    for ($k = 0; $k < $numglyphindexarray; ++$k) {
                        $glyphindexarray[$k] = $this->_getushort($font, $offset);
                        $offset += 2;
                    }
                    for ($i = 0; $i < 256; ++$i) {
                        $k = $subheaderkeys[$i];
                        if ($k == 0) {
                            // One byte code.
                            $c = $i;
                            if (isset($subsetchars[$c])) {
                                $g = $glyphindexarray[0];
                                $subsetglyphs[$g] = true;
                            }
                        } else {
                            // Two bytes code.
                            $startbyte = $subheaders[$k]['firstcode'];
                            $endbyte = $startbyte + $subheaders[$k]['entrycount'];
                            for ($j = $startbyte; $j < $endbyte; ++$j) {
                                // Combine high and low bytes.
                                $c = (($i << 8) + $j);
                                if (isset($subsetchars[$c])) {
                                    $idrangeoffset = ($subheaders[$k]['idrangeoffset'] + $j - $subheaders[$k]['firstcode']);
                                    $g = ($glyphindexarray[$idrangeoffset] + $iddelta[$k]) % 65536;
                                    if ($g < 0) {
                                        $g = 0;
                                    }
                                    $subsetglyphs[$g] = true;
                                }
                            }
                        }
                    }
                    break;
                }
                case 4: { // Format 4: Segment mapping to delta values.
                    $length = $this->_getushort($font, $offset);
                    $offset += 2;
                    $offset += 2; // Skip version/language.
                    $segcount = ($this->_getushort($font, $offset) / 2);
                    $offset += 2;
                    $offset += 6; // Skip searchrange, entryselector, rangeshift.
                    $endcount = array(); // Array of end character codes for each segment.
                    for ($k = 0; $k < $segcount; ++$k) {
                        $endcount[$k] = $this->_getushort($font, $offset);
                        $offset += 2;
                    }
                    $offset += 2; // Skip reservedPad.
                    $startcount = array(); // Array of start character codes for each segment.
                    for ($k = 0; $k < $segcount; ++$k) {
                        $startcount[$k] = $this->_getushort($font, $offset);
                        $offset += 2;
                    }
                    $iddelta = array(); // Delta for all character codes in segment.
                    for ($k = 0; $k < $segcount; ++$k) {
                        $iddelta[$k] = $this->_getushort($font, $offset);
                        $offset += 2;
                    }
                    $idrangeoffset = array(); // Offsets into glyphidarray or 0.
                    for ($k = 0; $k < $segcount; ++$k) {
                        $idrangeoffset[$k] = $this->_getushort($font, $offset);
                        $offset += 2;
                    }
                    $gidlen = ($length / 2) - 8 - (4 * $segcount);
                    $glyphidarray = array(); // Glyph index array.
                    for ($k = 0; $k < $gidlen; ++$k) {
                        $glyphidarray[$k] = $this->_getushort($font, $offset);
                        $offset += 2;
                    }
                    for ($k = 0; $k < $segcount; ++$k) {
                        for ($c = $startcount[$k]; $c <= $endcount[$k]; ++$c) {
                            if (isset($subsetchars[$c])) {
                                if ($idrangeoffset[$k] == 0) {
                                    $g = ($iddelta[$k] + $c) % 65536;
                                } else {
                                    $gid = (($idrangeoffset[$k] / 2) + ($c - $startcount[$k]) - ($segcount - $k));
                                    $g = ($glyphidarray[$gid] + $iddelta[$k]) % 65536;
                                }
                                if ($g < 0) {
                                    $g = 0;
                                }
                                $subsetglyphs[$g] = true;
                            }
                        }
                    }
                    break;
                }
                case 6: { // Format 6: Trimmed table mapping.
                    $offset += 4; // Skip length and version/language.
                    $firstcode = $this->_getushort($font, $offset);
                    $offset += 2;
                    $entrycount = $this->_getushort($font, $offset);
                    $offset += 2;
                    for ($k = 0; $k < $entrycount; ++$k) {
                        $c = ($k + $firstcode);
                        if (isset($subsetchars[$c])) {
                            $g = $this->_getushort($font, $offset);
                            $subsetglyphs[$g] = true;
                        }
                        $offset += 2;
                    }
                    break;
                }
                case 8: { // Format 8: Mixed 16-bit and 32-bit coverage.
                    $offset += 10; // Skip reserved, length and version/language.
                    for ($k = 0; $k < 8192; ++$k) {
                        $is32[$k] = $this->_getbyte($font, $offset);
                        ++$offset;
                    }
                    $ngroups = $this->_getulong($font, $offset);
                    $offset += 4;
                    for ($i = 0; $i < $ngroups; ++$i) {
                        $startcharcode = $this->_getulong($font, $offset);
                        $offset += 4;
                        $endcharcode = $this->_getulong($font, $offset);
                        $offset += 4;
                        $startglyphid = $this->_getulong($font, $offset);
                        $offset += 4;
                        for ($k = $startcharcode; $k <= $endcharcode; ++$k) {
                            $is32idx = floor($c / 8);
                            if ((isset($is32[$is32idx])) AND (($is32[$is32idx] & (1 << (7 - ($c % 8)))) == 0)) {
                                $c = $k;
                            } else {
                                $c = ((55232 + ($k >> 10)) << 10) + (0xDC00 + ($k & 0x3FF)) - 56613888;
                            }
                            if (isset($subsetchars[$c])) {
                                $subsetglyphs[$startglyphid] = true;
                            }
                            ++$startglyphid;
                        }
                    }
                    break;
                }
                case 10: { // Format 10: Trimmed array.
                    $offset += 10; // Skip reserved, length and version/language.
                    $startcharcode = $this->_getulong($font, $offset);
                    $offset += 4;
                    $numchars = $this->_getulong($font, $offset);
                    $offset += 4;
                    for ($k = 0; $k < $numchars; ++$k) {
                        $c = ($k + $startcharcode);
                        if (isset($subsetchars[$c])) {
                            $g = $this->_getushort($font, $offset);
                            $subsetglyphs[$g] = true;
                        }
                        $offset += 2;
                    }
                    break;
                }
                case 12: { // Format 12: Segmented coverage.
                    $offset += 10; // Skip length and version/language.
                    $ngroups = $this->_getulong($font, $offset);
                    $offset += 4;
                    for ($k = 0; $k < $ngroups; ++$k) {
                        $startcharcode = $this->_getulong($font, $offset);
                        $offset += 4;
                        $endcharcode = $this->_getulong($font, $offset);
                        $offset += 4;
                        $startglyphcode = $this->_getulong($font, $offset);
                        $offset += 4;
                        for ($c = $startcharcode; $c <= $endcharcode; ++$c) {
                            if (isset($subsetchars[$c])) {
                                $subsetglyphs[$startglyphcode] = true;
                            }
                            ++$startglyphcode;
                        }
                    }
                    break;
                }
                case 13: { // Format 13: Many-to-one range mappings.
                    // To be implemented ...
                    break;
                }
                case 14: { // Format 14: Unicode Variation Sequences.
                    // To be implemented ...
                    break;
                }
            }
        }
        // Include all parts of composite glyphs.
        $newsga = $subsetglyphs;
        while (!empty($newsga)) {
            $sga = $newsga;
            $newsga = array();
            foreach ($sga as $key => $val) {
                if (isset($indextoloc[$key])) {
                    $offset = ($table['glyf']['offset'] + $indextoloc[$key]);
                    $numberofcontours = $this->_getshort($font, $offset);
                    $offset += 2;
                    if ($numberofcontours < 0) { // Composite glyph.
                        $offset += 8; // Skip xmin, ymin, xmax, ymax.
                        do {
                            $flags = $this->_getushort($font, $offset);
                            $offset += 2;
                            $glyphindex = $this->_getushort($font, $offset);
                            $offset += 2;
                            if (!isset($subsetglyphs[$glyphindex])) {
                                // Add missing glyphs.
                                $newsga[$glyphindex] = true;
                            }
                            // Skip some bytes by case.
                            if ($flags & 1) {
                                $offset += 4;
                            } else {
                                $offset += 2;
                            }
                            if ($flags & 8) {
                                $offset += 2;
                            } else if ($flags & 64) {
                                $offset += 4;
                            } else if ($flags & 128) {
                                $offset += 8;
                            }
                        } while ($flags & 32);
                    }
                }
            }
            $subsetglyphs += $newsga;
        }
        // Sort glyphs by key (and remove duplicates).
        ksort($subsetglyphs);
        // Build new glyf and loca tables.
        $glyf = '';
        $loca = '';
        $offset = 0;
        $glyfoffset = $table['glyf']['offset'];
        for ($i = 0; $i < $totnumglyphs; ++$i) {
            if (isset($subsetglyphs[$i])) {
                $length = ($indextoloc[($i + 1)] - $indextoloc[$i]);
                $glyf .= substr($font, ($glyfoffset + $indextoloc[$i]), $length);
            } else {
                $length = 0;
            }
            if ($shortoffset) {
                $loca .= pack('n', ($offset / 2));
            } else {
                $loca .= pack('N', $offset);
            }
            $offset += $length;
        }
        // Array of table names to preserve (loca and glyf tables will be added later).
        // The cmap table is not needed and shall not be present, since the mapping from character codes to glyph
        // descriptions is provided separately.
        $tablenames = array ('head', 'hhea', 'hmtx', 'maxp', 'cvt ', 'fpgm', 'prep'); // minimum required table names
        // Get the tables to preserve.
        $offset = 12;
        foreach ($table as $tag => $val) {
            if (in_array($tag, $tablenames)) {
                $table[$tag]['data'] = substr($font, $table[$tag]['offset'], $table[$tag]['length']);
                if ($tag == 'head') {
                    // Set the checksumadjustment to 0.
                    $table[$tag]['data'] = substr($table[$tag]['data'], 0, 8)."\x0\x0\x0\x0".substr($table[$tag]['data'], 12);
                }
                $pad = 4 - ($table[$tag]['length'] % 4);
                if ($pad != 4) {
                    // The length of a table must be a multiple of four bytes.
                    $table[$tag]['length'] += $pad;
                    $table[$tag]['data'] .= str_repeat("\x0", $pad);
                }
                $table[$tag]['offset'] = $offset;
                $offset += $table[$tag]['length'];
                // Check sum is not changed (so keep the following line commented).
            } else {
                unset($table[$tag]);
            }
        }
        // Add loca.
        $table['loca']['data'] = $loca;
        $table['loca']['length'] = strlen($loca);
        $pad = 4 - ($table['loca']['length'] % 4);
        if ($pad != 4) {
            // The length of a table must be a multiple of four bytes.
            $table['loca']['length'] += $pad;
            $table['loca']['data'] .= str_repeat("\x0", $pad);
        }
        $table['loca']['offset'] = $offset;
        $table['loca']['checkSum'] = $this->_getttftablechecksum($table['loca']['data'], $table['loca']['length']);
        $offset += $table['loca']['length'];
        // Add glyf.
        $table['glyf']['data'] = $glyf;
        $table['glyf']['length'] = strlen($glyf);
        $pad = 4 - ($table['glyf']['length'] % 4);
        if ($pad != 4) {
            // The length of a table must be a multiple of four bytes.
            $table['glyf']['length'] += $pad;
            $table['glyf']['data'] .= str_repeat("\x0", $pad);
        }
        $table['glyf']['offset'] = $offset;
        $table['glyf']['checkSum'] = $this->_getttftablechecksum($table['glyf']['data'], $table['glyf']['length']);
        // Rebuild font.
        $font = '';
        $font .= pack('N', 0x10000);
        $numtables = count($table);
        $font .= pack('n', $numtables);
        $entryselector = floor(log($numtables, 2));
        $searchrange = pow(2, $entryselector) * 16;
        $rangeshift = ($numtables * 16) - $searchrange;
        $font .= pack('n', $searchrange);
        $font .= pack('n', $entryselector);
        $font .= pack('n', $rangeshift);
        $offset = ($numtables * 16);
        foreach ($table as $tag => $data) {
            $font .= $tag; // Tag.
            $font .= pack('N', $data['checkSum']);
            $font .= pack('N', ($data['offset'] + $offset));
            $font .= pack('N', $data['length']);
        }
        foreach ($table as $data) {
            $font .= $data['data'];
        }
        // Set checksumadjustment on head table.
        $checksumadjustment = 0xB1B0AFBA - $this->_getttftablechecksum($font, strlen($font));
        $font = substr($font, 0, $table['head']['offset'] + 8).pack('N', $checksumadjustment).
                substr($font, $table['head']['offset'] + 12);
        return $font;
    }

    /**
     * Returs the checksum of a TTF table.
     */
    protected function _getttftablechecksum($table, $length) {
        $sum = 0;
        $tlen = ($length / 4);
        $offset = 0;
        for ($i = 0; $i < $tlen; ++$i) {
            $v = unpack('Ni', substr($table, $offset, 4));
            $sum += $v['i'];
            $offset += 4;
        }
        $sum = unpack('Ni', pack('N', $sum));
        return $sum['i'];
    }

    /**
     * outputs font widths
     */
    protected function _putfontwidths($font, $cidoffset=0) {
        ksort($font['cw']);
        $rangeid = 0;
        $range = array();
        $prevcid = -2;
        $prevwidth = -1;
        $interval = false;
        // For each character.
        foreach ($font['cw'] as $cid => $width) {
            $cid -= $cidoffset;
            if ($font['subset'] AND ($cid > 255) AND (!isset($font['subsetchars'][$cid]))) {
                // Ignore the unused characters (font subsetting).
                continue;
            }
            if ($width != $font['dw']) {
                if ($cid == ($prevcid + 1)) {
                    // Consecutive CID.
                    if ($width == $prevwidth) {
                        if ($width == $range[$rangeid][0]) {
                            $range[$rangeid][] = $width;
                        } else {
                            array_pop($range[$rangeid]);
                            // New range.
                            $rangeid = $prevcid;
                            $range[$rangeid] = array();
                            $range[$rangeid][] = $prevwidth;
                            $range[$rangeid][] = $width;
                        }
                        $interval = true;
                        $range[$rangeid]['interval'] = true;
                    } else {
                        if ($interval) {
                            // New range.
                            $rangeid = $cid;
                            $range[$rangeid] = array();
                            $range[$rangeid][] = $width;
                        } else {
                            $range[$rangeid][] = $width;
                        }
                        $interval = false;
                    }
                } else {
                    // New range.
                    $rangeid = $cid;
                    $range[$rangeid] = array();
                    $range[$rangeid][] = $width;
                    $interval = false;
                }
                $prevcid = $cid;
                $prevwidth = $width;
            }
        }
        // Optimize ranges.
        $prevk = -1;
        $nextk = -1;
        $prevint = false;
        foreach ($range as $k => $ws) {
            $cws = count($ws);
            if (($k == $nextk) AND (!$prevint) AND ((!isset($ws['interval'])) OR ($cws < 4))) {
                if (isset($range[$k]['interval'])) {
                    unset($range[$k]['interval']);
                }
                $range[$prevk] = array_merge($range[$prevk], $range[$k]);
                unset($range[$k]);
            } else {
                $prevk = $k;
            }
            $nextk = $k + $cws;
            if (isset($ws['interval'])) {
                if ($cws > 3) {
                    $prevint = true;
                } else {
                    $prevint = false;
                }
                unset($range[$k]['interval']);
                --$nextk;
            } else {
                $prevint = false;
            }
        }
        // Output data.
        $w = '';
        foreach ($range as $k => $ws) {
            if (count(array_count_values($ws)) == 1) {
                // Interval mode is more compact.
                $w .= ' '.$k.' '.($k + count($ws) - 1).' '.$ws[0];
            } else {
                // Range mode.
                $w .= ' '.$k.' [ '.implode(' ', $ws).' ]';
            }
        }
        return '/W ['.$w.' ]';
    }

    /**
     * output fonts.
     */
    protected function _putfonts() {
        $nf = $this->n;
        foreach ($this->diffs as $diff) {
            // Encodings.
            $this->_newobj();
            $this->_out('<< /Type /Encoding /BaseEncoding /WinAnsiEncoding /Differences ['.$diff.'] >>'."\n".'endobj');
        }
        $mqr = $this->get_mqr();
        $this->set_mqr(false);
        foreach ($this->fontfiles as $file => $info) {
            // Search and get font file to embedd.
            $fontdir = $info['fontdir'];
            $file = strtolower($file);
            $fontfile = '';
            // Search files on various directories.
            if (($fontdir !== false) AND file_exists($fontdir.$file)) {
                $fontfile = $fontdir.$file;
            } else if (file_exists($this->_getfontpath().$file)) {
                $fontfile = $this->_getfontpath().$file;
            } else if (file_exists($file)) {
                $fontfile = $file;
            }
            if (!$this->empty_string($fontfile)) {
                $font = file_get_contents($fontfile);
                $compressed = (substr($file, -2) == '.z');
                if ((!$compressed) AND (isset($info['length2']))) {
                    $header = (ord($font{0}) == 128);
                    if ($header) {
                        // Strip first binary header.
                        $font = substr($font, 6);
                    }
                    if ($header AND (ord($font[$info['length1']]) == 128)) {
                        // Strip second binary header.
                        $font = substr($font, 0, $info['length1']).substr($font, ($info['length1'] + 6));
                    }
                } else if ($info['subset'] AND ((!$compressed) OR ($compressed AND function_exists('gzcompress')))) {
                    if ($compressed) {
                        // Uncompress font.
                        $font = gzuncompress($font);
                    }
                    // Merge subset characters.
                    $subsetchars = array(); // Used chars.
                    foreach ($info['fontkeys'] as $fontkey) {
                        $fontinfo = $this->getfontbuffer($fontkey);
                        $subsetchars += $fontinfo['subsetchars'];
                    }
                    // Rebuild a font subset.
                    $font = $this->_gettruetypefontsubset($font, $subsetchars);
                    // Calculate new font length.
                    $info['length1'] = strlen($font);
                    if ($compressed) {
                        // Recompress font.
                        $font = gzcompress($font);
                    }
                }
                $this->_newobj();
                $this->fontfiles[$file]['n'] = $this->n;
                $stream = $this->_getrawstream($font);
                $out = '<< /Length '.strlen($stream);
                if ($compressed) {
                    $out .= ' /Filter /FlateDecode';
                }
                $out .= ' /Length1 '.$info['length1'];
                if (isset($info['length2'])) {
                    $out .= ' /Length2 '.$info['length2'].' /Length3 0';
                }
                $out .= ' >>';
                $out .= ' stream'."\n".$stream."\n".'endstream';
                $out .= "\n".'endobj';
                $this->_out($out);
            }
        }
        $this->set_mqr($mqr);
        foreach ($this->fontkeys as $k) {
            // Font objects.
            $font = $this->getfontbuffer($k);
            $type = $font['type'];
            $name = $font['name'];
            if ($type == 'core') {
                // Standard core font.
                $out = $this->_getobj($this->fontobjids[$k])."\n";
                $out .= '<</Type /Font';
                $out .= ' /Subtype /Type1';
                $out .= ' /BaseFont /'.$name;
                $out .= ' /Name /F'.$font['i'];
                if ((strtolower($name) != 'symbol') AND (strtolower($name) != 'zapfdingbats')) {
                    $out .= ' /Encoding /WinAnsiEncoding';
                }
                if ($k == 'helvetica') {
                    // Add default font for annotations.
                    $this->annotationfonts[$k] = $font['i'];
                }
                $out .= ' >>';
                $out .= "\n".'endobj';
                $this->_out($out);
            } else if (($type == 'Type1') OR ($type == 'TrueType')) {
                // Additional Type1 or TrueType font.
                $out = $this->_getobj($this->fontobjids[$k])."\n";
                $out .= '<</Type /Font';
                $out .= ' /Subtype /'.$type;
                $out .= ' /BaseFont /'.$name;
                $out .= ' /Name /F'.$font['i'];
                $out .= ' /FirstChar 32 /LastChar 255';
                $out .= ' /Widths '.($this->n + 1).' 0 R';
                $out .= ' /FontDescriptor '.($this->n + 2).' 0 R';
                if ($font['enc']) {
                    if (isset($font['diff'])) {
                        $out .= ' /Encoding '.($nf + $font['diff']).' 0 R';
                    } else {
                        $out .= ' /Encoding /WinAnsiEncoding';
                    }
                }
                $out .= ' >>';
                $out .= "\n".'endobj';
                $this->_out($out);
                // Widths.
                $this->_newobj();
                $s = '[';
                for ($i = 32; $i < 256; ++$i) {
                    $s .= $font['cw'][$i].' ';
                }
                $s .= ']';
                $s .= "\n".'endobj';
                $this->_out($s);
                // Descriptor.
                $this->_newobj();
                $s = '<</Type /FontDescriptor /FontName /'.$name;
                foreach ($font['desc'] as $fdk => $fdv) {
                    if (is_float($fdv)) {
                        $fdv = sprintf('%F', $fdv);
                    }
                    $s .= ' /'.$fdk.' '.$fdv.'';
                }
                if (!$this->empty_string($font['file'])) {
                    $s .= ' /FontFile'.($type == 'Type1' ? '' : '2').' '.$this->fontfiles[$font['file']]['n'].' 0 R';
                }
                $s .= '>>';
                $s .= "\n".'endobj';
                $this->_out($s);
            } else {
                // Additional types.
                $mtd = '_put'.strtolower($type);
                if (!method_exists($this, $mtd)) {
                    $this->errord('Unsupported font type: '.$type);
                }
                $this->$mtd($font);
            }
        }
    }

    /**
     * Adds unicode fonts.<br>
     * Based on PDF Reference 1.3 (section 5)
     */
    protected function _puttruetypeunicode($font) {
        $fontname = '';
        if ($font['subset']) {
            // Change name for font subsetting.
            $subtag = sprintf('%06u', $font['i']);
            $subtag = strtr($subtag, '0123456789', 'ABCDEFGHIJ');
            $fontname .= $subtag.'+';
        }
        $fontname .= $font['name'];
        // Type0 Font.
        // A composite font composed of other fonts, organized hierarchically.
        $out = $this->_getobj($this->fontobjids[$font['fontkey']])."\n";
        $out .= '<< /Type /Font';
        $out .= ' /Subtype /Type0';
        $out .= ' /BaseFont /'.$fontname;
        $out .= ' /Name /F'.$font['i'];
        $out .= ' /Encoding /'.$font['enc'];
        $out .= ' /ToUnicode '.($this->n + 1).' 0 R';
        $out .= ' /DescendantFonts ['.($this->n + 2).' 0 R]';
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        // ToUnicode map for Identity-H.
        $stream = "/CIDInit /ProcSet findresource begin\n";
        $stream .= "12 dict begin\n";
        $stream .= "begincmap\n";
        $stream .= "/CIDSystemInfo << /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def\n";
        $stream .= "/CMapName /Adobe-Identity-UCS def\n";
        $stream .= "/CMapType 2 def\n";
        $stream .= "/WMode 0 def\n";
        $stream .= "1 begincodespacerange\n";
        $stream .= "<0000> <FFFF>\n";
        $stream .= "endcodespacerange\n";
        $stream .= "100 beginbfrange\n";
        $stream .= "<0000> <00ff> <0000>\n";
        $stream .= "<0100> <01ff> <0100>\n";
        $stream .= "<0200> <02ff> <0200>\n";
        $stream .= "<0300> <03ff> <0300>\n";
        $stream .= "<0400> <04ff> <0400>\n";
        $stream .= "<0500> <05ff> <0500>\n";
        $stream .= "<0600> <06ff> <0600>\n";
        $stream .= "<0700> <07ff> <0700>\n";
        $stream .= "<0800> <08ff> <0800>\n";
        $stream .= "<0900> <09ff> <0900>\n";
        $stream .= "<0a00> <0aff> <0a00>\n";
        $stream .= "<0b00> <0bff> <0b00>\n";
        $stream .= "<0c00> <0cff> <0c00>\n";
        $stream .= "<0d00> <0dff> <0d00>\n";
        $stream .= "<0e00> <0eff> <0e00>\n";
        $stream .= "<0f00> <0fff> <0f00>\n";
        $stream .= "<1000> <10ff> <1000>\n";
        $stream .= "<1100> <11ff> <1100>\n";
        $stream .= "<1200> <12ff> <1200>\n";
        $stream .= "<1300> <13ff> <1300>\n";
        $stream .= "<1400> <14ff> <1400>\n";
        $stream .= "<1500> <15ff> <1500>\n";
        $stream .= "<1600> <16ff> <1600>\n";
        $stream .= "<1700> <17ff> <1700>\n";
        $stream .= "<1800> <18ff> <1800>\n";
        $stream .= "<1900> <19ff> <1900>\n";
        $stream .= "<1a00> <1aff> <1a00>\n";
        $stream .= "<1b00> <1bff> <1b00>\n";
        $stream .= "<1c00> <1cff> <1c00>\n";
        $stream .= "<1d00> <1dff> <1d00>\n";
        $stream .= "<1e00> <1eff> <1e00>\n";
        $stream .= "<1f00> <1fff> <1f00>\n";
        $stream .= "<2000> <20ff> <2000>\n";
        $stream .= "<2100> <21ff> <2100>\n";
        $stream .= "<2200> <22ff> <2200>\n";
        $stream .= "<2300> <23ff> <2300>\n";
        $stream .= "<2400> <24ff> <2400>\n";
        $stream .= "<2500> <25ff> <2500>\n";
        $stream .= "<2600> <26ff> <2600>\n";
        $stream .= "<2700> <27ff> <2700>\n";
        $stream .= "<2800> <28ff> <2800>\n";
        $stream .= "<2900> <29ff> <2900>\n";
        $stream .= "<2a00> <2aff> <2a00>\n";
        $stream .= "<2b00> <2bff> <2b00>\n";
        $stream .= "<2c00> <2cff> <2c00>\n";
        $stream .= "<2d00> <2dff> <2d00>\n";
        $stream .= "<2e00> <2eff> <2e00>\n";
        $stream .= "<2f00> <2fff> <2f00>\n";
        $stream .= "<3000> <30ff> <3000>\n";
        $stream .= "<3100> <31ff> <3100>\n";
        $stream .= "<3200> <32ff> <3200>\n";
        $stream .= "<3300> <33ff> <3300>\n";
        $stream .= "<3400> <34ff> <3400>\n";
        $stream .= "<3500> <35ff> <3500>\n";
        $stream .= "<3600> <36ff> <3600>\n";
        $stream .= "<3700> <37ff> <3700>\n";
        $stream .= "<3800> <38ff> <3800>\n";
        $stream .= "<3900> <39ff> <3900>\n";
        $stream .= "<3a00> <3aff> <3a00>\n";
        $stream .= "<3b00> <3bff> <3b00>\n";
        $stream .= "<3c00> <3cff> <3c00>\n";
        $stream .= "<3d00> <3dff> <3d00>\n";
        $stream .= "<3e00> <3eff> <3e00>\n";
        $stream .= "<3f00> <3fff> <3f00>\n";
        $stream .= "<4000> <40ff> <4000>\n";
        $stream .= "<4100> <41ff> <4100>\n";
        $stream .= "<4200> <42ff> <4200>\n";
        $stream .= "<4300> <43ff> <4300>\n";
        $stream .= "<4400> <44ff> <4400>\n";
        $stream .= "<4500> <45ff> <4500>\n";
        $stream .= "<4600> <46ff> <4600>\n";
        $stream .= "<4700> <47ff> <4700>\n";
        $stream .= "<4800> <48ff> <4800>\n";
        $stream .= "<4900> <49ff> <4900>\n";
        $stream .= "<4a00> <4aff> <4a00>\n";
        $stream .= "<4b00> <4bff> <4b00>\n";
        $stream .= "<4c00> <4cff> <4c00>\n";
        $stream .= "<4d00> <4dff> <4d00>\n";
        $stream .= "<4e00> <4eff> <4e00>\n";
        $stream .= "<4f00> <4fff> <4f00>\n";
        $stream .= "<5000> <50ff> <5000>\n";
        $stream .= "<5100> <51ff> <5100>\n";
        $stream .= "<5200> <52ff> <5200>\n";
        $stream .= "<5300> <53ff> <5300>\n";
        $stream .= "<5400> <54ff> <5400>\n";
        $stream .= "<5500> <55ff> <5500>\n";
        $stream .= "<5600> <56ff> <5600>\n";
        $stream .= "<5700> <57ff> <5700>\n";
        $stream .= "<5800> <58ff> <5800>\n";
        $stream .= "<5900> <59ff> <5900>\n";
        $stream .= "<5a00> <5aff> <5a00>\n";
        $stream .= "<5b00> <5bff> <5b00>\n";
        $stream .= "<5c00> <5cff> <5c00>\n";
        $stream .= "<5d00> <5dff> <5d00>\n";
        $stream .= "<5e00> <5eff> <5e00>\n";
        $stream .= "<5f00> <5fff> <5f00>\n";
        $stream .= "<6000> <60ff> <6000>\n";
        $stream .= "<6100> <61ff> <6100>\n";
        $stream .= "<6200> <62ff> <6200>\n";
        $stream .= "<6300> <63ff> <6300>\n";
        $stream .= "endbfrange\n";
        $stream .= "100 beginbfrange\n";
        $stream .= "<6400> <64ff> <6400>\n";
        $stream .= "<6500> <65ff> <6500>\n";
        $stream .= "<6600> <66ff> <6600>\n";
        $stream .= "<6700> <67ff> <6700>\n";
        $stream .= "<6800> <68ff> <6800>\n";
        $stream .= "<6900> <69ff> <6900>\n";
        $stream .= "<6a00> <6aff> <6a00>\n";
        $stream .= "<6b00> <6bff> <6b00>\n";
        $stream .= "<6c00> <6cff> <6c00>\n";
        $stream .= "<6d00> <6dff> <6d00>\n";
        $stream .= "<6e00> <6eff> <6e00>\n";
        $stream .= "<6f00> <6fff> <6f00>\n";
        $stream .= "<7000> <70ff> <7000>\n";
        $stream .= "<7100> <71ff> <7100>\n";
        $stream .= "<7200> <72ff> <7200>\n";
        $stream .= "<7300> <73ff> <7300>\n";
        $stream .= "<7400> <74ff> <7400>\n";
        $stream .= "<7500> <75ff> <7500>\n";
        $stream .= "<7600> <76ff> <7600>\n";
        $stream .= "<7700> <77ff> <7700>\n";
        $stream .= "<7800> <78ff> <7800>\n";
        $stream .= "<7900> <79ff> <7900>\n";
        $stream .= "<7a00> <7aff> <7a00>\n";
        $stream .= "<7b00> <7bff> <7b00>\n";
        $stream .= "<7c00> <7cff> <7c00>\n";
        $stream .= "<7d00> <7dff> <7d00>\n";
        $stream .= "<7e00> <7eff> <7e00>\n";
        $stream .= "<7f00> <7fff> <7f00>\n";
        $stream .= "<8000> <80ff> <8000>\n";
        $stream .= "<8100> <81ff> <8100>\n";
        $stream .= "<8200> <82ff> <8200>\n";
        $stream .= "<8300> <83ff> <8300>\n";
        $stream .= "<8400> <84ff> <8400>\n";
        $stream .= "<8500> <85ff> <8500>\n";
        $stream .= "<8600> <86ff> <8600>\n";
        $stream .= "<8700> <87ff> <8700>\n";
        $stream .= "<8800> <88ff> <8800>\n";
        $stream .= "<8900> <89ff> <8900>\n";
        $stream .= "<8a00> <8aff> <8a00>\n";
        $stream .= "<8b00> <8bff> <8b00>\n";
        $stream .= "<8c00> <8cff> <8c00>\n";
        $stream .= "<8d00> <8dff> <8d00>\n";
        $stream .= "<8e00> <8eff> <8e00>\n";
        $stream .= "<8f00> <8fff> <8f00>\n";
        $stream .= "<9000> <90ff> <9000>\n";
        $stream .= "<9100> <91ff> <9100>\n";
        $stream .= "<9200> <92ff> <9200>\n";
        $stream .= "<9300> <93ff> <9300>\n";
        $stream .= "<9400> <94ff> <9400>\n";
        $stream .= "<9500> <95ff> <9500>\n";
        $stream .= "<9600> <96ff> <9600>\n";
        $stream .= "<9700> <97ff> <9700>\n";
        $stream .= "<9800> <98ff> <9800>\n";
        $stream .= "<9900> <99ff> <9900>\n";
        $stream .= "<9a00> <9aff> <9a00>\n";
        $stream .= "<9b00> <9bff> <9b00>\n";
        $stream .= "<9c00> <9cff> <9c00>\n";
        $stream .= "<9d00> <9dff> <9d00>\n";
        $stream .= "<9e00> <9eff> <9e00>\n";
        $stream .= "<9f00> <9fff> <9f00>\n";
        $stream .= "<a000> <a0ff> <a000>\n";
        $stream .= "<a100> <a1ff> <a100>\n";
        $stream .= "<a200> <a2ff> <a200>\n";
        $stream .= "<a300> <a3ff> <a300>\n";
        $stream .= "<a400> <a4ff> <a400>\n";
        $stream .= "<a500> <a5ff> <a500>\n";
        $stream .= "<a600> <a6ff> <a600>\n";
        $stream .= "<a700> <a7ff> <a700>\n";
        $stream .= "<a800> <a8ff> <a800>\n";
        $stream .= "<a900> <a9ff> <a900>\n";
        $stream .= "<aa00> <aaff> <aa00>\n";
        $stream .= "<ab00> <abff> <ab00>\n";
        $stream .= "<ac00> <acff> <ac00>\n";
        $stream .= "<ad00> <adff> <ad00>\n";
        $stream .= "<ae00> <aeff> <ae00>\n";
        $stream .= "<af00> <afff> <af00>\n";
        $stream .= "<b000> <b0ff> <b000>\n";
        $stream .= "<b100> <b1ff> <b100>\n";
        $stream .= "<b200> <b2ff> <b200>\n";
        $stream .= "<b300> <b3ff> <b300>\n";
        $stream .= "<b400> <b4ff> <b400>\n";
        $stream .= "<b500> <b5ff> <b500>\n";
        $stream .= "<b600> <b6ff> <b600>\n";
        $stream .= "<b700> <b7ff> <b700>\n";
        $stream .= "<b800> <b8ff> <b800>\n";
        $stream .= "<b900> <b9ff> <b900>\n";
        $stream .= "<ba00> <baff> <ba00>\n";
        $stream .= "<bb00> <bbff> <bb00>\n";
        $stream .= "<bc00> <bcff> <bc00>\n";
        $stream .= "<bd00> <bdff> <bd00>\n";
        $stream .= "<be00> <beff> <be00>\n";
        $stream .= "<bf00> <bfff> <bf00>\n";
        $stream .= "<c000> <c0ff> <c000>\n";
        $stream .= "<c100> <c1ff> <c100>\n";
        $stream .= "<c200> <c2ff> <c200>\n";
        $stream .= "<c300> <c3ff> <c300>\n";
        $stream .= "<c400> <c4ff> <c400>\n";
        $stream .= "<c500> <c5ff> <c500>\n";
        $stream .= "<c600> <c6ff> <c600>\n";
        $stream .= "<c700> <c7ff> <c700>\n";
        $stream .= "endbfrange\n";
        $stream .= "56 beginbfrange\n";
        $stream .= "<c800> <c8ff> <c800>\n";
        $stream .= "<c900> <c9ff> <c900>\n";
        $stream .= "<ca00> <caff> <ca00>\n";
        $stream .= "<cb00> <cbff> <cb00>\n";
        $stream .= "<cc00> <ccff> <cc00>\n";
        $stream .= "<cd00> <cdff> <cd00>\n";
        $stream .= "<ce00> <ceff> <ce00>\n";
        $stream .= "<cf00> <cfff> <cf00>\n";
        $stream .= "<d000> <d0ff> <d000>\n";
        $stream .= "<d100> <d1ff> <d100>\n";
        $stream .= "<d200> <d2ff> <d200>\n";
        $stream .= "<d300> <d3ff> <d300>\n";
        $stream .= "<d400> <d4ff> <d400>\n";
        $stream .= "<d500> <d5ff> <d500>\n";
        $stream .= "<d600> <d6ff> <d600>\n";
        $stream .= "<d700> <d7ff> <d700>\n";
        $stream .= "<d800> <d8ff> <d800>\n";
        $stream .= "<d900> <d9ff> <d900>\n";
        $stream .= "<da00> <daff> <da00>\n";
        $stream .= "<db00> <dbff> <db00>\n";
        $stream .= "<dc00> <dcff> <dc00>\n";
        $stream .= "<dd00> <ddff> <dd00>\n";
        $stream .= "<de00> <deff> <de00>\n";
        $stream .= "<df00> <dfff> <df00>\n";
        $stream .= "<e000> <e0ff> <e000>\n";
        $stream .= "<e100> <e1ff> <e100>\n";
        $stream .= "<e200> <e2ff> <e200>\n";
        $stream .= "<e300> <e3ff> <e300>\n";
        $stream .= "<e400> <e4ff> <e400>\n";
        $stream .= "<e500> <e5ff> <e500>\n";
        $stream .= "<e600> <e6ff> <e600>\n";
        $stream .= "<e700> <e7ff> <e700>\n";
        $stream .= "<e800> <e8ff> <e800>\n";
        $stream .= "<e900> <e9ff> <e900>\n";
        $stream .= "<ea00> <eaff> <ea00>\n";
        $stream .= "<eb00> <ebff> <eb00>\n";
        $stream .= "<ec00> <ecff> <ec00>\n";
        $stream .= "<ed00> <edff> <ed00>\n";
        $stream .= "<ee00> <eeff> <ee00>\n";
        $stream .= "<ef00> <efff> <ef00>\n";
        $stream .= "<f000> <f0ff> <f000>\n";
        $stream .= "<f100> <f1ff> <f100>\n";
        $stream .= "<f200> <f2ff> <f200>\n";
        $stream .= "<f300> <f3ff> <f300>\n";
        $stream .= "<f400> <f4ff> <f400>\n";
        $stream .= "<f500> <f5ff> <f500>\n";
        $stream .= "<f600> <f6ff> <f600>\n";
        $stream .= "<f700> <f7ff> <f700>\n";
        $stream .= "<f800> <f8ff> <f800>\n";
        $stream .= "<f900> <f9ff> <f900>\n";
        $stream .= "<fa00> <faff> <fa00>\n";
        $stream .= "<fb00> <fbff> <fb00>\n";
        $stream .= "<fc00> <fcff> <fc00>\n";
        $stream .= "<fd00> <fdff> <fd00>\n";
        $stream .= "<fe00> <feff> <fe00>\n";
        $stream .= "<ff00> <ffff> <ff00>\n";
        $stream .= "endbfrange\n";
        $stream .= "endcmap\n";
        $stream .= "CMapName currentdict /CMap defineresource pop\n";
        $stream .= "end\n";
        $stream .= "end";
        // ToUnicode Object.
        $this->_newobj();
        $stream = ($this->compress) ? gzcompress($stream) : $stream;
        $filter = ($this->compress) ? '/Filter /FlateDecode ' : '';
        $stream = $this->_getrawstream($stream);
        $this->_out('<<'.$filter.'/Length '.strlen($stream).'>> stream'."\n".$stream."\n".'endstream'."\n".'endobj');
        // CIDFontType2.
        // A CIDFont whose glyph descriptions are based on TrueType font technology.
        $oid = $this->_newobj();
        $out = '<< /Type /Font';
        $out .= ' /Subtype /CIDFontType2';
        $out .= ' /BaseFont /'.$fontname;
        // A dictionary containing entries that define the character collection of the CIDFont.
        $cidinfo = '/Registry '.$this->_datastring($font['cidinfo']['Registry'], $oid);
        $cidinfo .= ' /Ordering '.$this->_datastring($font['cidinfo']['Ordering'], $oid);
        $cidinfo .= ' /Supplement '.$font['cidinfo']['Supplement'];
        $out .= ' /CIDSystemInfo << '.$cidinfo.' >>';
        $out .= ' /FontDescriptor '.($this->n + 1).' 0 R';
        $out .= ' /DW '.$font['dw']; // Default width.
        $out .= "\n".$this->_putfontwidths($font, 0);
        if (isset($font['ctg']) AND (!$this->empty_string($font['ctg']))) {
            $out .= "\n".'/CIDToGIDMap '.($this->n + 2).' 0 R';
        }
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        // Font descriptor.
        // A font descriptor describing the CIDFont default metrics other than its glyph widths.
        $this->_newobj();
        $out = '<< /Type /FontDescriptor';
        $out .= ' /FontName /'.$fontname;
        foreach ($font['desc'] as $key => $value) {
            if (is_float($value)) {
                $value = sprintf('%F', $value);
            }
            $out .= ' /'.$key.' '.$value;
        }
        $fontdir = false;
        if (!$this->empty_string($font['file'])) {
            // A stream containing a TrueType font.
            $out .= ' /FontFile2 '.$this->fontfiles[$font['file']]['n'].' 0 R';
            $fontdir = $this->fontfiles[$font['file']]['fontdir'];
        }
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        if (isset($font['ctg']) AND (!$this->empty_string($font['ctg']))) {
            $this->_newobj();
            // Embed CIDToGIDMap.
            // A specification of the mapping from CIDs to glyph indices.
            // Search and get CTG font file to embedd.
            $ctgfile = strtolower($font['ctg']);
            // Search and get ctg font file to embedd.
            $fontfile = '';
            // Search files on various directories.
            if (($fontdir !== false) AND file_exists($fontdir.$ctgfile)) {
                $fontfile = $fontdir.$ctgfile;
            } else if (file_exists($this->_getfontpath().$ctgfile)) {
                $fontfile = $this->_getfontpath().$ctgfile;
            } else if (file_exists($ctgfile)) {
                $fontfile = $ctgfile;
            }
            if ($this->empty_string($fontfile)) {
                $this->errord('Font file not found: '.$ctgfile);
            }
            $stream = $this->_getrawstream(file_get_contents($fontfile));
            $out = '<< /Length '.strlen($stream).'';
            if (substr($fontfile, -2) == '.z') { // Check file extension.
                // Decompresses data encoded using the public-domain.
                // Zlib/deflate compression method, reproducing the original text or binary data.
                $out .= ' /Filter /FlateDecode';
            }
            $out .= ' >>';
            $out .= ' stream'."\n".$stream."\n".'endstream';
            $out .= "\n".'endobj';
            $this->_out($out);
        }
    }

    /**
     * output CID-0 fonts.
     * A Type 0 CIDFont contains glyph descriptions based on the Adobe Type 1 font format
     */
    protected function _putcidfont0($font) {
        $cidoffset = 0;
        if (!isset($font['cw'][1])) {
            $cidoffset = 31;
        }
        if (isset($font['cidinfo']['uni2cid'])) {
            // Convert unicode to cid.
            $uni2cid = $font['cidinfo']['uni2cid'];
            $cw = array();
            foreach ($font['cw'] as $uni => $width) {
                if (isset($uni2cid[$uni])) {
                    $cw[($uni2cid[$uni] + $cidoffset)] = $width;
                } else if ($uni < 256) {
                    $cw[$uni] = $width;
                } // Else unknown character.
            }
            $font = array_merge($font, array('cw' => $cw));
        }
        $name = $font['name'];
        $enc = $font['enc'];
        if ($enc) {
            $longname = $name.'-'.$enc;
        } else {
            $longname = $name;
        }
        $out = $this->_getobj($this->fontobjids[$font['fontkey']])."\n";
        $out .= '<</Type /Font';
        $out .= ' /Subtype /Type0';
        $out .= ' /BaseFont /'.$longname;
        $out .= ' /Name /F'.$font['i'];
        if ($enc) {
            $out .= ' /Encoding /'.$enc;
        }
        $out .= ' /DescendantFonts ['.($this->n + 1).' 0 R]';
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        $oid = $this->_newobj();
        $out = '<</Type /Font';
        $out .= ' /Subtype /CIDFontType0';
        $out .= ' /BaseFont /'.$name;
        $cidinfo = '/Registry '.$this->_datastring($font['cidinfo']['Registry'], $oid);
        $cidinfo .= ' /Ordering '.$this->_datastring($font['cidinfo']['Ordering'], $oid);
        $cidinfo .= ' /Supplement '.$font['cidinfo']['Supplement'];
        $out .= ' /CIDSystemInfo <<'.$cidinfo.'>>';
        $out .= ' /FontDescriptor '.($this->n + 1).' 0 R';
        $out .= ' /DW '.$font['dw'];
        $out .= "\n".$this->_putfontwidths($font, $cidoffset);
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        $this->_newobj();
        $s = '<</Type /FontDescriptor /FontName /'.$name;
        foreach ($font['desc'] as $k => $v) {
            if ($k != 'Style') {
                if (is_float($v)) {
                    $v = sprintf('%F', $v);
                }
                $s .= ' /'.$k.' '.$v.'';
            }
        }
        $s .= '>>';
        $s .= "\n".'endobj';
        $this->_out($s);
    }

    /**
     * output images.
     * @protected
     */
    protected function _putimages() {
        $filter = ($this->compress) ? '/Filter /FlateDecode ' : '';
        foreach ($this->imagekeys as $file) {
            $info = $this->getimagebuffer($file);
            // Set object for alternate images array.
            if ((!$this->pdfamode) AND isset($info['altimgs']) AND !empty($info['altimgs'])) {
                $altoid = $this->_newobj();
                $out = '[';
                foreach ($info['altimgs'] as $altimage) {
                    if (isset($this->xobjects['I'.$altimage[0]]['n'])) {
                        $out .= ' << /Image '.$this->xobjects['I'.$altimage[0]]['n'].' 0 R';
                        $out .= ' /DefaultForPrinting';
                        if ($altimage[1] === true) {
                            $out .= ' true';
                        } else {
                            $out .= ' false';
                        }
                        $out .= ' >>';
                    }
                }
                $out .= ' ]';
                $out .= "\n".'endobj';
                $this->_out($out);
            }
            // Set image object.
            $oid = $this->_newobj();
            $this->xobjects['I'.$info['i']] = array('n' => $oid);
            $this->setimagesubbuffer($file, 'n', $this->n);
            $out = '<</Type /XObject';
            $out .= ' /Subtype /Image';
            $out .= ' /Width '.$info['w'];
            $out .= ' /Height '.$info['h'];
            if (array_key_exists('masked', $info)) {
                $out .= ' /SMask '.($this->n - 1).' 0 R';
            }
            // Set color space.
            $icc = false;
            if (isset($info['icc']) AND ($info['icc'] !== false)) {
                // ICC Colour Space.
                $icc = true;
                $out .= ' /ColorSpace [/ICCBased '.($this->n + 1).' 0 R]';
            } else if ($info['cs'] == 'Indexed') {
                // Indexed Colour Space.
                $out .= ' /ColorSpace [/Indexed /DeviceRGB '.((strlen($info['pal']) / 3) - 1).' '.($this->n + 1).' 0 R]';
            } else {
                // Device Colour Space.
                $out .= ' /ColorSpace /'.$info['cs'];
            }
            if ($info['cs'] == 'DeviceCMYK') {
                $out .= ' /Decode [1 0 1 0 1 0 1 0]';
            }
            $out .= ' /BitsPerComponent '.$info['bpc'];
            if (isset($altoid) AND ($altoid > 0)) {
                // Reference to alternate images dictionary.
                $out .= ' /Alternates '.$altoid.' 0 R';
            }
            if (isset($info['exurl']) AND !empty($info['exurl'])) {
                // External stream.
                $out .= ' /Length 0';
                $out .= ' /F << /FS /URL /F '.$this->_datastring($info['exurl'], $oid).' >>';
                if (isset($info['f'])) {
                    $out .= ' /FFilter /'.$info['f'];
                }
                $out .= ' >>';
                $out .= ' stream'."\n".'endstream';
            } else {
                if (isset($info['f'])) {
                    $out .= ' /Filter /'.$info['f'];
                }
                if (isset($info['parms'])) {
                    $out .= ' '.$info['parms'];
                }
                if (isset($info['trns']) AND is_array($info['trns'])) {
                    $trns = '';
                    $countinfo = count($info['trns']);
                    for ($i = 0; $i < $countinfo; ++$i) {
                        $trns .= $info['trns'][$i].' '.$info['trns'][$i].' ';
                    }
                    $out .= ' /Mask ['.$trns.']';
                }
                $stream = $this->_getrawstream($info['data']);
                $out .= ' /Length '.strlen($stream).' >>';
                $out .= ' stream'."\n".$stream."\n".'endstream';
            }
            $out .= "\n".'endobj';
            $this->_out($out);
            if ($icc) {
                // ICC colour profile.
                $this->_newobj();
                $icc = ($this->compress) ? gzcompress($info['icc']) : $info['icc'];
                $icc = $this->_getrawstream($icc);
                $this->_out('<</N '.$info['ch'].' /Alternate /'.$info['cs'].' '.$filter.'/Length '.strlen($icc).'>>
                             stream'."\n".$icc."\n".'endstream'."\n".'endobj');
            } else if ($info['cs'] == 'Indexed') {
                // Colour palette.
                $this->_newobj();
                $pal = ($this->compress) ? gzcompress($info['pal']) : $info['pal'];
                $pal = $this->_getrawstream($pal);
                $this->_out('<<'.$filter.'/Length '.strlen($pal).'>> stream'."\n".$pal."\n".'endstream'."\n".'endobj');
            }
        }
    }

    /**
     * output Form XObjects Templates.
     * @see starttemplate(), endtemplate(), printtemplate()
     */
    protected function _putxobjects() {
        foreach ($this->xobjects as $key => $data) {
            if (isset($data['outdata'])) {
                $stream = trim($data['outdata']);
                $out = $this->_getobj($data['n'])."\n";
                $out .= '<<';
                $out .= ' /Type /XObject';
                $out .= ' /Subtype /Form';
                $out .= ' /FormType 1';
                if ($this->compress) {
                    $stream = gzcompress($stream);
                    $out .= ' /Filter /FlateDecode';
                }
                $out .= sprintf(' /BBox [%F %F %F %F]', ($data['x'] * $this->k), (-$data['y'] * $this->k),
                         (($data['w'] + $data['x']) * $this->k), (($data['h'] - $data['y']) * $this->k));
                $out .= ' /Matrix [1 0 0 1 0 0]';
                $out .= ' /Resources <<';
                $out .= ' /ProcSet [/PDF /text /ImageB /ImageC /ImageI]';
                if (!$this->pdfamode) {
                    // Transparency.
                    if (isset($data['extgstates']) AND !empty($data['extgstates'])) {
                        $out .= ' /ExtGState <<';
                        foreach ($data['extgstates'] as $k => $extgstate) {
                            if (isset($this->extgstates[$k]['name'])) {
                                $out .= ' /'.$this->extgstates[$k]['name'];
                            } else {
                                $out .= ' /GS'.$k;
                            }
                            $out .= ' '.$this->extgstates[$k]['n'].' 0 R';
                        }
                        $out .= ' >>';
                    }
                    if (isset($data['gradients']) AND !empty($data['gradients'])) {
                        $gp = '';
                        $gs = '';
                        foreach ($data['gradients'] as $id => $grad) {
                            // Gradient patterns.
                            $gp .= ' /p'.$id.' '.$this->gradients[$id]['pattern'].' 0 R';
                            // Gradient shadings.
                            $gs .= ' /Sh'.$id.' '.$this->gradients[$id]['id'].' 0 R';
                        }
                        $out .= ' /Pattern <<'.$gp.' >>';
                        $out .= ' /Shading <<'.$gs.' >>';
                    }
                }
                // Spot colors.
                if (isset($data['spotcolors']) AND !empty($data['spotcolors'])) {
                    $out .= ' /ColorSpace <<';
                    foreach ($data['spotcolors'] as $name => $color) {
                        $out .= ' /CS'.$color['i'].' '.$this->spotcolors[$name]['n'].' 0 R';
                    }
                    $out .= ' >>';
                }
                // Fonts.
                if (!empty($data['fonts'])) {
                    $out .= ' /Font <<';
                    foreach ($data['fonts'] as $fontkey => $fontid) {
                        $out .= ' /F'.$fontid.' '.$this->fontobjids[$fontkey].' 0 R';
                    }
                    $out .= ' >>';
                }
                // Images or nested xobjects.
                if (!empty($data['images']) OR !empty($data['xobjects'])) {
                    $out .= ' /XObject <<';
                    foreach ($data['images'] as $imgid) {
                        $out .= ' /I'.$imgid.' '.$this->xobjects['I'.$imgid]['n'].' 0 R';
                    }
                    foreach ($data['xobjects'] as $subid => $subobjid) {
                        $out .= ' /'.$subid.' '.$subobjid['n'].' 0 R';
                    }
                    $out .= ' >>';
                }
                $out .= ' >>'; // End resources.
                if (isset($data['group']) AND ($data['group'] !== false)) {
                    // Set transparency group.
                    $out .= ' /Group << /Type /Group /S /Transparency';
                    if (is_array($data['group'])) {
                        if (isset($data['group']['CS']) AND !empty($data['group']['CS'])) {
                            $out .= ' /CS /'.$data['group']['CS'];
                        }
                        if (isset($data['group']['I'])) {
                            $out .= ' /I /'.($data['group']['I'] === true ? 'true' : 'false');
                        }
                        if (isset($data['group']['K'])) {
                            $out .= ' /K /'.($data['group']['K'] === true ? 'true' : 'false');
                        }
                    }
                    $out .= ' >>';
                }
                $stream = $this->_getrawstream($stream, $data['n']);
                $out .= ' /Length '.strlen($stream);
                $out .= ' >>';
                $out .= ' stream'."\n".$stream."\n".'endstream';
                $out .= "\n".'endobj';
                $this->_out($out);
            }
        }
    }

    /**
     * output Spot Colors Resources.
     */
    protected function _putspotcolors() {
        foreach ($this->spotcolors as $name => $color) {
            $this->_newobj();
            $this->spotcolors[$name]['n'] = $this->n;
            $out = '[/Separation /'.str_replace(' ', '#20', $name);
            $out .= ' /DeviceCMYK <<';
            $out .= ' /Range [0 1 0 1 0 1 0 1] /C0 [0 0 0 0]';
            $out .= ' '.sprintf('/C1 [%F %F %F %F] ', ($color['C'] / 100), ($color['M'] / 100),
                                ($color['Y'] / 100), ($color['K'] / 100));
            $out .= ' /FunctionType 2 /Domain [0 1] /N 1>>]';
            $out .= "\n".'endobj';
            $this->_out($out);
        }
    }

    /**
     * Return XObjects Dictionary.
     * @return string XObjects dictionary
     */
    protected function _getxobjectdict() {
        $out = '';
        foreach ($this->xobjects as $id => $objid) {
            $out .= ' /'.$id.' '.$objid['n'].' 0 R';
        }
        return $out;
    }

    /**
     * output Resources Dictionary.
     * @protected
     */
    protected function _putresourcedict() {
        $out = $this->_getobj(2)."\n";
        $out .= '<< /ProcSet [/PDF /text /ImageB /ImageC /ImageI]';
        $out .= ' /Font <<';
        foreach ($this->fontkeys as $fontkey) {
            $font = $this->getfontbuffer($fontkey);
            $out .= ' /F'.$font['i'].' '.$font['n'].' 0 R';
        }
        $out .= ' >>';
        $out .= ' /XObject <<';
        $out .= $this->_getxobjectdict();
        $out .= ' >>';
        // Layers.
        if (!empty($this->pdflayers)) {
            $out .= ' /Properties <<';
            foreach ($this->pdflayers as $layer) {
                $out .= ' /'.$layer['layer'].' '.$layer['objid'].' 0 R';
            }
            $out .= ' >>';
        }
        if (!$this->pdfamode) {
            // Transparency.
            if (isset($this->extgstates) AND !empty($this->extgstates)) {
                $out .= ' /ExtGState <<';
                foreach ($this->extgstates as $k => $extgstate) {
                    if (isset($extgstate['name'])) {
                        $out .= ' /'.$extgstate['name'];
                    } else {
                        $out .= ' /GS'.$k;
                    }
                    $out .= ' '.$extgstate['n'].' 0 R';
                }
                $out .= ' >>';
            }
            if (isset($this->gradients) AND !empty($this->gradients)) {
                $gp = '';
                $gs = '';
                foreach ($this->gradients as $id => $grad) {
                    // Gradient patterns.
                    $gp .= ' /p'.$id.' '.$grad['pattern'].' 0 R';
                    // Gradient shadings.
                    $gs .= ' /Sh'.$id.' '.$grad['id'].' 0 R';
                }
                $out .= ' /Pattern <<'.$gp.' >>';
                $out .= ' /Shading <<'.$gs.' >>';
            }
        }
        // Spot colors.
        if (isset($this->spotcolors) AND !empty($this->spotcolors)) {
            $out .= ' /ColorSpace <<';
            foreach ($this->spotcolors as $color) {
                $out .= ' /CS'.$color['i'].' '.$color['n'].' 0 R';
            }
            $out .= ' >>';
        }
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
    }

    /**
     * output Resources.
     * @protected
     */
    protected function _putresources() {
        $this->_putextgstates();
        $this->_putocg();
        $this->_putfonts();
        $this->_putimages();
        $this->_putspotcolors();
        $this->_putshaders();
        $this->_putxobjects();
        $this->_putresourcedict();
        $this->_putdests();
        $this->_putbookmarks();
        $this->_putembeddedfiles();
        $this->_putannotsobjs();
        $this->_putjavascript();
        $this->_putencryption();
    }

    /**
     * Adds some Metadata information (Document Information Dictionary)
     * (see Chapter 14.3.3 Document Information Dictionary of PDF32000_2008.pdf Reference)
     */
    protected function _putinfo() {
        $oid = $this->_newobj();
        $out = '<<';
        // Store current isunicode value.
        $previsunicode = $this->isunicode;
        if ($this->docinfounicode) {
            $this->isunicode = true;
        }
        if (!$this->empty_string($this->title)) {
            // The document's title.
            $out .= ' /Title '.$this->_textstring($this->title, $oid);
        }
        if (!$this->empty_string($this->author)) {
            // The name of the person who created the document.
            $out .= ' /Author '.$this->_textstring($this->author, $oid);
        }
        if (!$this->empty_string($this->subject)) {
            // The subject of the document.
            $out .= ' /Subject '.$this->_textstring($this->subject, $oid);
        }
        if (!$this->empty_string($this->keywords)) {
            // Keywords associated with the document.
            $out .= ' /Keywords '.$this->_textstring($this->keywords.' TCPDF', $oid);
        }
        if (!$this->empty_string($this->creator)) {
            // If the document was converted to PDF from another format, the name of the conforming product
            // that created the original document from which it was converted.
            $out .= ' /Creator '.$this->_textstring($this->creator, $oid);
        }
        // Restore previous isunicode value.
        $this->isunicode = $previsunicode;
        // Default producer.
        $out .= ' /Producer '.$this->_textstring($this->pdfproducer, $oid);
        // The date and time the document was created, in human-readable form.
        $out .= ' /CreationDate '.$this->_datestring(0, $this->doccreationtimestamp);
        // The date and time the document was most recently modified, in human-readable form.
        $out .= ' /ModDate '.$this->_datestring(0, $this->docmodificationtimestamp);
        // A name object indicating whether the document has been modified to include trapping information.
        $out .= ' /Trapped /False';
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        return $oid;
    }

    /**
     * Set additional XMP data to be added on the default XMP data just before the end of "x:xmpmeta" tag.
     * IMPORTANT: This data is added as-is without controls, so you have to validate your data before using
       this method!
     */
    public function setextraxmp($xmp) {
        $this->customxmp = $xmp;
    }

    /**
     * Put XMP data object and return ID.
     * @return (int) The object ID.
     */
    protected function _putxmp() {
        $oid = $this->_newobj();
        // Store current isunicode value.
        $previsunicode = $this->isunicode;
        $this->isunicode = true;
        $prevencrypted = $this->encrypted;
        $this->encrypted = false;
        // Set XMP data.
        $xmp = '<?xpacket begin="'.$this->unichr(0xfeff).'" id="W5M0MpCehiHzreSzNTczkc9d"?>'."\n";
        $xmp .= '<x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 4.2.1-c043 52.372728, 2009/01/18-15:08:04">'."\n";
        $xmp .= "\t".'<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">'."\n";
        $xmp .= "\t\t".'<rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">'."\n";
        $xmp .= "\t\t\t".'<dc:format>application/pdf</dc:format>'."\n";
        $xmp .= "\t\t\t".'<dc:title>'."\n";
        $xmp .= "\t\t\t\t".'<rdf:Alt>'."\n";
        $xmp .= "\t\t\t\t\t".'<rdf:li xml:lang="x-default">'.$this->_escapexml($this->title).'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t".'</rdf:Alt>'."\n";
        $xmp .= "\t\t\t".'</dc:title>'."\n";
        $xmp .= "\t\t\t".'<dc:creator>'."\n";
        $xmp .= "\t\t\t\t".'<rdf:Seq>'."\n";
        $xmp .= "\t\t\t\t\t".'<rdf:li>'.$this->_escapexml($this->author).'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t".'</rdf:Seq>'."\n";
        $xmp .= "\t\t\t".'</dc:creator>'."\n";
        $xmp .= "\t\t\t".'<dc:description>'."\n";
        $xmp .= "\t\t\t\t".'<rdf:Alt>'."\n";
        $xmp .= "\t\t\t\t\t".'<rdf:li xml:lang="x-default">'.$this->_escapexml($this->subject).'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t".'</rdf:Alt>'."\n";
        $xmp .= "\t\t\t".'</dc:description>'."\n";
        $xmp .= "\t\t\t".'<dc:subject>'."\n";
        $xmp .= "\t\t\t\t".'<rdf:Bag>'."\n";
        $xmp .= "\t\t\t\t\t".'<rdf:li>'.$this->_escapexml($this->keywords).'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t".'</rdf:Bag>'."\n";
        $xmp .= "\t\t\t".'</dc:subject>'."\n";
        $xmp .= "\t\t".'</rdf:Description>'."\n";
        // Convert doc creation date format.
        $dcdate = $this->getformatteddate($this->doccreationtimestamp);
        $doccreationdate = substr($dcdate, 0, 4).'-'.substr($dcdate, 4, 2).'-'.substr($dcdate, 6, 2);
        $doccreationdate .= 'T'.substr($dcdate, 8, 2).':'.substr($dcdate, 10, 2).':'.substr($dcdate, 12, 2);
        $doccreationdate .= '+'.substr($dcdate, 15, 2).':'.substr($dcdate, 18, 2);
        $doccreationdate = $this->_escapexml($doccreationdate);
        // Convert doc modification date format.
        $dmdate = $this->getformatteddate($this->docmodificationtimestamp);
        $docmoddate = substr($dmdate, 0, 4).'-'.substr($dmdate, 4, 2).'-'.substr($dmdate, 6, 2);
        $docmoddate .= 'T'.substr($dmdate, 8, 2).':'.substr($dmdate, 10, 2).':'.substr($dmdate, 12, 2);
        $docmoddate .= '+'.substr($dmdate, 15, 2).':'.substr($dmdate, 18, 2);
        $docmoddate = $this->_escapexml($docmoddate);
        $xmp .= "\t\t".'<rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">'."\n";
        $xmp .= "\t\t\t".'<xmp:CreateDate>'.$doccreationdate.'</xmp:CreateDate>'."\n";
        $xmp .= "\t\t\t".'<xmp:CreatorTool>'.$this->creator.'</xmp:CreatorTool>'."\n";
        $xmp .= "\t\t\t".'<xmp:ModifyDate>'.$docmoddate.'</xmp:ModifyDate>'."\n";
        $xmp .= "\t\t\t".'<xmp:MetadataDate>'.$doccreationdate.'</xmp:MetadataDate>'."\n";
        $xmp .= "\t\t".'</rdf:Description>'."\n";
        $xmp .= "\t\t".'<rdf:Description rdf:about="" xmlns:pdf="http://ns.adobe.com/pdf/1.3/">'."\n";
        $xmp .= "\t\t\t".'<pdf:Keywords>'.$this->_escapexml($this->keywords).' TCPDF</pdf:Keywords>'."\n";
        $xmp .= "\t\t\t".'<pdf:Producer>'.$this->_escapexml($this->pdfproducer).'</pdf:Producer>'."\n";
        $xmp .= "\t\t".'</rdf:Description>'."\n";
        $xmp .= "\t\t".'<rdf:Description rdf:about="" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/">'."\n";
        $uuid = 'uuid:'.substr($this->fileid, 0, 8).'-'.substr($this->fileid, 8, 4).'-'
               .substr($this->fileid, 12, 4).'-'.substr($this->fileid, 16, 4).'-'.substr($this->fileid, 20, 12);
        $xmp .= "\t\t\t".'<xmpMM:DocumentID>'.$uuid.'</xmpMM:DocumentID>'."\n";
        $xmp .= "\t\t\t".'<xmpMM:InstanceID>'.$uuid.'</xmpMM:InstanceID>'."\n";
        $xmp .= "\t\t".'</rdf:Description>'."\n";
        if ($this->pdfamode) {
            $xmp .= "\t\t".'<rdf:Description rdf:about="" xmlns:pdfaid="http://www.aiim.org/pdfa/ns/id/">'."\n";
            $xmp .= "\t\t\t".'<pdfaid:part>1</pdfaid:part>'."\n";
            $xmp .= "\t\t\t".'<pdfaid:conformance>B</pdfaid:conformance>'."\n";
            $xmp .= "\t\t".'</rdf:Description>'."\n";
        }
        // XMP extension schemas.
        $xmp .= "\t\t".'<rdf:Description rdf:about="" xmlns:pdfaExtension="http://www.aiim.org/pdfa/ns/extension/"
                xmlns:pdfaSchema="http://www.aiim.org/pdfa/ns/schema#"
                xmlns:pdfaProperty="http://www.aiim.org/pdfa/ns/property#">'."\n";
        $xmp .= "\t\t\t".'<pdfaExtension:schemas>'."\n";
        $xmp .= "\t\t\t\t".'<rdf:Bag>'."\n";
        $xmp .= "\t\t\t\t\t".'<rdf:li rdf:parseType="Resource">'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:namespaceURI>http://ns.adobe.com/pdf/1.3/</pdfaSchema:namespaceURI>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:prefix>pdf</pdfaSchema:prefix>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:schema>Adobe PDF Schema</pdfaSchema:schema>'."\n";
        $xmp .= "\t\t\t\t\t".'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t\t".'<rdf:li rdf:parseType="Resource">'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:namespaceURI>http://ns.adobe.com/xap/1.0/mm/</pdfaSchema:namespaceURI>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:prefix>xmpMM</pdfaSchema:prefix>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:schema>XMP Media Management Schema</pdfaSchema:schema>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:property>'."\n";
        $xmp .= "\t\t\t\t\t\t\t".'<rdf:Seq>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'<rdf:li rdf:parseType="Resource">'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:category>internal</pdfaProperty:category>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:description>UUID based identifier for specific incarnation of a
               document</pdfaProperty:description>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:name>InstanceID</pdfaProperty:name>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:valueType>URI</pdfaProperty:valueType>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t\t\t\t".'</rdf:Seq>'."\n";
        $xmp .= "\t\t\t\t\t\t".'</pdfaSchema:property>'."\n";
        $xmp .= "\t\t\t\t\t".'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t\t".'<rdf:li rdf:parseType="Resource">'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:namespaceURI>http://www.aiim.org/pdfa/ns/id/</pdfaSchema:namespaceURI>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:prefix>pdfaid</pdfaSchema:prefix>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:schema>PDF/A ID Schema</pdfaSchema:schema>'."\n";
        $xmp .= "\t\t\t\t\t\t".'<pdfaSchema:property>'."\n";
        $xmp .= "\t\t\t\t\t\t\t".'<rdf:Seq>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'<rdf:li rdf:parseType="Resource">'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:category>internal</pdfaProperty:category>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:description>Part of PDF/A standard</pdfaProperty:description>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:name>part</pdfaProperty:name>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:valueType>Integer</pdfaProperty:valueType>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'<rdf:li rdf:parseType="Resource">'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:category>internal</pdfaProperty:category>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:description>Amendment of PDF/A standard</pdfaProperty:description>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:name>amd</pdfaProperty:name>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:valueType>text</pdfaProperty:valueType>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'<rdf:li rdf:parseType="Resource">'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:category>internal</pdfaProperty:category>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:description>Conformance level of PDF/A standard</pdfaProperty:description>'.
                "\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:name>conformance</pdfaProperty:name>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t\t".'<pdfaProperty:valueType>text</pdfaProperty:valueType>'."\n";
        $xmp .= "\t\t\t\t\t\t\t\t".'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t\t\t\t".'</rdf:Seq>'."\n";
        $xmp .= "\t\t\t\t\t\t".'</pdfaSchema:property>'."\n";
        $xmp .= "\t\t\t\t\t".'</rdf:li>'."\n";
        $xmp .= "\t\t\t\t".'</rdf:Bag>'."\n";
        $xmp .= "\t\t\t".'</pdfaExtension:schemas>'."\n";
        $xmp .= "\t\t".'</rdf:Description>'."\n";
        $xmp .= "\t".'</rdf:RDF>'."\n";
        $xmp .= $this->customxmp;
        $xmp .= '</x:xmpmeta>'."\n";
        $xmp .= '<?xpacket end="w"?>';
        $out = '<< /Type /Metadata /Subtype /XML /Length '.strlen($xmp).' >> stream'."\n".$xmp."\n".'endstream'."\n".'endobj';
        // Restore previous isunicode value.
        $this->isunicode = $previsunicode;
        $this->encrypted = $prevencrypted;
        $this->_out($out);
        return $oid;
    }

    /**
     * output Catalog.
     * @return int object id
     * @protected
     */
    protected function _putcatalog() {
        // Put XMP.
        $xmpobj = $this->_putxmp();
        // If required, add standard sRGB_IEC61966-2.1 blackscaled ICC colour profile.
        if ($this->pdfamode OR $this->forcesrgb) {
            $iccobj = $this->_newobj();
            $icc = file_get_contents(dirname(__FILE__).'/sRGB.icc');
            $filter = '';
            if ($this->compress) {
                $filter = ' /Filter /FlateDecode';
                $icc = gzcompress($icc);
            }
            $icc = $this->_getrawstream($icc);
            $this->_out('<</N 3 '.$filter.'/Length '.strlen($icc).'>> stream'."\n".$icc."\n".'endstream'."\n".'endobj');
        }
        // Start catalog.
        $oid = $this->_newobj();
        $out = '<< /Type /Catalog';
        $out .= ' /Version /'.$this->pdfversion;
        $out .= ' /Pages 1 0 R';
        $out .= ' /Names <<';
        if ((!$this->pdfamode) AND ((!empty($this->javascript)) OR (!empty($this->jsobjects)))) {
            $out .= ' /JavaScript '.($this->njs).' 0 R';
        }
        $out .= ' >>';
        if (!empty($this->dests)) {
            $out .= ' /Dests '.$this->ndests.' 0 R';
        }
        $out .= $this->_putviewerpreferences();
        if (isset($this->layoutmode) AND (!$this->empty_string($this->layoutmode))) {
            $out .= ' /PageLayout /'.$this->layoutmode;
        }
        if (isset($this->pagemode) AND (!$this->empty_string($this->pagemode))) {
            $out .= ' /pagemode /'.$this->pagemode;
        }
        if (count($this->outlines) > 0) {
            $out .= ' /Outlines '.$this->outlineroot.' 0 R';
            $out .= ' /pagemode /UseOutlines';
        }
        if ($this->zoommode == 'fullpage') {
            $out .= ' /OpenAction ['.$this->pageobjid[1].' 0 R /Fit]';
        } else if ($this->zoommode == 'fullwidth') {
            $out .= ' /OpenAction ['.$this->pageobjid[1].' 0 R /FitH null]';
        } else if ($this->zoommode == 'real') {
            $out .= ' /OpenAction ['.$this->pageobjid[1].' 0 R /XYZ null null 1]';
        } else if (!is_string($this->zoommode)) {
            $out .= sprintf(' /OpenAction ['.$this->pageobjid[1].' 0 R /XYZ null null %F]', ($this->zoommode / 100));
        }
        $out .= ' /Metadata '.$xmpobj.' 0 R';
        if (isset($this->l['a_meta_language'])) {
            $out .= ' /Lang '.$this->_textstring($this->l['a_meta_language'], $oid);
        }
        // Set outputIntent to sRGB IEC61966-2.1 if required.
        if ($this->pdfamode OR $this->forcesrgb) {
            $out .= ' /outputIntents [<<';
            $out .= ' /Type /outputIntent';
            $out .= ' /S /GTS_PDFA1';
            $out .= ' /outputCondition '.$this->_textstring('sRGB IEC61966-2.1', $oid);
            $out .= ' /outputConditionIdentifier '.$this->_textstring('sRGB IEC61966-2.1', $oid);
            $out .= ' /RegistryName '.$this->_textstring('http://www.color.org', $oid);
            $out .= ' /Info '.$this->_textstring('sRGB IEC61966-2.1', $oid);
            $out .= ' /DestoutputProfile '.$iccobj.' 0 R';
            $out .= ' >>]';
        }
        if (!empty($this->pdflayers)) {
            $lyrobjs = '';
            $lyrobjsprint = '';
            $lyrobjsview = '';
            foreach ($this->pdflayers as $layer) {
                $lyrobjs .= ' '.$layer['objid'].' 0 R';
                if ($layer['print']) {
                    $lyrobjsprint .= ' '.$layer['objid'].' 0 R';
                }
                if ($layer['view']) {
                    $lyrobjsview .= ' '.$layer['objid'].' 0 R';
                }
            }
            $out .= ' /OCProperties << /OCGs ['.$lyrobjs.']';
            $out .= ' /D <<';
            $out .= ' /Name '.$this->_textstring('Layers', $oid);
            $out .= ' /Creator '.$this->_textstring('TCPDF', $oid);
            $out .= ' /BaseState /ON';
            $out .= ' /ON ['.$lyrobjsprint.']';
            $out .= ' /OFF ['.$lyrobjsview.']';
            $out .= ' /Intent /View';
            $out .= ' /AS [';
            $out .= ' << /Event /Print /OCGs ['.$lyrobjs.'] /Category [/Print] >>';
            $out .= ' << /Event /View /OCGs ['.$lyrobjs.'] /Category [/View] >>';
            $out .= ' ]';
            $out .= ' /Order ['.$lyrobjs.']';
            $out .= ' /ListMode /AllPages';
            $out .= ' >>';
            $out .= ' >>';
        }
        // AcroForm.
        if (!empty($this->formobjid) OR ($this->sign AND isset($this->signaturedata['certtype']))) {
            $out .= ' /AcroForm <<';
            $objrefs = '';
            if ($this->sign AND isset($this->signaturedata['certtype'])) {
                // Set reference for signature object.
                $objrefs .= $this->sigobjid.' 0 R';
            }
            if (!empty($this->emptysignatureappearance)) {
                foreach ($this->emptysignatureappearance as $esa) {
                    // Set reference for empty signature objects.
                    $objrefs .= ' '.$esa['objid'].' 0 R';
                }
            }
            if (!empty($this->formobjid)) {
                foreach ($this->formobjid as $objid) {
                    $objrefs .= ' '.$objid.' 0 R';
                }
            }
            $out .= ' /Fields ['.$objrefs.']';
            // It's better to turn off this value and set the appearance stream for each annotation (/AP)
            // to avoid conflicts with signature fields.
            $out .= ' /NeedAppearances false';
            if ($this->sign AND isset($this->signaturedata['certtype'])) {
                if ($this->signaturedata['certtype'] > 0) {
                    $out .= ' /SigFlags 3';
                } else {
                    $out .= ' /SigFlags 1';
                }
            }
            if (isset($this->annotationfonts) AND !empty($this->annotationfonts)) {
                $out .= ' /DR <<';
                $out .= ' /Font <<';
                foreach ($this->annotationfonts as $fontkey => $fontid) {
                    $out .= ' /F'.$fontid.' '.$this->fontobjids[$fontkey].' 0 R';
                }
                $out .= ' >> >>';
            }
            $font = $this->getfontbuffer('helvetica');
            $out .= ' /DA (/F'.$font['i'].' 0 Tf 0 g)';
            $out .= ' /Q '.(($this->rtl) ? '2' : '0');
            $out .= ' >>';
            // Signatures.
            if ($this->sign AND isset($this->signaturedata['certtype'])) {
                if ($this->signaturedata['certtype'] > 0) {
                    $out .= ' /Perms << /DocMDP '.($this->sigobjid + 1).' 0 R >>';
                } else {
                    $out .= ' /Perms << /UR3 '.($this->sigobjid + 1).' 0 R >>';
                }
            }
        }
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        return $oid;
    }

    /**
     * output viewer preferences.
     * @return string for viewer preferences
     */
    protected function _putviewerpreferences() {
        $out = ' /ViewerPreferences <<';
        if ($this->rtl) {
            $out .= ' /Direction /R2L';
        } else {
            $out .= ' /Direction /L2R';
        }
        if (isset($this->viewerpreferences['HideToolbar']) AND ($this->viewerpreferences['HideToolbar'])) {
            $out .= ' /HideToolbar true';
        }
        if (isset($this->viewerpreferences['HideMenubar']) AND ($this->viewerpreferences['HideMenubar'])) {
            $out .= ' /HideMenubar true';
        }
        if (isset($this->viewerpreferences['HideWindowUI']) AND ($this->viewerpreferences['HideWindowUI'])) {
            $out .= ' /HideWindowUI true';
        }
        if (isset($this->viewerpreferences['FitWindow']) AND ($this->viewerpreferences['FitWindow'])) {
            $out .= ' /FitWindow true';
        }
        if (isset($this->viewerpreferences['CenterWindow']) AND ($this->viewerpreferences['CenterWindow'])) {
            $out .= ' /CenterWindow true';
        }
        if (isset($this->viewerpreferences['DisplayDocTitle']) AND ($this->viewerpreferences['DisplayDocTitle'])) {
            $out .= ' /DisplayDocTitle true';
        }
        if (isset($this->viewerpreferences['NonFullScreenPageMode'])) {
            $out .= ' /NonFullScreenPageMode /'.$this->viewerpreferences['NonFullScreenPageMode'];
        }
        if (isset($this->viewerpreferences['ViewArea'])) {
            $out .= ' /ViewArea /'.$this->viewerpreferences['ViewArea'];
        }
        if (isset($this->viewerpreferences['Viewclip'])) {
            $out .= ' /Viewclip /'.$this->viewerpreferences['Viewclip'];
        }
        if (isset($this->viewerpreferences['PrintArea'])) {
            $out .= ' /PrintArea /'.$this->viewerpreferences['PrintArea'];
        }
        if (isset($this->viewerpreferences['Printclip'])) {
            $out .= ' /Printclip /'.$this->viewerpreferences['Printclip'];
        }
        if (isset($this->viewerpreferences['PrintScaling'])) {
            $out .= ' /PrintScaling /'.$this->viewerpreferences['PrintScaling'];
        }
        if (isset($this->viewerpreferences['Duplex']) AND (!$this->empty_string($this->viewerpreferences['Duplex']))) {
            $out .= ' /Duplex /'.$this->viewerpreferences['Duplex'];
        }
        if (isset($this->viewerpreferences['PickTrayByPDFSize'])) {
            if ($this->viewerpreferences['PickTrayByPDFSize']) {
                $out .= ' /PickTrayByPDFSize true';
            } else {
                $out .= ' /PickTrayByPDFSize false';
            }
        }
        if (isset($this->viewerpreferences['PrintPageRange'])) {
            $printpagerangenum = '';
            foreach ($this->viewerpreferences['PrintPageRange'] as $k => $v) {
                $printpagerangenum .= ' '.($v - 1).'';
            }
            $out .= ' /PrintPageRange ['.substr($printpagerangenum, 1).']';
        }
        if (isset($this->viewerpreferences['NumCopies'])) {
            $out .= ' /NumCopies '.intval($this->viewerpreferences['NumCopies']);
        }
        $out .= ' >>';
        return $out;
    }

    /**
     * output PDF File header (7.5.2).
     * @protected
     */
    protected function _putheader() {
        $this->_out('%PDF-'.$this->pdfversion);
        $this->_out('%'.chr(0xe2).chr(0xe3).chr(0xcf).chr(0xd3));
    }

    /**
     * output end of document (EOF).
     * @protected
     */
    protected function _enddoc() {
        $this->state = 1;
        $this->_putheader();
        $this->_putpages();
        $this->_putresources();
        // Empty signature fields.
        if (!empty($this->emptysignatureappearance)) {
            foreach ($this->emptysignatureappearance as $key => $esa) {
                // Widget annotation for empty signature.
                $out = $this->_getobj($esa['objid'])."\n";
                $out .= '<< /Type /Annot';
                $out .= ' /Subtype /Widget';
                $out .= ' /rect ['.$esa['rect'].']';
                $out .= ' /P '.$this->pageobjid[($esa['page'])].' 0 R'; // Link to signature appearance page.
                $out .= ' /F 4';
                $out .= ' /FT /Sig';
                $signame = sprintf('Signature_%03d', ($key + 1));
                $out .= ' /T '.$this->_textstring($signame, $esa['objid']);
                $out .= ' /Ff 0';
                $out .= ' >>';
                $out .= "\n".'endobj';
                $this->_out($out);
            }
        }
        // Signature.
        if ($this->sign AND isset($this->signaturedata['certtype'])) {
            // Widget annotation for signature.
            $out = $this->_getobj($this->sigobjid)."\n";
            $out .= '<< /Type /Annot';
            $out .= ' /Subtype /Widget';
            $out .= ' /rect ['.$this->signatureappearance['rect'].']';
            $out .= ' /P '.$this->pageobjid[($this->signatureappearance['page'])].' 0 R';
            // Link to signature appearance page.
            $out .= ' /F 4';
            $out .= ' /FT /Sig';
            $out .= ' /T '.$this->_textstring('Signature_000', $this->sigobjid);
            $out .= ' /Ff 0';
            $out .= ' /V '.($this->sigobjid + 1).' 0 R';
            $out .= ' >>';
            $out .= "\n".'endobj';
            $this->_out($out);
            // Signature.
            $this->_putsignature();
        }
        // Info.
        $objidinfo = $this->_putinfo();
        // Catalog.
        $objidcatalog = $this->_putcatalog();
        // Cross-ref.
        $o = $this->bufferlen;
        // XREF section.
        $this->_out('xref');
        $this->_out('0 '.($this->n + 1));
        $this->_out('0000000000 65535 f ');
        $freegen = ($this->n + 2);
        for ($i = 1; $i <= $this->n; ++$i) {
            if (!isset($this->offsets[$i]) AND ($i > 1)) {
                $this->_out(sprintf('0000000000 %05d f ', $freegen));
                ++$freegen;
            } else {
                $this->_out(sprintf('%010d 00000 n ', $this->offsets[$i]));
            }
        }
        // TRAILER.
        $out = 'trailer'."\n";
        $out .= '<<';
        $out .= ' /Size '.($this->n + 1);
        $out .= ' /Root '.$objidcatalog.' 0 R';
        $out .= ' /Info '.$objidinfo.' 0 R';
        if ($this->encrypted) {
            $out .= ' /Encrypt '.$this->encryptdata['objid'].' 0 R';
        }
        $out .= ' /ID [ <'.$this->fileid.'> <'.$this->fileid.'> ]';
        $out .= ' >>';
        $this->_out($out);
        $this->_out('startxref');
        $this->_out($o);
        $this->_out('%%EOF');
        $this->state = 3; // End-of-doc.
        if ($this->diskcache) {
            // Remove temporary files used for images.
            foreach ($this->imagekeys as $key) {
                // Remove temporary files.
                unlink($this->images[$key]);
            }
            foreach ($this->fontkeys as $key) {
                // Remove temporary files.
                unlink($this->fonts[$key]);
            }
        }
    }

    /**
     * Initialize a new page.
     * @see getpagesizefromformat(), setpageformat()
     */
    protected function _beginpage($orientation = '', $format = '') {
        ++$this->page;
        $this->pageobjects[$this->page] = array();
        $this->setpagebuffer($this->page, '');
        // Initialize array for graphics tranformation positions inside a page buffer.
        $this->transfmrk[$this->page] = array();
        $this->state = 2;
        if ($this->empty_string($orientation)) {
            if (isset($this->curcrientation)) {
                $orientation = $this->curcrientation;
            } else if ($this->fwpt > $this->fhpt) {
                // Landscape.
                $orientation = 'L';
            } else {
                // Portrait.
                $orientation = 'P';
            }
        }
        if ($this->empty_string($format)) {
            $this->pagedim[$this->page] = $this->pagedim[($this->page - 1)];
            $this->setpageorientation($orientation);
        } else {
            $this->setpageformat($format, $orientation);
        }
        if ($this->rtl) {
            $this->x = $this->w - $this->rmargin;
        } else {
            $this->x = $this->lmargin;
        }
        $this->y = $this->tmargin;
        if (isset($this->newpagegroup[$this->page])) {
            // Start a new group.
            $this->currpagegroup = $this->newpagegroup[$this->page];
            $this->pagegroups[$this->currpagegroup] = 1;
        } else if (isset($this->currpagegroup) AND ($this->currpagegroup > 0)) {
            ++$this->pagegroups[$this->currpagegroup];
        }
    }

    /**
     * Mark end of page.
     */
    protected function _endpage() {
        $this->setvisibility('all');
        $this->state = 1;
    }

    /**
     * Begin a new object and return the object number.
     */
    protected function _newobj() {
        $this->_out($this->_getobj());
        return $this->n;
    }

    /**
     * Return the starting object string for the selected object ID.
     */
    protected function _getobj($objid='') {
        if ($objid === '') {
            ++$this->n;
            $objid = $this->n;
        }
        $this->offsets[$objid] = $this->bufferlen;
        $this->pageobjects[$this->page][] = $objid;
        return $objid.' 0 obj';
    }

    /**
     * Underline text.
     * @param $x (int) X coordinate
     * @param $y (int) Y coordinate
     * @param $txt (string) text to underline
     * @protected
     */
    protected function _dounderline($x, $y, $txt) {
        $w = $this->getstringwidth($txt);
        return $this->_dounderlinew($x, $y, $w);
    }

    /**
     * Underline for rectangular text area.
     */
    protected function _dounderlinew($x, $y, $w) {
        $linew = - $this->currentfont['ut'] / 1000 * $this->fontsizept;
        return sprintf('%F %F %F %F re f', $x * $this->k, ((($this->h - $y) * $this->k) + $linew), $w * $this->k, $linew);
    }

    /**
     * line through text.
     */
    protected function _dolinethrough($x, $y, $txt) {
        $w = $this->getstringwidth($txt);
        return $this->_dolinethroughw($x, $y, $w);
    }

    /**
     * line through for rectangular text area.
     */
    protected function _dolinethroughw($x, $y, $w) {
        $linew = - $this->currentfont['ut'] / 1000 * $this->fontsizept;
        return sprintf('%F %F %F %F re f', $x * $this->k, ((($this->h - $y) * $this->k) + $linew +
                      ($this->fontsizept / 3)), $w * $this->k, $linew);
    }

    /**
     * Overline text.
     */
    protected function _dooverline($x, $y, $txt) {
        $w = $this->getstringwidth($txt);
        return $this->_dooverlinew($x, $y, $w);
    }

    /**
     * Overline for rectangular text area.
     */
    protected function _dooverlinew($x, $y, $w) {
        $linew = - $this->currentfont['ut'] / 1000 * $this->fontsizept;
        return sprintf('%F %F %F %F re f', $x * $this->k, (($this->h - $y + $this->fontascent) * $this->k) -
                       $linew, $w * $this->k, $linew);

    }

    /**
     * Read a 4-byte (32 bit) integer from file.
     */
    protected function _freadint($f) {
        $a = unpack('Ni', fread($f, 4));
        return $a['i'];
    }

    /**
     * Add "\" before "\", "(" and ")"
     */
    protected function _escape($s) {
        // The chr(13) substitution fixes the Bugs item #1421290.
        return strtr($s, array(')' => '\\)', '(' => '\\(', '\\' => '\\\\', chr(13) => '\r'));
    }

    /**
     * Format a data string for meta information
     * @protected
     */
    protected function _datastring($s, $n = 0) {
        if ($n == 0) {
            $n = $this->n;
        }
        $s = $this->_encrypt_data($n, $s);
        return '('. $this->_escape($s).')';
    }

    /**
     * Set the document creation timestamp
     */
    public function setdoccreationtimestamp($time) {
        if (is_string($time)) {
            $time = gettimestamp($time);
        }
        $this->doccreationtimestamp = intval($time);
    }

    /**
     * Set the document modification timestamp
     */
    public function setdocmodificationtimestamp($time) {
        if (is_string($time)) {
            $time = gettimestamp($time);
        }
        $this->docmodificationtimestamp = intval($time);
    }

    /**
     * Returns document creation timestamp in seconds.
     */
    public function getdoccreationtimestamp() {
        return $this->doccreationtimestamp;
    }

    /**
     * Returns document modification timestamp in seconds.
     * @return (int) Modfication timestamp in seconds.
     * @public
     */
    public function getdocmodificationtimestamp() {
        return $this->docmodificationtimestamp;
    }

    /**
     * Returns timestamp in seconds from formatted date-time.
     */
    public function gettimestamp($date) {
        if (($date[0] == 'D') AND ($date[1] == ':')) {
            // Remove date prefix if present.
            $date = substr($date, 2);
        }
        return strtotime($date);
    }

    /**
     * Returns a formatted date-time.
     */
    public function getformatteddate($time) {
        return substr_replace(date('YmdHisO', intval($time)), '\'', (0 - 2), 0).'\'';
    }

    /**
     * Returns a formatted date for meta information
     */
    protected function _datestring($n=0, $timestamp=0) {
        if ((empty($timestamp)) OR ($timestamp < 0)) {
            $timestamp = $this->doccreationtimestamp;
        }
        return $this->_datastring('D:'.$this->getformatteddate($timestamp), $n);
    }

    /**
     * Format a text string for meta information
     * @param $s (string) string to escape.
     * @param $n (int) object ID
     * @return string escaped string.
     * @protected
     */
    protected function _textstring($s, $n = 0) {
        if ($this->isunicode) {
            // Convert string to UTF-16BE.
            $s = $this->utf8toutf16be($s, true);
        }
        return $this->_datastring($s, $n);
    }

    /**
     * THIS METHOD IS DEPRECATED
     * Format a text string
     */
    protected function _escapetext($s) {
        if ($this->isunicode) {
            if (($this->currentfont['type'] == 'core') OR ($this->currentfont['type'] == 'TrueType') OR
                ($this->currentfont['type'] == 'Type1')) {
                $s = $this->utf8tolatin1($s);
            } else {
                // Convert string to UTF-16BE and reverse RTL language.
                $s = $this->utf8strrev($s, false, $this->tmprtl);
            }
        }
        return $this->_escape($s);
    }

    /**
     * Escape some special characters (&lt; &gt; &amp;) for XML output.
     */
    protected function _escapexml($str) {
        $replacetable = array("\0" => '', '&' => '&amp;', '<' => '&lt;', '>' => '&gt;');
        $str = strtr($str, $replacetable);
        return $str;
    }

    /**
     * get raw output stream.
     */
    protected function _getrawstream($s, $n=0) {
        if ($n <= 0) {
            // Default to current object.
            $n = $this->n;
        }
        return $this->_encrypt_data($n, $s);
    }

    /**
     * Format output stream (DEPRECATED).
     */
    protected function _getstream($s, $n=0) {
        return 'stream'."\n".$this->_getrawstream($s, $n)."\n".'endstream';
    }

    /**
     * output a stream (DEPRECATED).
     */
    protected function _putstream($s, $n=0) {
        $this->_out($this->_getstream($s, $n));
    }

    /**
     * output a string to the document.
     */
    protected function _out($s) {
        if ($this->state == 2) {
            if ($this->inxobj) {
                // We are inside an XObject template.
                $this->xobjects[$this->xobjid]['outdata'] .= $s."\n";
            } else if ((!$this->infooter) AND isset($this->footerlen[$this->page]) AND ($this->footerlen[$this->page] > 0)) {
                // Puts data before page footer.
                $pagebuff = $this->getpagebuffer($this->page);
                $page = substr($pagebuff, 0, -$this->footerlen[$this->page]);
                $footer = substr($pagebuff, -$this->footerlen[$this->page]);
                $this->setpagebuffer($this->page, $page.$s."\n".$footer);
                // Update footer position.
                $this->footerpos[$this->page] += strlen($s."\n");
            } else {
                $this->setpagebuffer($this->page, $s."\n", true);
            }
        } else {
            $this->setbuffer($s."\n");
        }
    }

    /**
     * Converts UTF-8 strings to codepoints array.<br>
     */
    protected function utf8stringtoarray($str) {
        // Build a unique string key.
        $strkey = md5($str);
        if (isset($this->cacheutf8stringtoarray[$strkey])) {
            // Return cached value.
            $chrarray = $this->cacheutf8stringtoarray[$strkey]['s'];
            if (!isset($this->cacheutf8stringtoarray[$strkey]['f'][$this->currentfont['fontkey']])) {
                if ($this->isunicode) {
                    foreach ($chrarray as $chr) {
                        // Store this char for font subsetting.
                        $this->currentfont['subsetchars'][$chr] = true;
                    }
                    // Update font subsetchars.
                    $this->setfontsubbuffer($this->currentfont['fontkey'], 'subsetchars',
                                            $this->currentfont['subsetchars']);
                }
                $this->cacheutf8stringtoarray[$strkey]['f'][$this->currentfont['fontkey']] = true;
            }
            return $chrarray;
        }
        // Check cache size.
        if ($this->cachesizeutf8stringtoarray >= $this->cachemaxsizeutf8stringtoarray) {
            // Remove first element.
            array_shift($this->cacheutf8stringtoarray);
        }
        // New cache array for selected string.
        $this->cacheutf8stringtoarray[$strkey] = array('s' => array(), 'f' => array());
        ++$this->cachesizeutf8stringtoarray;
        if (!$this->isunicode) {
            // Split string into array of equivalent codes.
            $strarr = array();
            $strlen = strlen($str);
            for ($i = 0; $i < $strlen; ++$i) {
                $strarr[] = ord($str[$i]);
            }
            // Insert new value on cache.
            $this->cacheutf8stringtoarray[$strkey]['s'] = $strarr;
            $this->cacheutf8stringtoarray[$strkey]['f'][$this->currentfont['fontkey']] = true;
            return $strarr;
        }
        $unichar = -1; // Last unicode char.
        $unicode = array(); // Array containing unicode values.
        $bytes  = array(); // Array containing single character byte sequences.
        $numbytes = 1; // Number of octetc needed to represent the UTF-8 character.
        $str .= ''; // Force $str to be a string.
        $length = strlen($str);
        for ($i = 0; $i < $length; ++$i) {
            $char = ord($str[$i]); // Get one string character at time.
            if (count($bytes) == 0) { // Get starting octect.
                if ($char <= 0x7F) {
                    $unichar = $char; // Use the character "as is" because is ASCII.
                    $numbytes = 1;
                } else if (($char >> 0x05) == 0x06) {
                    $bytes[] = ($char - 0xC0) << 0x06;
                    $numbytes = 2;
                } else if (($char >> 0x04) == 0x0E) {
                    $bytes[] = ($char - 0xE0) << 0x0C;
                    $numbytes = 3;
                } else if (($char >> 0x03) == 0x1E) {
                    $bytes[] = ($char - 0xF0) << 0x12;
                    $numbytes = 4;
                } else {
                    // Use replacement character for other invalid sequences.
                    $unichar = 0xFFFD;
                    $bytes = array();
                    $numbytes = 1;
                }
            } else if (($char >> 0x06) == 0x02) { // Bytes 2, 3 and 4 must start with 0x02 = 10 BIN.
                $bytes[] = $char - 0x80;
                if (count($bytes) == $numbytes) {
                    // Compose UTF-8 bytes to a single unicode value.
                    $char = $bytes[0];
                    for ($j = 1; $j < $numbytes; ++$j) {
                        $char += ($bytes[$j] << (($numbytes - $j - 1) * 0x06));
                    }
                    if ((($char >= 0xD800) AND ($char <= 0xDFFF)) OR ($char >= 0x10FFFF)) {
                        $unichar = 0xFFFD; // Use replacement character.
                    } else {
                        $unichar = $char; // Add char to array.
                    }
                    // Reset data for next char.
                    $bytes = array();
                    $numbytes = 1;
                }
            } else {
                // Use replacement character for other invalid sequences.
                $unichar = 0xFFFD;
                $bytes = array();
                $numbytes = 1;
            }
            if ($unichar >= 0) {
                // Insert unicode value into array.
                $unicode[] = $unichar;
                // Store this char for font subsetting.
                $this->currentfont['subsetchars'][$unichar] = true;
                $unichar = -1;
            }
        }
        // Update font subsetchars.
        $this->setfontsubbuffer($this->currentfont['fontkey'], 'subsetchars', $this->currentfont['subsetchars']);
        // Insert new value on cache.
        $this->cacheutf8stringtoarray[$strkey]['s'] = $unicode;
        $this->cacheutf8stringtoarray[$strkey]['f'][$this->currentfont['fontkey']] = true;
        return $unicode;
    }

    /**
     * Converts UTF-8 strings to UTF16-BE.
     * @see utf8stringtoarray(), arrutf8toutf16be()
     */
    protected function utf8toutf16be($str, $setbom=false) {
        if (!$this->isunicode) {
            return $str; // String is not in unicode.
        }
        $unicode = $this->utf8stringtoarray($str); // Array containing UTF-8 unicode values.
        return $this->arrutf8toutf16be($unicode, $setbom);
    }

    /**
     * Converts UTF-8 strings to Latin1 when using the standard 14 core fonts.
     */
    protected function utf8tolatin1($str) {
        if (!$this->isunicode) {
            return $str; // String is not in unicode.
        }
        $outstr = ''; // String to be returned.
        $unicode = $this->utf8stringtoarray($str); // Array containing UTF-8 unicode values.
        foreach ($unicode as $char) {
            if ($char < 256) {
                $outstr .= chr($char);
            } else if (array_key_exists($char, $this->unicode->uni_utf8tolatin)) {
                // Map from UTF-8.
                $outstr .= chr($this->unicode->uni_utf8tolatin[$char]);
            } else {
                $outstr .= '?';
            }
        }
        return $outstr;
    }

    /**Converts UTF-8 characters array to array of Latin1 characters<br>
     */
    protected function utf8arrtolatin1($unicode) {
        if ((!$this->isunicode) OR $this->isunicodefont()) {
            return $unicode;
        }
        $outarr = array(); // Array to be returned.
        foreach ($unicode as $char) {
            if ($char < 256) {
                $outarr[] = $char;
            } else if (array_key_exists($char, $this->unicode->uni_utf8tolatin)) {
                // Map from UTF-8.
                $outarr[] = $this->unicode->uni_utf8tolatin[$char];
            } else {
                $outarr[] = 63;
            }
        }
        return $outarr;
    }

    /**
     * Converts array of UTF-8 characters to UTF16-BE string.<br>
     * @see utf8toutf16be()
     */
    protected function arrutf8toutf16be($unicode, $setbom=false) {
        $outstr = ''; // String to be returned.
        if ($setbom) {
            $outstr .= "\xFE\xFF"; // Byte Order Mark (BOM).
        }
        foreach ($unicode as $char) {
            if ($char == 0xFFFD) {
                $outstr .= "\xFF\xFD"; // Replacement character.
            } else if ($char < 0x10000) {
                $outstr .= chr($char >> 0x08);
                $outstr .= chr($char & 0xFF);
            } else {
                $char -= 0x10000;
                $w1 = 0xD800 | ($char >> 0x0a);
                $w2 = 0xDC00 | ($char & 0x3FF);
                $outstr .= chr($w1 >> 0x08);
                $outstr .= chr($w1 & 0xFF);
                $outstr .= chr($w2 >> 0x08);
                $outstr .= chr($w2 & 0xFF);
            }
        }
        return $outstr;
    }

    /**
     * Set header font.
     */
    public function setheaderfont($font) {
        $this->headerfont = $font;
    }

    /**
     * Get header font.
     */
    public function getheaderfont() {
        return $this->headerfont;
    }

    /**
     * Set footer font.
     */
    public function setfooterfont($font) {
        $this->footerfont = $font;
    }

    /**
     * Get footer font.
     */
    public function getfooterfont() {
        return $this->footerfont;
    }

    /**
     * Set language array.
     */
    public function setlanguagearray($language) {
        $this->l = $language;
        if (isset($this->l['a_meta_dir'])) {
            $this->rtl = $this->l['a_meta_dir'] == 'rtl' ? true : false;
        } else {
            $this->rtl = false;
        }
    }

    /**
     * Returns the PDF data.
     */
    public function getpdfdata() {
        if ($this->state < 3) {
            $this->close();
        }
        return $this->buffer;
    }

    /**
     * output anchor link.
     */
    public function addhtmllink($url, $name, $fill = false, $firstline = false, $color = '', $style = -1,
                               $firstblock = false) {
        if (!$this->empty_string($url) AND ($url{0} == '#')) {
            // Convert url to internal link.
            $lnkdata = explode(',', $url);
            if (isset($lnkdata[0])) {
                $page = intval(substr($lnkdata[0], 1));
                if (empty($page) OR ($page <= 0)) {
                    $page = $this->page;
                }
                if (isset($lnkdata[1]) AND (strlen($lnkdata[1]) > 0)) {
                    $lnky = floatval($lnkdata[1]);
                } else {
                    $lnky = 0;
                }
                $url = $this->addlink();
                $this->setlink($url, $lnky, $page);
            }
        }
        // Store current settings.
        $prevcolor = $this->fgcolor;
        $prevstyle = $this->fontstyle;
        if (empty($color)) {
            $this->settextcolorarray($this->htmllinkcolorarray);
        } else {
            $this->settextcolorarray($color);
        }
        if ($style == -1) {
            $this->setfont('', $this->fontstyle.$this->htmllinkfontstyle);
        } else {
            $this->setfont('', $this->fontstyle.$style);
        }
        $ret = $this->write($this->lasth, $name, $url, $fill, '', false, 0, $firstline, $firstblock, 0);
        // Restore settings.
        $this->setfont('', $prevstyle);
        $this->settextcolorarray($prevcolor);
        return $ret;
    }

    /**
     * Returns an array (RGB or CMYK) from an html color name, or a six-digit (i.e. #3FE5AA), or three-digit
       (i.e. #7FF) hexadecimal color, or a javascript color array, or javascript color name.
     */
    public function converthtmlcolortodec($hcolor = '#FFFFFF', $defcol = array('R' => 128, 'G' => 128, 'B' => 128)) {
        $color = preg_replace('/[\s]*/', '', $hcolor); // Remove extra spaces.
        $color = strtolower($color);
        // Check for javascript color array syntax.
        if (strpos($color, '[') !== false) {
            if (preg_match('/[\[][\"\'](t|g|rgb|cmyk)[\"\'][\,]?([0-9\.]*)[\,]?([0-9\.]*)[\,]?([0-9\.]*)[\,]?([0-9\.]*)[\]]/',
                            $color, $m) > 0) {
                $returncolor = array();
                switch ($m[1]) {
                    case 'cmyk': {
                        // RGB.
                        $returncolor['C'] = max(0, min(100, (floatval($m[2]) * 100)));
                        $returncolor['M'] = max(0, min(100, (floatval($m[3]) * 100)));
                        $returncolor['Y'] = max(0, min(100, (floatval($m[4]) * 100)));
                        $returncolor['K'] = max(0, min(100, (floatval($m[5]) * 100)));
                        break;
                    }
                    case 'rgb': {
                        // RGB.
                        $returncolor['R'] = max(0, min(255, (floatval($m[2]) * 255)));
                        $returncolor['G'] = max(0, min(255, (floatval($m[3]) * 255)));
                        $returncolor['B'] = max(0, min(255, (floatval($m[4]) * 255)));
                        break;
                    }
                    case 'g': {
                        // Grayscale.
                        $returncolor['G'] = max(0, min(255, (floatval($m[2]) * 255)));
                        break;
                    }
                    case 't':
                    default: {
                        // Transparent empty array.
                        break;
                    }
                }
                return $returncolor;
            }
        } else if (($dotpos = strpos($color, '.')) !== false) {
            // Remove class parent,i.e.: color.red.
            $color = substr($color, ($dotpos + 1));
            if ($color == 'transparent') {
                // Transparent.
                return array();
            }
        }
        if (strlen($color) == 0) {
            return $defcol;
        }
        // RGB ARRAY.
        if (substr($color, 0, 3) == 'rgb') {
            $codes = substr($color, 4);
            $codes = str_replace(')', '', $codes);
            $returncolor = explode(',', $codes);
            foreach ($returncolor as $key => $val) {
                if (strpos($val, '%') > 0) {
                    // Percentage.
                    $returncolor[$key] = (255 * intval($val) / 100);
                } else {
                    $returncolor[$key] = intval($val);
                }
                // Normalize value.
                $returncolor[$key] = max(0, min(255, $returncolor[$key]));
            }
            return $returncolor;
        }
        // CMYK ARRAY.
        if (substr($color, 0, 4) == 'cmyk') {
            $codes = substr($color, 5);
            $codes = str_replace(')', '', $codes);
            $returncolor = explode(',', $codes);
            foreach ($returncolor as $key => $val) {
                if (strpos($val, '%') !== false) {
                    // Percentage.
                    $returncolor[$key] = (100 * intval($val) / 100);
                } else {
                    $returncolor[$key] = intval($val);
                }
                // Normalize value.
                $returncolor[$key] = max(0, min(100, $returncolor[$key]));
            }
            return $returncolor;
        }
        if ($color{0} != '#') {
            // COLOR NAME.
            if (isset($this->webcolor[$color])) {
                // Web color.
                $colorcode = $this->webcolor[$color];
            } else {
                // Spot color.
                $returncolor = $this->getspotcolor($color);
                if ($returncolor === false) {
                    $returncolor = $defcol;
                }
                return $returncolor;
            }
        } else {
            $colorcode = substr($color, 1);
        }
        // HEXADECIMAL REPRESENTATION.
        switch (strlen($colorcode)) {
            case 3: {
                // Three-digit RGB hexadecimal representation.
                $r = substr($colorcode, 0, 1);
                $g = substr($colorcode, 1, 1);
                $b = substr($colorcode, 2, 1);
                $returncolor = array();
                $returncolor['R'] = max(0, min(255, hexdec($r.$r)));
                $returncolor['G'] = max(0, min(255, hexdec($g.$g)));
                $returncolor['B'] = max(0, min(255, hexdec($b.$b)));
                break;
            }
            case 6: {
                // Six-digit RGB hexadecimal representation.
                $returncolor = array();
                $returncolor['R'] = max(0, min(255, hexdec(substr($colorcode, 0, 2))));
                $returncolor['G'] = max(0, min(255, hexdec(substr($colorcode, 2, 2))));
                $returncolor['B'] = max(0, min(255, hexdec(substr($colorcode, 4, 2))));
                break;
            }
            case 8: {
                // Eight-digit CMYK hexadecimal representation.
                $returncolor = array();
                $returncolor['C'] = max(0, min(100, round(hexdec(substr($colorcode, 0, 2)) / 2.55)));
                $returncolor['M'] = max(0, min(100, round(hexdec(substr($colorcode, 2, 2)) / 2.55)));
                $returncolor['Y'] = max(0, min(100, round(hexdec(substr($colorcode, 4, 2)) / 2.55)));
                $returncolor['K'] = max(0, min(100, round(hexdec(substr($colorcode, 6, 2)) / 2.55)));
                break;
            }
            default: {
                $returncolor = $defcol;
                break;
            }
        }
        return $returncolor;
    }

    /**
     * Converts pixels to User's Units.
     * @see setimagescale(), getimagescale()
     */
    public function pixelstounits($px) {
        return ($px / ($this->imgscale * $this->k));
    }

    /**
     * Reverse function for htmlentities.
     * Convert entities in UTF-8.
     */
    public function unhtmlentities($texttoconvert) {
        return @html_entity_decode($texttoconvert, ENT_QUOTES, $this->encoding);
    }

    /**
     * Returns a string containing random data to be used as a seed for encryption methods.
     */
    protected function getrandomseed($seed='') {
        $seed .= microtime();
        if (function_exists('openssl_random_pseudo_bytes') AND (strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN')) {
            // This is not used on windows systems because it is very slow for a know bug.
            $seed .= openssl_random_pseudo_bytes(512);
        } else {
            for ($i = 0; $i < 23; ++$i) {
                $seed .= uniqid('', true);
            }
        }
        $seed .= uniqid('', true);
        $seed .= rand();
        $seed .= getmypid();
        $seed .= __FILE__;
        $seed .= $this->bufferlen;
        if (isset($_SERVER['REMOTE_ADDR'])) {
            $seed .= $_SERVER['REMOTE_ADDR'];
        }
        if (isset($_SERVER['HTTP_USER_AGENT'])) {
            $seed .= $_SERVER['HTTP_USER_AGENT'];
        }
        if (isset($_SERVER['HTTP_ACCEPT'])) {
            $seed .= $_SERVER['HTTP_ACCEPT'];
        }
        if (isset($_SERVER['HTTP_ACCEPT_ENCODING'])) {
            $seed .= $_SERVER['HTTP_ACCEPT_ENCODING'];
        }
        if (isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
            $seed .= $_SERVER['HTTP_ACCEPT_LANGUAGE'];
        }
        if (isset($_SERVER['HTTP_ACCEPT_CHARSET'])) {
            $seed .= $_SERVER['HTTP_ACCEPT_CHARSET'];
        }
        $seed .= rand();
        $seed .= uniqid('', true);
        $seed .= microtime();
        return $seed;
    }

    /**
     * Compute encryption key depending on object number where the encrypted data is stored.
     * This is used for all strings and streams without crypt filter specifier.
     */
    protected function _objectkey($n) {
        $objkey = $this->encryptdata['key'].pack('VXxx', $n);
        if ($this->encryptdata['mode'] == 2) { // AES-128.
            // aes padding.
            $objkey .= "\x73\x41\x6C\x54"; // Salt.
        }
        $objkey = substr($this->_md5_16($objkey), 0, (($this->encryptdata['Length'] / 8) + 5));
        $objkey = substr($objkey, 0, 16);
        return $objkey;
    }

    /**
     * Encrypt the input string.
     */
    protected function _encrypt_data($n, $s) {
        if (!$this->encrypted) {
            return $s;
        }
        switch ($this->encryptdata['mode']) {
            case 0:   // RC4-40.
            case 1: { // RC4-128.
                $s = $this->_rc4($this->_objectkey($n), $s);
                break;
            }
            case 2: { // AES-128.
                $s = $this->_aes($this->_objectkey($n), $s);
                break;
            }
            case 3: { // AES-256.
                $s = $this->_aes($this->encryptdata['key'], $s);
                break;
            }
        }
        return $s;
    }

    /**
     * Put encryption on PDF document.
     */
    protected function _putencryption() {
        if (!$this->encrypted) {
            return;
        }
        $this->encryptdata['objid'] = $this->_newobj();
        $out = '<<';
        if (!isset($this->encryptdata['Filter']) OR empty($this->encryptdata['Filter'])) {
            $this->encryptdata['Filter'] = 'Standard';
        }
        $out .= ' /Filter /'.$this->encryptdata['Filter'];
        if (isset($this->encryptdata['SubFilter']) AND !empty($this->encryptdata['SubFilter'])) {
            $out .= ' /SubFilter /'.$this->encryptdata['SubFilter'];
        }
        if (!isset($this->encryptdata['V']) OR empty($this->encryptdata['V'])) {
            $this->encryptdata['V'] = 1;
        }
        // V is a code specifying the algorithm to be used in encrypting and decrypting the document.
        $out .= ' /V '.$this->encryptdata['V'];
        if (isset($this->encryptdata['Length']) AND !empty($this->encryptdata['Length'])) {
            // The length of the encryption key, in bits. The value shall be a multiple of 8, in the range 40 to 256.
            $out .= ' /Length '.$this->encryptdata['Length'];
        } else {
            $out .= ' /Length 40';
        }
        if ($this->encryptdata['V'] >= 4) {
            if (!isset($this->encryptdata['StmF']) OR empty($this->encryptdata['StmF'])) {
                $this->encryptdata['StmF'] = 'Identity';
            }
            if (!isset($this->encryptdata['StrF']) OR empty($this->encryptdata['StrF'])) {
                // The name of the crypt filter that shall be used when decrypting all strings in the document.
                $this->encryptdata['StrF'] = 'Identity';
            }
            // A dictionary whose keys shall be crypt filter names and whose values shall be the corresponding
            // crypt filter dictionaries.
            if (isset($this->encryptdata['CF']) AND !empty($this->encryptdata['CF'])) {
                $out .= ' /CF <<';
                $out .= ' /'.$this->encryptdata['StmF'].' <<';
                $out .= ' /Type /CryptFilter';
                if (isset($this->encryptdata['CF']['CFM']) AND !empty($this->encryptdata['CF']['CFM'])) {
                    // The method used.
                    $out .= ' /CFM /'.$this->encryptdata['CF']['CFM'];
                    if ($this->encryptdata['pubkey']) {
                        $out .= ' /Recipients [';
                        foreach ($this->encryptdata['Recipients'] as $rec) {
                            $out .= ' <'.$rec.'>';
                        }
                        $out .= ' ]';
                        if (isset($this->encryptdata['CF']['EncryptMetadata']) AND
                                 (!$this->encryptdata['CF']['EncryptMetadata'])) {
                            $out .= ' /EncryptMetadata false';
                        } else {
                            $out .= ' /EncryptMetadata true';
                        }
                    }
                } else {
                    $out .= ' /CFM /None';
                }
                if (isset($this->encryptdata['CF']['AuthEvent']) AND !empty($this->encryptdata['CF']['AuthEvent'])) {
                    // The event to be used to trigger the authorization that is required to access encryption keys
                    // used by this filter.
                    $out .= ' /AuthEvent /'.$this->encryptdata['CF']['AuthEvent'];
                } else {
                    $out .= ' /AuthEvent /DocOpen';
                }
                if (isset($this->encryptdata['CF']['Length']) AND !empty($this->encryptdata['CF']['Length'])) {
                    // The bit length of the encryption key.
                    $out .= ' /Length '.$this->encryptdata['CF']['Length'];
                }
                $out .= ' >> >>';
            }
            // The name of the crypt filter that shall be used by default when decrypting streams.
            $out .= ' /StmF /'.$this->encryptdata['StmF'];
            // The name of the crypt filter that shall be used when decrypting all strings in the document.
            $out .= ' /StrF /'.$this->encryptdata['StrF'];
            if (isset($this->encryptdata['EFF']) AND !empty($this->encryptdata['EFF'])) {
                // The name of the crypt filter that shall be used when encrypting embedded file streams that
                // do not have their own crypt filter specifier.
                $out .= ' /EFF /'.$this->encryptdata[''];
            }
        }
        // Additional encryption dictionary entries for the standard security handler.
        if ($this->encryptdata['pubkey']) {
            if (($this->encryptdata['V'] < 4) AND isset($this->encryptdata['Recipients']) AND
                !empty($this->encryptdata['Recipients'])) {
                $out .= ' /Recipients [';
                foreach ($this->encryptdata['Recipients'] as $rec) {
                    $out .= ' <'.$rec.'>';
                }
                $out .= ' ]';
            }
        } else {
            $out .= ' /R';
            if ($this->encryptdata['V'] == 5) { // AES-256.
                $out .= ' 5';
                $out .= ' /OE ('.$this->_escape($this->encryptdata['OE']).')';
                $out .= ' /UE ('.$this->_escape($this->encryptdata['UE']).')';
                $out .= ' /Perms ('.$this->_escape($this->encryptdata['perms']).')';
            } else if ($this->encryptdata['V'] == 4) { // AES-128.
                $out .= ' 4';
            } else if ($this->encryptdata['V'] < 2) { // RC-40.
                $out .= ' 2';
            } else { // RC-128.
                $out .= ' 3';
            }
            $out .= ' /O ('.$this->_escape($this->encryptdata['O']).')';
            $out .= ' /U ('.$this->_escape($this->encryptdata['U']).')';
            $out .= ' /P '.$this->encryptdata['P'];
            if (isset($this->encryptdata['EncryptMetadata']) AND (!$this->encryptdata['EncryptMetadata'])) {
                $out .= ' /EncryptMetadata false';
            } else {
                $out .= ' /EncryptMetadata true';
            }
        }
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
    }

    /**
     * Returns the input text encrypted using rc4 algorithm and the specified key.
     * rc4 is the standard encryption algorithm used in PDF format
     */
    protected function _rc4($key, $text) {
        if ($this->lastenckey != $key) {
            $k = str_repeat($key, ((256 / strlen($key)) + 1));
            $rc4 = range(0, 255);
            $j = 0;
            for ($i = 0; $i < 256; ++$i) {
                $t = $rc4[$i];
                $j = ($j + $t + ord($k[$i])) % 256;
                $rc4[$i] = $rc4[$j];
                $rc4[$j] = $t;
            }
            $this->lastenckey = $key;
            $this->lastenckeyc = $rc4;
        } else {
            $rc4 = $this->lastenckeyc;
        }
        $len = strlen($text);
        $a = 0;
        $b = 0;
        $out = '';
        for ($i = 0; $i < $len; ++$i) {
            $a = ($a + 1) % 256;
            $t = $rc4[$a];
            $b = ($b + $t) % 256;
            $rc4[$a] = $rc4[$b];
            $rc4[$b] = $t;
            $k = $rc4[($rc4[$a] + $rc4[$b]) % 256];
            $out .= chr(ord($text[$i]) ^ $k);
        }
        return $out;
    }

    /**
     * Encrypts a string using MD5 and returns it's value as a binary string.
     */
    protected function _md5_16($str) {
        return pack('H*', md5($str));
    }

    /**
     * Compute U value (used for encryption)
     */
    protected function _uvalue() {
        if ($this->encryptdata['mode'] == 0) {
            return $this->_rc4($this->encryptdata['key'], $this->encpadding);
        } else if ($this->encryptdata['mode'] < 3) {
            $tmp = $this->_md5_16($this->encpadding.$this->encryptdata['fileid']);
            $enc = $this->_rc4($this->encryptdata['key'], $tmp);
            $len = strlen($tmp);
            for ($i = 1; $i <= 19; ++$i) {
                $ek = '';
                for ($j = 0; $j < $len; ++$j) {
                    $ek .= chr(ord($this->encryptdata['key'][$j]) ^ $i);
                }
                $enc = $this->_rc4($ek, $enc);
            }
            $enc .= str_repeat("\x00", 16);
            return substr($enc, 0, 32);
        } else if ($this->encryptdata['mode'] == 3) {
            $seed = $this->_md5_16($this->getrandomseed());
            // User Validation Salt.
            $this->encryptdata['UVS'] = substr($seed, 0, 8);
            // User Key Salt.
            $this->encryptdata['UKS'] = substr($seed, 8, 16);
            return hash('sha256', $this->encryptdata['userpassword'].$this->encryptdata['UVS'], true).
                        $this->encryptdata['UVS'].$this->encryptdata['UKS'];
        }
    }

    /**
     * Compute UE value (used for encryption)
     */
    protected function _uevalue() {
        $hashkey = hash('sha256', $this->encryptdata['userpassword'].$this->encryptdata['UKS'], true);
    }

    /**
     * Compute O value (used for encryption)
     */
    protected function _ovalue() {
        if ($this->encryptdata['mode'] < 3) {
            $tmp = $this->_md5_16($this->encryptdata['ownerpassword']);
            if ($this->encryptdata['mode'] > 0) {
                for ($i = 0; $i < 50; ++$i) {
                    $tmp = $this->_md5_16($tmp);
                }
            }
            $ownerkey = substr($tmp, 0, ($this->encryptdata['Length'] / 8));
            $enc = $this->_rc4($ownerkey, $this->encryptdata['userpassword']);
            if ($this->encryptdata['mode'] > 0) {
                $len = strlen($ownerkey);
                for ($i = 1; $i <= 19; ++$i) {
                    $ek = '';
                    for ($j = 0; $j < $len; ++$j) {
                        $ek .= chr(ord($ownerkey[$j]) ^ $i);
                    }
                    $enc = $this->_rc4($ek, $enc);
                }
            }
            return $enc;
        } else if ($this->encryptdata['mode'] == 3) { // AES-256.
            $seed = $this->_md5_16($this->getrandomseed());
            // Owner Validation Salt.
            $this->encryptdata['OVS'] = substr($seed, 0, 8);
            // Owner Key Salt.
            $this->encryptdata['OKS'] = substr($seed, 8, 16);
            return hash('sha256', $this->encryptdata['ownerpassword'].$this->encryptdata['OVS'].
                        $this->encryptdata['U'], true).$this->encryptdata['OVS'].$this->encryptdata['OKS'];
        }
    }

    /**
     * Compute OE value (used for encryption)
     */
    protected function _oevalue() {
        $hashkey = hash('sha256', $this->encryptdata['ownerpassword'].$this->encryptdata['OKS'].$this->encryptdata['U'], true);
    }

    /**
     * Convert password for aes-256 encryption mode
     */
    protected function _fixaes256password($password) {
        $psw = ''; // Password to be returned.
        $pswarray = $this->utf8bidi($this->utf8stringtoarray($password), $password, $this->rtl);
        foreach ($pswarray as $c) {
            $psw .= $this->unichr($c);
        }
        return substr($psw, 0, 127);
    }

    /**
     * Compute encryption key
     */
    protected function _generateencryptionkey() {
        $keybytelen = ($this->encryptdata['Length'] / 8);
        if (!$this->encryptdata['pubkey']) { // Standard mode.
            if ($this->encryptdata['mode'] == 3) { // AES-256.
                // Generate 256 bit random key.
                $this->encryptdata['key'] = substr(hash('sha256', $this->getrandomseed(), true), 0, $keybytelen);
                // Truncate passwords.
                $this->encryptdata['userpassword'] = $this->_fixaes256password($this->encryptdata['userpassword']);
                $this->encryptdata['ownerpassword'] = $this->_fixaes256password($this->encryptdata['ownerpassword']);
                // Compute U value.
                $this->encryptdata['U'] = $this->_uvalue();
                // Compute UE value.
                $this->encryptdata['UE'] = $this->_uevalue();
                // Compute O value.
                $this->encryptdata['O'] = $this->_ovalue();
                // Compute OE value.
                $this->encryptdata['OE'] = $this->_oevalue();
                // Compute P value.
                $this->encryptdata['P'] = $this->encryptdata['protection'];
                // Computing the encryption dictionary's Perms (permissions) value.
                $perms = $this->getencpermissionsstring($this->encryptdata['protection']);
                $perms .= chr(255).chr(255).chr(255).chr(255);
                if (isset($this->encryptdata['CF']['EncryptMetadata']) AND (!$this->encryptdata['CF']['EncryptMetadata'])) {
                    $perms .= 'F';
                } else {
                    $perms .= 'T';
                }
                $perms .= 'adb';
                $perms .= 'nick';
            } else {
                // Pad passwords.
                $this->encryptdata['userpassword'] = substr($this->encryptdata['userpassword'].$this->encpadding, 0, 32);
                $this->encryptdata['ownerpassword'] = substr($this->encryptdata['ownerpassword'].$this->encpadding, 0, 32);
                // Compute O value.
                $this->encryptdata['O'] = $this->_ovalue();
                // Get default permissions reverse byte order.
                $permissions = $this->getencpermissionsstring($this->encryptdata['protection']);
                // Compute encryption key.
                $tmp = $this->_md5_16($this->encryptdata['userpassword'].$this->encryptdata['O'].$permissions.
                       $this->encryptdata['fileid']);
                if ($this->encryptdata['mode'] > 0) {
                    for ($i = 0; $i < 50; ++$i) {
                        $tmp = $this->_md5_16(substr($tmp, 0, $keybytelen));
                    }
                }
                $this->encryptdata['key'] = substr($tmp, 0, $keybytelen);
                // Compute U value.
                $this->encryptdata['U'] = $this->_uvalue();
                // Compute P value.
                $this->encryptdata['P'] = $this->encryptdata['protection'];
            }
        } else { // Public-Key mode.
            // Random 20-byte seed.
            $seed = sha1($this->getrandomseed(), true);
            $recipientbytes = '';
            foreach ($this->encryptdata['pubkeys'] as $pubkey) {
                // For each public certificate.
                if (isset($pubkey['p'])) {
                    $pkprotection = $this->getuserpermissioncode($pubkey['p'], $this->encryptdata['mode']);
                } else {
                    $pkprotection = $this->encryptdata['protection'];
                }
                // Get default permissions reverse byte order.
                $pkpermissions = $this->getencpermissionsstring($pkprotection);
                // Envelope data.
                $envelope = $seed.$pkpermissions;
                // Write the envelope data to a temporary file.
                $tempkeyfile = tempnam(K_PATH_CACHE, 'tmpkey_');
                $f = fopen($tempkeyfile, 'wb');
                if (!$f) {
                    $this->errord('Unable to create temporary key file: '.$tempkeyfile);
                }
                $envelopelength = strlen($envelope);
                fwrite($f, $envelope, $envelopelength);
                fclose($f);
                $tempencfile = tempnam(K_PATH_CACHE, 'tmpenc_');
                if (!openssl_pkcs7_encrypt($tempkeyfile, $tempencfile, $pubkey['c'], array(),
                    PKCS7_BINARY | PKCS7_DETACHED)) {
                    $this->errord('Unable to encrypt the file: '.$tempkeyfile);
                }
                unlink($tempkeyfile);
                // Read encryption signature.
                $signature = file_get_contents($tempencfile, false, null, $envelopelength);
                unlink($tempencfile);
                // Extract signature.
                $signature = substr($signature, strpos($signature, 'Content-Disposition'));
                $tmparr = explode("\n\n", $signature);
                $signature = trim($tmparr[1]);
                unset($tmparr);
                // Decode signature.
                $signature = base64_decode($signature);
                // Convert signature to hex.
                $hexsignature = current(unpack('H*', $signature));
                // Store signature on recipients array.
                $this->encryptdata['Recipients'][] = $hexsignature;
                // The bytes of each item in the Recipients array of PKCS#7 objects in the order in which they
                // appear in the array.
                $recipientbytes .= $signature;
            }
            // Calculate encryption key.
            if ($this->encryptdata['mode'] == 3) {
                $this->encryptdata['key'] = substr(hash('sha256', $seed.$recipientbytes, true), 0, $keybytelen);
            } else {
                $this->encryptdata['key'] = substr(sha1($seed.$recipientbytes, true), 0, $keybytelen);
            }
        }
    }

    /**
     * Return the premission code used on encryption (P value).
     */
    protected function getuserpermissioncode($permissions, $mode=0) {
        $options = array(
            'owner' => 2, // Bit 2 -- inverted logic: cleared by default.
            'print' => 4, // Bit 3.
            'modify' => 8, // Bit 4.
            'copy' => 16, // Bit 5.
            'annot-forms' => 32, // Bit 6.
            'fill-forms' => 256, // Bit 9.
            'extract' => 512, // Bit 10.
            'assemble' => 1024, // Bit 11.
            'print-high' => 2048 // Bit 12.
            );
        $protection = 2147422012;
        foreach ($permissions as $permission) {
            if (!isset($options[$permission])) {
                $this->errord('Incorrect permission: '.$permission);
            }
            if (($mode > 0) OR ($options[$permission] <= 32)) {
                // Set only valid permissions.
                if ($options[$permission] == 2) {
                    // The logic for bit 2 is inverted (cleared by default).
                    $protection += $options[$permission];
                } else {
                    $protection -= $options[$permission];
                }
            }
        }
        return $protection;
    }

    /**
     * Set document protection
     * Remark: the protection against modification is for people who have the full Acrobat product.
     * If you don't set any password, the document will open as usual. If you set a user password,
       the PDF viewer will ask for it before displaying the document. The master password, if different
       from the user one, can be used to get full access.
     * Note: protecting a document requires to encrypt it, which increases the processing time a lot.
       This can cause a PHP time-out in some cases, especially if the document contains images or fonts.
     */
    public function setprotection($permissions=array('print', 'modify', 'copy', 'annot-forms', 'fill-forms', 'extract',
                                  'assemble', 'print-high'), $userpass='', $ownerpass=null, $mode=0, $pubkeys=null) {
        if ($this->pdfamode) {
            // Encryption is not allowed in PDF/A mode.
            return;
        }
        $this->encryptdata['protection'] = $this->getuserpermissioncode($permissions, $mode);
        if (($pubkeys !== null) AND (is_array($pubkeys))) {
            // Public-key mode.
            $this->encryptdata['pubkeys'] = $pubkeys;
            if ($mode == 0) {
                // Public-Key Security requires at least 128 bit.
                $mode = 1;
            }
            if (!function_exists('openssl_pkcs7_encrypt')) {
                $this->errord('Public-Key Security requires openssl library.');
            }
            // Set Public-Key filter (availabe are: Entrust.PPKEF, Adobe.PPKLite, Adobe.PubSec).
            $this->encryptdata['pubkey'] = true;
            $this->encryptdata['Filter'] = 'Adobe.PubSec';
            $this->encryptdata['StmF'] = 'DefaultCryptFilter';
            $this->encryptdata['StrF'] = 'DefaultCryptFilter';
        } else {
            // Standard mode (password mode).
            $this->encryptdata['pubkey'] = false;
            $this->encryptdata['Filter'] = 'Standard';
            $this->encryptdata['StmF'] = 'StdCF';
            $this->encryptdata['StrF'] = 'StdCF';
        }
        if ($mode > 1) { // AES.
            if (!extension_loaded('mcrypt')) {
                $this->errord('aes encryption requires mcrypt library
                             (http://www.php.net/manual/en/mcrypt.requirements.php).');
            }
            if (($mode == 3) AND !function_exists('hash')) {
                // The Hash extension requires no external libraries and is enabled by default as of PHP 5.1.2.
                $this->errord('aes 256 encryption requires HASH Message Digest Framework
                              (http://www.php.net/manual/en/book.hash.php).');
            }
        }
        if ($ownerpass === null) {
            $ownerpass = md5($this->getrandomseed());
        }
        $this->encryptdata['userpassword'] = $userpass;
        $this->encryptdata['ownerpassword'] = $ownerpass;
        $this->encryptdata['mode'] = $mode;
        switch ($mode) {
            case 0: { // Rc4 40 bit.
                $this->encryptdata['V'] = 1;
                $this->encryptdata['Length'] = 40;
                $this->encryptdata['CF']['CFM'] = 'V2';
                break;
            }
            case 1: { // Rc4 128 bit.
                $this->encryptdata['V'] = 2;
                $this->encryptdata['Length'] = 128;
                $this->encryptdata['CF']['CFM'] = 'V2';
                if ($this->encryptdata['pubkey']) {
                    $this->encryptdata['SubFilter'] = 'adbe.pkcs7.s4';
                    $this->encryptdata['Recipients'] = array();
                }
                break;
            }
            case 2: { // AES 128 bit.
                $this->encryptdata['V'] = 4;
                $this->encryptdata['Length'] = 128;
                $this->encryptdata['CF']['CFM'] = 'aesV2';
                $this->encryptdata['CF']['Length'] = 128;
                if ($this->encryptdata['pubkey']) {
                    $this->encryptdata['SubFilter'] = 'adbe.pkcs7.s5';
                    $this->encryptdata['Recipients'] = array();
                }
                break;
            }
            case 3: { // AES 256 bit.
                $this->encryptdata['V'] = 5;
                $this->encryptdata['Length'] = 256;
                $this->encryptdata['CF']['CFM'] = 'aesV3';
                $this->encryptdata['CF']['Length'] = 256;
                if ($this->encryptdata['pubkey']) {
                    $this->encryptdata['SubFilter'] = 'adbe.pkcs7.s5';
                    $this->encryptdata['Recipients'] = array();
                }
                break;
            }
        }
        $this->encrypted = true;
        $this->encryptdata['fileid'] = $this->converthexstringtostring($this->fileid);
        $this->_generateencryptionkey();
    }

    /**
     * Convert hexadecimal string to string
     */
    protected function converthexstringtostring($bs) {
        $string = ''; // String to be returned.
        $bslength = strlen($bs);
        if (($bslength % 2) != 0) {
            // Padding.
            $bs .= '0';
            ++$bslength;
        }
        for ($i = 0; $i < $bslength; $i += 2) {
            $string .= chr(hexdec($bs[$i].$bs[($i + 1)]));
        }
        return $string;
    }

    /**
     * Convert string to hexadecimal string (byte string)
     */
    protected function convertstringtohexstring($s) {
        $bs = '';
        $chars = preg_split('//', $s, -1, PREG_SPLIT_NO_EMPTY);
        foreach ($chars as $c) {
            $bs .= sprintf('%02s', dechex(ord($c)));
        }
        return $bs;
    }

    /**
     * Convert encryption P value to a string of bytes, low-order byte first.
     */
    protected function getencpermissionsstring($protection) {
        $binprot = sprintf('%032b', $protection);
        $str = chr(bindec(substr($binprot, 24, 8)));
        $str .= chr(bindec(substr($binprot, 16, 8)));
        $str .= chr(bindec(substr($binprot, 8, 8)));
        $str .= chr(bindec(substr($binprot, 0, 8)));
        return $str;
    }

    // END OF ENCRYPTION FUNCTIONS.

    // START TRANSFORMATIONS SECTION.

    /**
     * Starts a 2D tranformation saving current graphic state.
     * This function must be called before scaling, mirroring, translation, rotation and skewing.
     * Use starttransform() before, and stoptransform() after the transformations to restore the normal behavior.
     */
    public function starttransform() {
        $this->_out('q');
        if ($this->inxobj) {
            // We are inside an XObject template.
            $this->xobjects[$this->xobjid]['transfmrk'][] = strlen($this->xobjects[$this->xobjid]['outdata']);
        } else {
            $this->transfmrk[$this->page][] = $this->pagelen[$this->page];
        }
        ++$this->transfmatrixkey;
        $this->transfmatrix[$this->transfmatrixkey] = array();
    }

    /**
     * Stops a 2D tranformation restoring previous graphic state.
     * This function must be called after scaling, mirroring, translation, rotation and skewing.
     * Use starttransform() before, and stoptransform() after the transformations to restore the normal behavior.
     * @see starttransform(), stoptransform()
     */
    public function stoptransform() {
        $this->_out('Q');
        if (isset($this->transfmatrix[$this->transfmatrixkey])) {
            array_pop($this->transfmatrix[$this->transfmatrixkey]);
            --$this->transfmatrixkey;
        }
        if ($this->inxobj) {
            // We are inside an XObject template.
            array_pop($this->xobjects[$this->xobjid]['transfmrk']);
        } else {
            array_pop($this->transfmrk[$this->page]);
        }
    }
    /**
     * Horizontal Scaling.
     * @see starttransform(), stoptransform()
     */
    public function scalex($sx, $x = '', $y = '') {
        $this->scale($sx, 100, $x, $y);
    }

    /**
     * Vertical Scaling.
     * @see starttransform(), stoptransform()
     */
    public function scaley($sy, $x = '', $y = '') {
        $this->scale(100, $sy, $x, $y);
    }

    /**
     * Vertical and horizontal proportional Scaling.
     * @see starttransform(), stoptransform()
     */
    public function scalexy($s, $x='', $y='') {
        $this->scale($s, $s, $x, $y);
    }

    /**
     * Vertical and horizontal non-proportional Scaling.
     * @see starttransform(), stoptransform()
     */
    public function scale($sx, $sy, $x = '', $y = '') {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        if (($sx == 0) OR ($sy == 0)) {
            $this->errord('Please do not use values equal to zero for scaling');
        }
        $y = ($this->h - $y) * $this->k;
        $x *= $this->k;
        // Calculate elements of transformation matrix.
        $sx /= 100;
        $sy /= 100;
        $tm = array();
        $tm[0] = $sx;
        $tm[1] = 0;
        $tm[2] = 0;
        $tm[3] = $sy;
        $tm[4] = $x * (1 - $sx);
        $tm[5] = $y * (1 - $sy);
        // Scale the coordinate system.
        $this->transform($tm);
    }

    /**
     * Horizontal Mirroring.
     * @see starttransform(), stoptransform()
     */
    public function mirrorh($x='') {
        $this->scale(-100, 100, $x);
    }

    /**
     * Verical Mirroring.
     * @see starttransform(), stoptransform()
     */
    public function mirrorv($y='') {
        $this->scale(100, -100, '', $y);
    }

    /**
     * Point reflection mirroring.
     * @see starttransform(), stoptransform()
     */
    public function mirrorp($x = '', $y = '') {
        $this->scale(-100, -100, $x, $y);
    }

    /**
     * Reflection against a straight line through point (x, y) with the gradient angle (angle).
     * @see starttransform(), stoptransform()
     */
    public function mirrorl($angle = 0, $x = '', $y = '') {
        $this->scale(-100, 100, $x, $y);
        $this->rotate(-2 * ($angle - 90), $x, $y);
    }

    /**
     * translate graphic object horizontally.
     * @see starttransform(), stoptransform()
     */
    public function translatex($tx) {
        $this->translate($tx, 0);
    }

    /**
     * translate graphic object vertically.
     * @see starttransform(), stoptransform()
     */
    public function translatey($ty) {
        $this->translate(0, $ty);
    }

    /**
     * translate graphic object horizontally and vertically.
     * @see starttransform(), stoptransform()
     */
    public function translate($tx, $ty) {
        // Calculate elements of transformation matrix.
        $tm = array();
        $tm[0] = 1;
        $tm[1] = 0;
        $tm[2] = 0;
        $tm[3] = 1;
        $tm[4] = $tx * $this->k;
        $tm[5] = -$ty * $this->k;
        // Translate the coordinate system.
        $this->transform($tm);
    }

    /**
     * rotate object.
     * @see starttransform(), stoptransform()
     */
    public function rotate($angle, $x='', $y='') {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        $y = ($this->h - $y) * $this->k;
        $x *= $this->k;
        // Calculate elements of transformation matrix.
        $tm = array();
        $tm[0] = cos(deg2rad($angle));
        $tm[1] = sin(deg2rad($angle));
        $tm[2] = -$tm[1];
        $tm[3] = $tm[0];
        $tm[4] = $x + ($tm[1] * $y) - ($tm[0] * $x);
        $tm[5] = $y - ($tm[0] * $y) - ($tm[1] * $x);
        // Rotate the coordinate system around ($x,$y).
        $this->transform($tm);
    }

    /**
     * skew horizontally.
     * @see starttransform(), stoptransform()
     */
    public function skewx($anglex, $x='', $y='') {
        $this->skew($anglex, 0, $x, $y);
    }

    /**
     * skew vertically.
     * @see starttransform(), stoptransform()
     */
    public function skewy($angley, $x='', $y='') {
        $this->skew(0, $angley, $x, $y);
    }

    /**
     * skew.
     * @see starttransform(), stoptransform()
     */
    public function skew($anglex, $angley, $x = '', $y = '') {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        if (($anglex <= -90) OR ($anglex >= 90) OR ($angley <= -90) OR ($angley >= 90)) {
            $this->errord('Please use values between -90 and +90 degrees for skewing.');
        }
        $x *= $this->k;
        $y = ($this->h - $y) * $this->k;
        // Calculate elements of transformation matrix.
        $tm = array();
        $tm[0] = 1;
        $tm[1] = tan(deg2rad($angley));
        $tm[2] = tan(deg2rad($anglex));
        $tm[3] = 1;
        $tm[4] = -$tm[2] * $y;
        $tm[5] = -$tm[1] * $x;
        // Skew the coordinate system.
        $this->transform($tm);
    }

    /**
     * Apply graphic transformations.
     * @see starttransform(), stoptransform()
     */
    protected function transform($tm) {
        $this->_out(sprintf('%F %F %F %F %F %F cm', $tm[0], $tm[1], $tm[2], $tm[3], $tm[4], $tm[5]));
        // Add tranformation matrix.
        $this->transfmatrix[$this->transfmatrixkey][] = array('a' => $tm[0], 'b' => $tm[1], 'c' => $tm[2],
                            'd' => $tm[3], 'e' => $tm[4], 'f' => $tm[5]);
        // Update transformation mark.
        if ($this->inxobj) {
            // We are inside an XObject template.
            if (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {
                $key = key($this->xobjects[$this->xobjid]['transfmrk']);
                $this->xobjects[$this->xobjid]['transfmrk'][$key] = strlen($this->xobjects[$this->xobjid]['outdata']);
            }
        } else if (end($this->transfmrk[$this->page]) !== false) {
            $key = key($this->transfmrk[$this->page]);
            $this->transfmrk[$this->page][$key] = $this->pagelen[$this->page];
        }
    }

    // END TRANSFORMATIONS SECTION.

    // START GRAPHIC FUNCTIONS SECTION.
    // The following section is based on the code provided by David Hernandez Sanz.

    /**
     * Defines the line width. By default, the value equals 0.2 mm. The method can be called before the first page
       is created and the value is retained from page to page.
     * @see line(), rect(), cell(), multicell()
     */
    public function setlinewidth($width) {
        // Set line width.
        $this->linewidth = $width;
        $this->linestylewidth = sprintf('%F w', ($width * $this->k));
        if ($this->page > 0) {
            $this->_out($this->linestylewidth);
        }
    }

    /**
     * Returns the current the line width.
     * @see line(), setlinewidth()
     */
    public function getlinewidth() {
        return $this->linewidth;
    }

    /**
     * Set line style.
     */
    public function setlinestyle($style, $ret = false) {
        $s = ''; // String to be returned.
        if (!is_array($style)) {
            return;
        }
        if (isset($style['width'])) {
            $this->linewidth = $style['width'];
            $this->linestylewidth = sprintf('%F w', ($style['width'] * $this->k));
            $s .= $this->linestylewidth.' ';
        }
        if (isset($style['cap'])) {
            $ca = array('butt' => 0, 'round' => 1, 'square' => 2);
            if (isset($ca[$style['cap']])) {
                $this->linestylecap = $ca[$style['cap']].' J';
                $s .= $this->linestylecap.' ';
            }
        }
        if (isset($style['join'])) {
            $ja = array('miter' => 0, 'round' => 1, 'bevel' => 2);
            if (isset($ja[$style['join']])) {
                $this->linestylejoin = $ja[$style['join']].' j';
                $s .= $this->linestylejoin.' ';
            }
        }
        if (isset($style['dash'])) {
            $dashstring = '';
            if ($style['dash']) {
                if (preg_match('/^.+,/', $style['dash']) > 0) {
                    $tab = explode(',', $style['dash']);
                } else {
                    $tab = array($style['dash']);
                }
                $dashstring = '';
                foreach ($tab as $i => $v) {
                    if ($i) {
                        $dashstring .= ' ';
                    }
                    $dashstring .= sprintf('%F', $v);
                }
            }
            if (!isset($style['phase']) OR !$style['dash']) {
                $style['phase'] = 0;
            }
            $this->linestyledash = sprintf('[%s] %F d', $dashstring, $style['phase']);
            $s .= $this->linestyledash.' ';
        }
        if (isset($style['color'])) {
            $s .= $this->setdrawcolorarray($style['color'], true).' ';
        }
        if (!$ret) {
            $this->_out($s);
        }
        return $s;
    }

    /**
     * Begin a new subpath by moving the current point to coordinates (x, y), omitting any connecting line segment.
     */
    protected function _outpoint($x, $y) {
        $this->_out(sprintf('%F %F m', ($x * $this->k), (($this->h - $y) * $this->k)));
    }

    /**
     * Append a straight line segment from the current point to the point (x, y).
     */
    protected function _outline($x, $y) {
        $this->_out(sprintf('%F %F l', ($x * $this->k), (($this->h - $y) * $this->k)));
    }

    /**
     * Append a rectangle to the current path as a complete subpath, with lower-left corner (x, y) and dimensions
       width and height in user space.
     */
    protected function _outrect($x, $y, $w, $h, $op) {
        $this->_out(sprintf('%F %F %F %F re %s', $x * $this->k, ($this->h - $y) * $this->k, $w * $this->k, -$h *
                            $this->k, $op));
    }

    /**
     * Append a cubic Bzier curve to the current path. The curve shall extend from the current point to the point
      (x3, y3), using (x1, y1) and (x2, y2) as the Bzier control points.
     * The new current point shall be (x3, y3).
     */
    protected function _outcurve($x1, $y1, $x2, $y2, $x3, $y3) {
        $this->_out(sprintf('%F %F %F %F %F %F c', $x1 * $this->k, ($this->h - $y1) * $this->k, $x2 * $this->k,
        ($this->h - $y2) * $this->k, $x3 * $this->k, ($this->h - $y3) * $this->k));
    }

    /**
     * Append a cubic Bzier curve to the current path. The curve shall extend from the current point to the
       point (x3, y3), using the current point and (x2, y2) as the Bzier control points.
     * The new current point shall be (x3, y3).
     */
    protected function _outcurvev($x2, $y2, $x3, $y3) {
        $this->_out(sprintf('%F %F %F %F v', $x2 * $this->k, ($this->h - $y2) * $this->k, $x3 * $this->k,
                   ($this->h - $y3) * $this->k));
    }

    /**
     * Append a cubic Bzier curve to the current path. The curve shall extend from the current point to the
       point (x3, y3), using (x1, y1) and (x3, y3) as the Bzier control points.
     * The new current point shall be (x3, y3).
     */
    protected function _outcurvey($x1, $y1, $x3, $y3) {
        $this->_out(sprintf('%F %F %F %F y', $x1 * $this->k, ($this->h - $y1) * $this->k, $x3 * $this->k,
                   ($this->h - $y3) * $this->k));
    }

    /**
     * Draws a line between two points.
     * @see setlinewidth(), setdrawcolor(), setlinestyle()
     */
    public function line($x1, $y1, $x2, $y2, $style=array()) {
        if (is_array($style)) {
            $this->setlinestyle($style);
        }
        $this->_outpoint($x1, $y1);
        $this->_outline($x2, $y2);
        $this->_out('S');
    }

    /**
     * Draws a rectangle.
     * @see setlinestyle()
     */
    public function rect($x, $y, $w, $h, $style = '', $borderstyle = array(), $fillcolor = array()) {
        if (!(false === strpos($style, 'F')) AND !empty($fillcolor)) {
            $this->setfillcolorarray($fillcolor);
        }
        $op = $this->getpathpaintoperator($style);
        if ((!$borderstyle) OR (isset($borderstyle['all']))) {
            if (isset($borderstyle['all']) AND $borderstyle['all']) {
                $this->setlinestyle($borderstyle['all']);
                $borderstyle = array();
            }
        }
        $this->_outrect($x, $y, $w, $h, $op);
        if ($borderstyle) {
            $borderstyle2 = array();
            foreach ($borderstyle as $line => $value) {
                $length = strlen($line);
                for ($i = 0; $i < $length; ++$i) {
                    $borderstyle2[$line[$i]] = $value;
                }
            }
            $borderstyle = $borderstyle2;
            if (isset($borderstyle['L']) AND $borderstyle['L']) {
                $this->line($x, $y, $x, $y + $h, $borderstyle['L']);
            }
            if (isset($borderstyle['T']) AND $borderstyle['T']) {
                $this->line($x, $y, $x + $w, $y, $borderstyle['T']);
            }
            if (isset($borderstyle['R']) AND $borderstyle['R']) {
                $this->line($x + $w, $y, $x + $w, $y + $h, $borderstyle['R']);
            }
            if (isset($borderstyle['B']) AND $borderstyle['B']) {
                $this->line($x, $y + $h, $x + $w, $y + $h, $borderstyle['B']);
            }
        }
    }

    /**
     * Draws a Bezier curve.
     * The Bezier curve is a tangent to the line between the control points at
     * either end of the curve.
     */
    public function curve($x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3, $style='', $linestyle=array(),
                          $fillcolor=array()) {
        if (!(false === strpos($style, 'F')) AND isset($fillcolor)) {
            $this->setfillcolorarray($fillcolor);
        }
        $op = $this->getpathpaintoperator($style);
        if ($linestyle) {
            $this->setlinestyle($linestyle);
        }
        $this->_outpoint($x0, $y0);
        $this->_outcurve($x1, $y1, $x2, $y2, $x3, $y3);
        $this->_out($op);
    }

    /**
     * Draws a poly-Bezier curve.
     * Each Bezier curve segment is a tangent to the line between the control points at
     * either end of the curve.
     */
    public function polycurve($x0, $y0, $segments, $style = '', $linestyle = array(), $fillcolor = array()) {
        if (!(false === strpos($style, 'F')) AND isset($fillcolor)) {
            $this->setfillcolorarray($fillcolor);
        }
        $op = $this->getpathpaintoperator($style);
        if ($op == 'f') {
            $linestyle = array();
        }
        if ($linestyle) {
            $this->setlinestyle($linestyle);
        }
        $this->_outpoint($x0, $y0);
        foreach ($segments as $segment) {
            list($x1, $y1, $x2, $y2, $x3, $y3) = $segment;
            $this->_outcurve($x1, $y1, $x2, $y2, $x3, $y3);
        }
        $this->_out($op);
    }

    /**
     * Draws an ellipse.
     * An ellipse is formed from n Bezier curves.
     */
    public function ellipse($x0, $y0, $rx, $ry = '', $angle = 0, $astart = 0, $afinish = 360, $style = '',
                            $linestyle = array(), $fillcolor = array(), $nc = 2) {
        if ($this->empty_string($ry) OR ($ry == 0)) {
            $ry = $rx;
        }
        if (!(false === strpos($style, 'F')) AND isset($fillcolor)) {
            $this->setfillcolorarray($fillcolor);
        }
        $op = $this->getpathpaintoperator($style);
        if ($op == 'f') {
            $linestyle = array();
        }
        if ($linestyle) {
            $this->setlinestyle($linestyle);
        }
        $this->_outellipticalarc($x0, $y0, $rx, $ry, $angle, $astart, $afinish, false, $nc, true, true, false);
        $this->_out($op);
    }

    /**
     * Append an elliptical arc to the current path.
     * An ellipse is formed from n Bezier curves.
     */
    protected function _outellipticalarc($xc, $yc, $rx, $ry, $xang = 0, $angs = 0, $angf = 360, $pie = false, $nc = 2,
                                         $startpoint = true, $ccw = true, $svg = false) {
        $k = $this->k;
        if ($nc < 2) {
            $nc = 2;
        }
        $xmin = 2147483647;
        $ymin = 2147483647;
        $xmax = 0;
        $ymax = 0;
        if ($pie) {
            // Center of the arc.
            $this->_outpoint($xc, $yc);
        }
        $xang = deg2rad((float) $xang);
        $angs = deg2rad((float) $angs);
        $angf = deg2rad((float) $angf);
        if ($svg) {
            $as = $angs;
            $af = $angf;
        } else {
            $as = atan2((sin($angs) / $ry), (cos($angs) / $rx));
            $af = atan2((sin($angf) / $ry), (cos($angf) / $rx));
        }
        if ($as < 0) {
            $as += (2 * M_PI);
        }
        if ($af < 0) {
            $af += (2 * M_PI);
        }
        if ($ccw AND ($as > $af)) {
            // Reverse rotation.
            $as -= (2 * M_PI);
        } else if (!$ccw AND ($as < $af)) {
            // Reverse rotation.
            $af -= (2 * M_PI);
        }
        $totalangle = ($af - $as);
        if ($nc < 2) {
            $nc = 2;
        }
        // Total arcs to draw.
        $nc *= (2 * abs($totalangle) / M_PI);
        $nc = round($nc) + 1;
        // Angle of each arc.
        $arcang = ($totalangle / $nc);
        // Center point in PDF coordinates.
        $x0 = $xc;
        $y0 = ($this->h - $yc);
        // Starting angle.
        $ang = $as;
        $alpha = sin($arcang) * ((sqrt(4 + (3 * pow(tan(($arcang) / 2), 2))) - 1) / 3);
        $cosxang = cos($xang);
        $sinxang = sin($xang);
        $cosang = cos($ang);
        $sinang = sin($ang);
        // First arc point.
        $px1 = $x0 + ($rx * $cosxang * $cosang) - ($ry * $sinxang * $sinang);
        $py1 = $y0 + ($rx * $sinxang * $cosang) + ($ry * $cosxang * $sinang);
        // First Bezier control point.
        $qx1 = ($alpha * ((-$rx * $cosxang * $sinang) - ($ry * $sinxang * $cosang)));
        $qy1 = ($alpha * ((-$rx * $sinxang * $sinang) + ($ry * $cosxang * $cosang)));
        if ($pie) {
            // Line from center to arc starting point.
            $this->_outline($px1, $this->h - $py1);
        } else if ($startpoint) {
            // Arc starting point.
            $this->_outpoint($px1, $this->h - $py1);
        }
        // Draw arcs.
        for ($i = 1; $i <= $nc; ++$i) {
            // Starting angle.
            $ang = $as + ($i * $arcang);
            if ($i == $nc) {
                $ang = $af;
            }
            $cosang = cos($ang);
            $sinang = sin($ang);
            // Second arc point.
            $px2 = $x0 + ($rx * $cosxang * $cosang) - ($ry * $sinxang * $sinang);
            $py2 = $y0 + ($rx * $sinxang * $cosang) + ($ry * $cosxang * $sinang);
            // Second Bezier control point.
            $qx2 = ($alpha * ((-$rx * $cosxang * $sinang) - ($ry * $sinxang * $cosang)));
            $qy2 = ($alpha * ((-$rx * $sinxang * $sinang) + ($ry * $cosxang * $cosang)));
            // Draw arc.
            $cx1 = ($px1 + $qx1);
            $cy1 = ($this->h - ($py1 + $qy1));
            $cx2 = ($px2 - $qx2);
            $cy2 = ($this->h - ($py2 - $qy2));
            $cx3 = $px2;
            $cy3 = ($this->h - $py2);
            $this->_outcurve($cx1, $cy1, $cx2, $cy2, $cx3, $cy3);
            // Get bounding box coordinates.
            $xmin = min($xmin, $cx1, $cx2, $cx3);
            $ymin = min($ymin, $cy1, $cy2, $cy3);
            $xmax = max($xmax, $cx1, $cx2, $cx3);
            $ymax = max($ymax, $cy1, $cy2, $cy3);
            // Move to next point.
            $px1 = $px2;
            $py1 = $py2;
            $qx1 = $qx2;
            $qy1 = $qy2;
        }
        if ($pie) {
            $this->_outline($xc, $yc);
            // Get bounding box coordinates.
            $xmin = min($xmin, $xc);
            $ymin = min($ymin, $yc);
            $xmax = max($xmax, $xc);
            $ymax = max($ymax, $yc);
        }
        return array($xmin, $ymin, $xmax, $ymax);
    }

    /**
     * Draws a circle.
     * A circle is formed from n Bezier curves.
     */
    public function circle($x0, $y0, $r, $angstr = 0, $angend = 360, $style = '', $linestyle = array(),
                           $fillcolor = array(), $nc = 2) {
        $this->ellipse($x0, $y0, $r, $r, 0, $angstr, $angend, $style, $linestyle, $fillcolor, $nc);
    }

    /**
     * Draws a polygonal line
     */
    public function polyline($p, $style = '', $linestyle = array(), $fillcolor = array()) {
        $this->polygon($p, $style, $linestyle, $fillcolor, false);
    }

    /**
     * Draws a polygon.
     */
    public function polygon($p, $style = '', $linestyle = array(), $fillcolor = array(), $closed=true) {
        $nc = count($p); // Number of coordinates.
        $np = $nc / 2; // Number of points.
        if ($closed) {
            // Close polygon by adding the first 2 points at the end (one line).
            for ($i = 0; $i < 4; ++$i) {
                $p[$nc + $i] = $p[$i];
            }
            // Copy style for the last added line.
            if (isset($linestyle[0])) {
                $linestyle[$np] = $linestyle[0];
            }
            $nc += 4;
        }
        if (!(false === strpos($style, 'F')) AND isset($fillcolor)) {
            $this->setfillcolorarray($fillcolor);
        }
        $op = $this->getpathpaintoperator($style);
        if ($op == 'f') {
            $linestyle = array();
        }
        $draw = true;
        if ($linestyle) {
            if (isset($linestyle['all'])) {
                $this->setlinestyle($linestyle['all']);
            } else {
                $draw = false;
                if ($op == 'B') {
                    // Draw fill.
                    $op = 'f';
                    $this->_outpoint($p[0], $p[1]);
                    for ($i = 2; $i < $nc; $i = $i + 2) {
                        $this->_outline($p[$i], $p[$i + 1]);
                    }
                    $this->_out($op);
                }
                // Draw outline.
                $this->_outpoint($p[0], $p[1]);
                for ($i = 2; $i < $nc; $i = $i + 2) {
                    $linenum = ($i / 2) - 1;
                    if (isset($linestyle[$linenum])) {
                        if ($linestyle[$linenum] != 0) {
                            if (is_array($linestyle[$linenum])) {
                                $this->_out('S');
                                $this->setlinestyle($linestyle[$linenum]);
                                $this->_outpoint($p[$i - 2], $p[$i - 1]);
                                $this->_outline($p[$i], $p[$i + 1]);
                                $this->_out('S');
                                $this->_outpoint($p[$i], $p[$i + 1]);
                            } else {
                                $this->_outline($p[$i], $p[$i + 1]);
                            }
                        }
                    } else {
                        $this->_outline($p[$i], $p[$i + 1]);
                    }
                }
                $this->_out($op);
            }
        }
        if ($draw) {
            $this->_outpoint($p[0], $p[1]);
            for ($i = 2; $i < $nc; $i = $i + 2) {
                $this->_outline($p[$i], $p[$i + 1]);
            }
            $this->_out($op);
        }
    }

    /**
     * Draws a regular polygon.
     */
    public function regularpolygon($x0, $y0, $r, $ns, $angle = 0, $drawcircle = false, $style = '',
                                  $linestyle = array(), $fillcolor = array(), $circlestyle = '',
                                  $circleoutlinestyle = array(), $circlefillcolor = array()) {
        if (3 > $ns) {
            $ns = 3;
        }
        if ($drawcircle) {
            $this->circle($x0, $y0, $r, 0, 360, $circlestyle, $circleoutlinestyle, $circlefillcolor);
        }
        $p = array();
        for ($i = 0; $i < $ns; ++$i) {
            $a = $angle + ($i * 360 / $ns);
            $arad = deg2rad((float) $a);
            $p[] = $x0 + ($r * sin($arad));
            $p[] = $y0 + ($r * cos($arad));
        }
        $this->polygon($p, $style, $linestyle, $fillcolor);
    }

    /**
     * Draws a star polygon
     */
    public function starpolygon($x0, $y0, $r, $nv, $ng, $angle = 0, $drawcircle = false, $style = '', $linestyle = array(),
                                $fillcolor = array(), $circlestyle = '', $circleoutlinestyle = array(),
                                $circlefillcolor = array()) {
        if ($nv < 2) {
            $nv = 2;
        }
        if ($drawcircle) {
            $this->circle($x0, $y0, $r, 0, 360, $circlestyle, $circleoutlinestyle, $circlefillcolor);
        }
        $p2 = array();
        $visited = array();
        for ($i = 0; $i < $nv; ++$i) {
            $a = $angle + ($i * 360 / $nv);
            $arad = deg2rad((float) $a);
            $p2[] = $x0 + ($r * sin($arad));
            $p2[] = $y0 + ($r * cos($arad));
            $visited[] = false;
        }
        $p = array();
        $i = 0;
        do {
            $p[] = $p2[$i * 2];
            $p[] = $p2[($i * 2) + 1];
            $visited[$i] = true;
            $i += $ng;
            $i %= $nv;
        } while (!$visited[$i]);
        $this->polygon($p, $style, $linestyle, $fillcolor);
    }

    /**
     * Draws a rounded rectangle.
     */
    public function roundedrect($x, $y, $w, $h, $r, $roundcorner = '1111', $style = '', $borderstyle = array(),
                                $fillcolor = array()) {
        $this->roundedrectxy($x, $y, $w, $h, $r, $r, $roundcorner, $style, $borderstyle, $fillcolor);
    }

    /**
     * Draws a rounded rectangle.
     */
    public function roundedrectxy($x, $y, $w, $h, $rx, $ry, $roundcorner = '1111', $style = '', $borderstyle = array(),
                                  $fillcolor = array()) {
        if (($roundcorner == '0000') OR (($rx == $ry) AND ($rx == 0))) {
            // Not rounded.
            $this->rect($x, $y, $w, $h, $style, $borderstyle, $fillcolor);
            return;
        }
        // Rounded.
        if (!(false === strpos($style, 'F')) AND isset($fillcolor)) {
            $this->setfillcolorarray($fillcolor);
        }
        $op = $this->getpathpaintoperator($style);
        if ($op == 'f') {
            $borderstyle = array();
        }
        if ($borderstyle) {
            $this->setlinestyle($borderstyle);
        }
        $myarc = 4 / 3 * (sqrt(2) - 1);
        $this->_outpoint($x + $rx, $y);
        $xc = $x + $w - $rx;
        $yc = $y + $ry;
        $this->_outline($xc, $y);
        if ($roundcorner[0]) {
            $this->_outcurve($xc + ($rx * $myarc), $yc - $ry, $xc + $rx, $yc - ($ry * $myarc), $xc + $rx, $yc);
        } else {
            $this->_outline($x + $w, $y);
        }
        $xc = $x + $w - $rx;
        $yc = $y + $h - $ry;
        $this->_outline($x + $w, $yc);
        if ($roundcorner[1]) {
            $this->_outcurve($xc + $rx, $yc + ($ry * $myarc), $xc + ($rx * $myarc), $yc + $ry, $xc, $yc + $ry);
        } else {
            $this->_outline($x + $w, $y + $h);
        }
        $xc = $x + $rx;
        $yc = $y + $h - $ry;
        $this->_outline($xc, $y + $h);
        if ($roundcorner[2]) {
            $this->_outcurve($xc - ($rx * $myarc), $yc + $ry, $xc - $rx, $yc + ($ry * $myarc), $xc - $rx, $yc);
        } else {
            $this->_outline($x, $y + $h);
        }
        $xc = $x + $rx;
        $yc = $y + $ry;
        $this->_outline($x, $yc);
        if ($roundcorner[3]) {
            $this->_outcurve($xc - $rx, $yc - ($ry * $myarc), $xc - ($rx * $myarc), $yc - $ry, $xc, $yc - $ry);
        } else {
            $this->_outline($x, $y);
            $this->_outline($x + $rx, $y);
        }
        $this->_out($op);
    }

    /**
     * Draws a grahic arrow.
     */
    public function arrow($x0, $y0, $x1, $y1, $headstyle = 0, $armsize = 5, $armangle = 15) {
        // Getting arrow direction angle.
        $dirangle = atan2(($y0 - $y1), ($x0 - $x1));
        if ($dirangle < 0) {
            $dirangle += (2 * M_PI);
        }
        $armangle = deg2rad($armangle);
        $sx1 = $x1;
        $sy1 = $y1;
        if ($headstyle > 0) {
            // Calculate the stopping point for the arrow shaft.
            $sx1 = $x1 + (($armsize - $this->linewidth) * cos($dirangle));
            $sy1 = $y1 + (($armsize - $this->linewidth) * sin($dirangle));
        }
        // Main arrow line / shaft.
        $this->line($x0, $y0, $sx1, $sy1);
        // Left arrowhead arm tip.
        $x2l = $x1 + ($armsize * cos($dirangle + $armangle));
        $y2l = $y1 + ($armsize * sin($dirangle + $armangle));
        // Right arrowhead arm tip.
        $x2r = $x1 + ($armsize * cos($dirangle - $armangle));
        $y2r = $y1 + ($armsize * sin($dirangle - $armangle));
        $mode = 'D';
        $style = array();
        switch ($headstyle) {
            case 0: {
                // Draw only arrowhead arms.
                $mode = 'D';
                $style = array(1, 1, 0);
                break;
            }
            case 1: {
                // Draw closed arrowhead, but no fill.
                $mode = 'D';
                break;
            }
            case 2: {
                // Closed and filled arrowhead.
                $mode = 'DF';
                break;
            }
            case 3: {
                // Filled arrowhead.
                $mode = 'F';
                break;
            }
        }
        $this->polygon(array($x2l, $y2l, $x1, $y1, $x2r, $y2r), $mode, $style, array());
    }

    // END GRAPHIC FUNCTIONS SECTION.

    // BIDIRECTIONAL TEXT SECTION.

    /**
     * Reverse the RLT substrings using the Bidirectional Algorithm (http://unicode.org/reports/tr9/).
     */
    protected function utf8strrev($str, $setbom = false, $forcertl = false) {
        return $this->utf8strarrrev($this->utf8stringtoarray($str), $str, $setbom, $forcertl);
    }

    /**
     * Reverse the RLT substrings array using the Bidirectional Algorithm (http://unicode.org/reports/tr9/).
     */
    protected function utf8strarrrev($arr, $str='', $setbom = false, $forcertl = false) {
        return $this->arrutf8toutf16be($this->utf8bidi($arr, $str, $forcertl), $setbom);
    }

    /**
     * Reverse the RLT substrings using the Bidirectional Algorithm (http://unicode.org/reports/tr9/).
     */
    protected function utf8bidi($ta, $str = '', $forcertl = false) {
        // Paragraph embedding level.
        $pel = 0;
        // Max level.
        $maxlevel = 0;
        if ($this->empty_string($str)) {
            // Create string from array.
            $str = $this->utf8arrsubstring($ta);
        }
        // Check if string contains arabic text.
        if (preg_match($this->unicode->uni_RE_PATTERN_ARABIC, $str)) {
            $arabic = true;
        } else {
            $arabic = false;
        }
        // Check if string contains RTL text.
        if (!($forcertl OR $arabic OR preg_match($this->unicode->uni_RE_PATTERN_RTL, $str))) {
            return $ta;
        }

        // Get number of chars.
        $numchars = count($ta);

        if ($forcertl == 'R') {
            $pel = 1;
        } else if ($forcertl == 'L') {
            $pel = 0;
        } else {
            // P2. In each paragraph, find the first character of type L, AL, or R.
            // P3. If a character is found in P2 and it is of type AL or R, then set the
            // paragraph embedding level to one; otherwise, set it to zero.
            for ($i = 0; $i < $numchars; ++$i) {
                $type = $this->unicode->uni_type[$ta[$i]];
                if ($type == 'L') {
                    $pel = 0;
                    break;
                } else if (($type == 'AL') OR ($type == 'R')) {
                    $pel = 1;
                    break;
                }
            }
        }

        // Current Embedding Level.
        $cel = $pel;
        // Directional override status.
        $dos = 'N';
        $remember = array();
        // Start-of-level-run.
        $sor = $pel % 2 ? 'R' : 'L';
        $eor = $sor;

        // Array of characters data.
        $chardata = Array();

        for ($i = 0; $i < $numchars; ++$i) {
            if ($ta[$i] == $this->unicode->uni_RLE) {
                $nextlevel = $cel + ($cel % 2) + 1;
                if ($nextlevel < 62) {
                    $remember[] = array('num' => $this->unicode->uni_RLE, 'cel' => $cel, 'dos' => $dos);
                    $cel = $nextlevel;
                    $dos = 'N';
                    $sor = $eor;
                    $eor = $cel % 2 ? 'R' : 'L';
                }
            } else if ($ta[$i] == $this->unicode->uni_LRE) {
                $nextlevel = $cel + 2 - ($cel % 2);
                if ( $nextlevel < 62 ) {
                    $remember[] = array('num' => $this->unicode->uni_LRE, 'cel' => $cel, 'dos' => $dos);
                    $cel = $nextlevel;
                    $dos = 'N';
                    $sor = $eor;
                    $eor = $cel % 2 ? 'R' : 'L';
                }
            } else if ($ta[$i] == $this->unicode->uni_RLO) {
                $nextlevel = $cel + ($cel % 2) + 1;
                if ($nextlevel < 62) {
                    $remember[] = array('num' => $this->unicode->uni_RLO, 'cel' => $cel, 'dos' => $dos);
                    $cel = $nextlevel;
                    $dos = 'R';
                    $sor = $eor;
                    $eor = $cel % 2 ? 'R' : 'L';
                }
            } else if ($ta[$i] == $this->unicode->uni_LRO) {
                $nextlevel = $cel + 2 - ($cel % 2);
                if ( $nextlevel < 62 ) {
                    $remember[] = array('num' => $this->unicode->uni_LRO, 'cel' => $cel, 'dos' => $dos);
                    $cel = $nextlevel;
                    $dos = 'L';
                    $sor = $eor;
                    $eor = $cel % 2 ? 'R' : 'L';
                }
            } else if ($ta[$i] == $this->unicode->uni_PDF) {
                if (count($remember)) {
                    $last = count($remember ) - 1;
                    if (($remember[$last]['num'] == $this->unicode->uni_RLE) OR
                        ($remember[$last]['num'] == $this->unicode->uni_LRE) OR
                        ($remember[$last]['num'] == $this->unicode->uni_RLO) OR
                        ($remember[$last]['num'] == $this->unicode->uni_LRO)) {
                        $match = array_pop($remember);
                        $cel = $match['cel'];
                        $dos = $match['dos'];
                        $sor = $eor;
                        $eor = ($cel > $match['cel'] ? $cel : $match['cel']) % 2 ? 'R' : 'L';
                    }
                }
            } else if (($ta[$i] != $this->unicode->uni_RLE) AND
                             ($ta[$i] != $this->unicode->uni_LRE) AND
                             ($ta[$i] != $this->unicode->uni_RLO) AND
                             ($ta[$i] != $this->unicode->uni_LRO) AND
                             ($ta[$i] != $this->unicode->uni_PDF)) {
                if ($dos != 'N') {
                    $chardir = $dos;
                } else {
                    if (isset($this->unicode->uni_type[$ta[$i]])) {
                        $chardir = $this->unicode->uni_type[$ta[$i]];
                    } else {
                        $chardir = 'L';
                    }
                }
                // Stores string characters and other information.
                $chardata[] = array('char' => $ta[$i], 'level' => $cel, 'type' => $chardir, 'sor' => $sor, 'eor' => $eor);
            }
        } // End for each char.
        $numchars = count($chardata);

        $prevlevel = -1; // Track level changes.
        $levcount = 0; // Counts consecutive chars at the same level.
        for ($i = 0; $i < $numchars; ++$i) {
            if ($chardata[$i]['type'] == 'NSM') {
                if ($levcount) {
                    $chardata[$i]['type'] = $chardata[$i]['sor'];
                } else if ($i > 0) {
                    $chardata[$i]['type'] = $chardata[($i - 1)]['type'];
                }
            }
            if ($chardata[$i]['level'] != $prevlevel) {
                $levcount = 0;
            } else {
                ++$levcount;
            }
            $prevlevel = $chardata[$i]['level'];
        }

        $prevlevel = -1;
        $levcount = 0;
        for ($i = 0; $i < $numchars; ++$i) {
            if ($chardata[$i]['char'] == 'EN') {
                for ($j = $levcount; $j >= 0; $j--) {
                    if ($chardata[$j]['type'] == 'AL') {
                        $chardata[$i]['type'] = 'AN';
                    } else if (($chardata[$j]['type'] == 'L') OR ($chardata[$j]['type'] == 'R')) {
                        break;
                    }
                }
            }
            if ($chardata[$i]['level'] != $prevlevel) {
                $levcount = 0;
            } else {
                ++$levcount;
            }
            $prevlevel = $chardata[$i]['level'];
        }

        for ($i = 0; $i < $numchars; ++$i) {
            if ($chardata[$i]['type'] == 'AL') {
                $chardata[$i]['type'] = 'R';
            }
        }

        $prevlevel = -1;
        $levcount = 0;
        for ($i = 0; $i < $numchars; ++$i) {
            if (($levcount > 0) AND (($i + 1) < $numchars) AND ($chardata[($i + 1)]['level'] == $prevlevel)) {
                if (($chardata[$i]['type'] == 'ES') AND ($chardata[($i - 1)]['type'] == 'EN') AND
                    ($chardata[($i + 1)]['type'] == 'EN')) {
                    $chardata[$i]['type'] = 'EN';
                } else if (($chardata[$i]['type'] == 'CS') AND ($chardata[($i - 1)]['type'] == 'EN') AND
                           ($chardata[($i + 1)]['type'] == 'EN')) {
                    $chardata[$i]['type'] = 'EN';
                } else if (($chardata[$i]['type'] == 'CS') AND ($chardata[($i - 1)]['type'] == 'AN') AND
                           ($chardata[($i + 1)]['type'] == 'AN')) {
                    $chardata[$i]['type'] = 'AN';
                }
            }
            if ($chardata[$i]['level'] != $prevlevel) {
                $levcount = 0;
            } else {
                ++$levcount;
            }
            $prevlevel = $chardata[$i]['level'];
        }

        $prevlevel = -1;
        $levcount = 0;
        for ($i = 0; $i < $numchars; ++$i) {
            if ($chardata[$i]['type'] == 'ET') {
                if (($levcount > 0) AND ($chardata[($i - 1)]['type'] == 'EN')) {
                    $chardata[$i]['type'] = 'EN';
                } else {
                    $j = $i + 1;
                    while (($j < $numchars) AND ($chardata[$j]['level'] == $prevlevel)) {
                        if ($chardata[$j]['type'] == 'EN') {
                            $chardata[$i]['type'] = 'EN';
                            break;
                        } else if ($chardata[$j]['type'] != 'ET') {
                            break;
                        }
                        ++$j;
                    }
                }
            }
            if ($chardata[$i]['level'] != $prevlevel) {
                $levcount = 0;
            } else {
                ++$levcount;
            }
            $prevlevel = $chardata[$i]['level'];
        }

        $prevlevel = -1;
        $levcount = 0;
        for ($i = 0; $i < $numchars; ++$i) {
            if (($chardata[$i]['type'] == 'ET') OR ($chardata[$i]['type'] == 'ES') OR
                ($chardata[$i]['type'] == 'CS')) {
                 $chardata[$i]['type'] = 'ON';
            }
            if ($chardata[$i]['level'] != $prevlevel) {
                $levcount = 0;
            } else {
                ++$levcount;
            }
            $prevlevel = $chardata[$i]['level'];
        }

        $prevlevel = -1;
        $levcount = 0;
        for ($i = 0; $i < $numchars; ++$i) {
            if ($chardata[$i]['char'] == 'EN') {
                for ($j = $levcount; $j >= 0; $j--) {
                    if ($chardata[$j]['type'] == 'L') {
                        $chardata[$i]['type'] = 'L';
                    } else if ($chardata[$j]['type'] == 'R') {
                        break;
                    }
                }
            }
            if ($chardata[$i]['level'] != $prevlevel) {
                $levcount = 0;
            } else {
                ++$levcount;
            }
            $prevlevel = $chardata[$i]['level'];
        }

        $prevlevel = -1;
        $levcount = 0;
        for ($i = 0; $i < $numchars; ++$i) {
            if (($levcount > 0) AND (($i + 1) < $numchars) AND ($chardata[($i + 1)]['level'] == $prevlevel)) {
                if (($chardata[$i]['type'] == 'N') AND ($chardata[($i - 1)]['type'] == 'L') AND
                ($chardata[($i + 1)]['type'] == 'L')) {
                    $chardata[$i]['type'] = 'L';
                } else if (($chardata[$i]['type'] == 'N') AND
                 (($chardata[($i - 1)]['type'] == 'R') OR ($chardata[($i - 1)]['type'] == 'EN') OR
                 ($chardata[($i - 1)]['type'] == 'AN')) AND
                 (($chardata[($i + 1)]['type'] == 'R') OR ($chardata[($i + 1)]['type'] == 'EN') OR
                 ($chardata[($i + 1)]['type'] == 'AN'))) {
                    $chardata[$i]['type'] = 'R';
                } else if ($chardata[$i]['type'] == 'N') {
                    // N2. Any remaining neutrals take the embedding direction.
                    $chardata[$i]['type'] = $chardata[$i]['sor'];
                }
            } else if (($levcount == 0) AND (($i + 1) < $numchars) AND ($chardata[($i + 1)]['level'] == $prevlevel)) {
                // First char.
                if (($chardata[$i]['type'] == 'N') AND ($chardata[$i]['sor'] == 'L') AND
                    ($chardata[($i + 1)]['type'] == 'L')) {
                    $chardata[$i]['type'] = 'L';
                } else if (($chardata[$i]['type'] == 'N') AND
                 (($chardata[$i]['sor'] == 'R') OR ($chardata[$i]['sor'] == 'EN') OR
                  ($chardata[$i]['sor'] == 'AN')) AND
                 (($chardata[($i + 1)]['type'] == 'R') OR ($chardata[($i + 1)]['type'] == 'EN') OR
                  ($chardata[($i + 1)]['type'] == 'AN'))) {
                    $chardata[$i]['type'] = 'R';
                } else if ($chardata[$i]['type'] == 'N') {
                    // N2. Any remaining neutrals take the embedding direction.
                    $chardata[$i]['type'] = $chardata[$i]['sor'];
                }
            } else if (($levcount > 0) AND ((($i + 1) == $numchars) OR (($i + 1) < $numchars) AND
            ($chardata[($i + 1)]['level'] != $prevlevel))) {
                // Last char.
                if (($chardata[$i]['type'] == 'N') AND ($chardata[($i - 1)]['type'] == 'L') AND
                ($chardata[$i]['eor'] == 'L')) {
                    $chardata[$i]['type'] = 'L';
                } else if (($chardata[$i]['type'] == 'N') AND
                 (($chardata[($i - 1)]['type'] == 'R') OR ($chardata[($i - 1)]['type'] == 'EN') OR
                 ($chardata[($i - 1)]['type'] == 'AN')) AND
                 (($chardata[$i]['eor'] == 'R') OR ($chardata[$i]['eor'] == 'EN') OR
                 ($chardata[$i]['eor'] == 'AN'))) {
                    $chardata[$i]['type'] = 'R';
                } else if ($chardata[$i]['type'] == 'N') {
                    // N2. Any remaining neutrals take the embedding direction.
                    $chardata[$i]['type'] = $chardata[$i]['sor'];
                }
            } else if ($chardata[$i]['type'] == 'N') {
                // N2. Any remaining neutrals take the embedding direction.
                $chardata[$i]['type'] = $chardata[$i]['sor'];
            }
            if ($chardata[$i]['level'] != $prevlevel) {
                $levcount = 0;
            } else {
                ++$levcount;
            }
            $prevlevel = $chardata[$i]['level'];
        }
        for ($i = 0; $i < $numchars; ++$i) {
            $odd = $chardata[$i]['level'] % 2;
            if ($odd) {
                if (($chardata[$i]['type'] == 'L') OR ($chardata[$i]['type'] == 'AN') OR
                    ($chardata[$i]['type'] == 'EN')) {
                    $chardata[$i]['level'] += 1;
                }
            } else {
                if ($chardata[$i]['type'] == 'R') {
                    $chardata[$i]['level'] += 1;
                } else if (($chardata[$i]['type'] == 'AN') OR ($chardata[$i]['type'] == 'EN')) {
                    $chardata[$i]['level'] += 2;
                }
            }
            $maxlevel = max($chardata[$i]['level'], $maxlevel);
        }

        for ($i = 0; $i < $numchars; ++$i) {
            if (($chardata[$i]['type'] == 'B') OR ($chardata[$i]['type'] == 'S')) {
                $chardata[$i]['level'] = $pel;
            } else if ($chardata[$i]['type'] == 'WS') {
                $j = $i + 1;
                while ($j < $numchars) {
                    if ((($chardata[$j]['type'] == 'B') OR ($chardata[$j]['type'] == 'S')) OR
                        (($j == ($numchars - 1)) AND ($chardata[$j]['type'] == 'WS'))) {
                        $chardata[$i]['level'] = $pel;
                        break;
                    } else if ($chardata[$j]['type'] != 'WS') {
                        break;
                    }
                    ++$j;
                }
            }
        }

        // Arabic Shaping.
        if ($arabic) {
            $endedletter = array(1569, 1570, 1571, 1572, 1573, 1575, 1577, 1583, 1584, 1585, 1586, 1608, 1688);
            $alfletter = array(1570, 1571, 1573, 1575);
            $chardata2 = $chardata;
            $laaletter = false;
            $charal = array();
            $x = 0;
            for ($i = 0; $i < $numchars; ++$i) {
                if (($this->unicode->uni_type[$chardata[$i]['char']] == 'AL') OR ($chardata[$i]['char'] == 32) OR
                                             ($chardata[$i]['char'] == 8204)) {
                    $charal[$x] = $chardata[$i];
                    $charal[$x]['i'] = $i;
                    $chardata[$i]['x'] = $x;
                    ++$x;
                }
            }
            $numal = $x;
            for ($i = 0; $i < $numchars; ++$i) {
                $thischar = $chardata[$i];
                if ($i > 0) {
                    $prevchar = $chardata[($i - 1)];
                } else {
                    $prevchar = false;
                }
                if (($i + 1) < $numchars) {
                    $nextchar = $chardata[($i + 1)];
                } else {
                    $nextchar = false;
                }
                if ($this->unicode->uni_type[$thischar['char']] == 'AL') {
                    $x = $thischar['x'];
                    if ($x > 0) {
                        $prevchar = $charal[($x - 1)];
                    } else {
                        $prevchar = false;
                    }
                    if (($x + 1) < $numal) {
                        $nextchar = $charal[($x + 1)];
                    } else {
                        $nextchar = false;
                    }
                    if (($prevchar !== false) AND ($prevchar['char'] == 1604) AND
                       (in_array($thischar['char'], $alfletter))) {
                        $arabicarr = $this->unicode->uni_laa_array;
                        $laaletter = true;
                        if ($x > 1) {
                            $prevchar = $charal[($x - 2)];
                        } else {
                            $prevchar = false;
                        }
                    } else {
                        $arabicarr = $this->unicode->uni_arabicsubst;
                        $laaletter = false;
                    }
                    if (($prevchar !== false) AND ($nextchar !== false) AND
                        (($this->unicode->uni_type[$prevchar['char']] == 'AL') OR
                        ($this->unicode->uni_type[$prevchar['char']] == 'NSM')) AND
                        (($this->unicode->uni_type[$nextchar['char']] == 'AL') OR
                        ($this->unicode->uni_type[$nextchar['char']] == 'NSM')) AND
                        ($prevchar['type'] == $thischar['type']) AND
                        ($nextchar['type'] == $thischar['type']) AND
                        ($nextchar['char'] != 1567)) {
                        if (in_array($prevchar['char'], $endedletter)) {
                            if (isset($arabicarr[$thischar['char']][2])) {
                                // Initial.
                                $chardata2[$i]['char'] = $arabicarr[$thischar['char']][2];
                            }
                        } else {
                            if (isset($arabicarr[$thischar['char']][3])) {
                                // Medial.
                                $chardata2[$i]['char'] = $arabicarr[$thischar['char']][3];
                            }
                        }
                    } else if (($nextchar !== false) AND
                        (($this->unicode->uni_type[$nextchar['char']] == 'AL') OR
                        ($this->unicode->uni_type[$nextchar['char']] == 'NSM')) AND
                        ($nextchar['type'] == $thischar['type']) AND
                        ($nextchar['char'] != 1567)) {
                        if (isset($arabicarr[$chardata[$i]['char']][2])) {
                            // Initial.
                            $chardata2[$i]['char'] = $arabicarr[$thischar['char']][2];
                        }
                    } else if ((($prevchar !== false) AND
                        (($this->unicode->uni_type[$prevchar['char']] == 'AL') OR
                        ($this->unicode->uni_type[$prevchar['char']] == 'NSM')) AND
                        ($prevchar['type'] == $thischar['type'])) OR
                        (($nextchar !== false) AND ($nextchar['char'] == 1567))) {
                        // Final.
                        if (($i > 1) AND ($thischar['char'] == 1607) AND
                            ($chardata[$i - 1]['char'] == 1604) AND
                            ($chardata[$i - 2]['char'] == 1604)) {
                            // Mark characters to delete with false.
                            $chardata2[$i - 2]['char'] = false;
                            $chardata2[$i - 1]['char'] = false;
                            $chardata2[$i]['char'] = 65010;
                        } else {
                            if (($prevchar !== false) AND in_array($prevchar['char'], $endedletter)) {
                                if (isset($arabicarr[$thischar['char']][0])) {
                                    // Isolated.
                                    $chardata2[$i]['char'] = $arabicarr[$thischar['char']][0];
                                }
                            } else {
                                if (isset($arabicarr[$thischar['char']][1])) {
                                    // Final.
                                    $chardata2[$i]['char'] = $arabicarr[$thischar['char']][1];
                                }
                            }
                        }
                    } else if (isset($arabicarr[$thischar['char']][0])) {
                        // Isolated.
                        $chardata2[$i]['char'] = $arabicarr[$thischar['char']][0];
                    }
                    if ($laaletter) {
                        // Mark characters to delete with false.
                        $chardata2[($charal[($x - 1)]['i'])]['char'] = false;
                    }
                } // end if AL (Arabic Letter)
            } // end for each char
            /*
             * Combining characters that can occur with Arabic Shadda (0651 HEX, 1617 DEC) are replaced.
             * Putting the combining mark and shadda in the same glyph allows us to avoid the two marks
               overlapping each other in an illegible manner.
             */
            for ($i = 0; $i < ($numchars - 1); ++$i) {
                if (($chardata2[$i]['char'] == 1617) AND
                (isset($this->unicode->uni_diacritics[($chardata2[$i + 1]['char'])]))) {
                    // Check if the subtitution font is defined on current font.
                    if (isset($this->currentfont['cw'][($this->unicode->uni_diacritics[($chardata2[$i + 1]['char'])])])) {
                        $chardata2[$i]['char'] = false;
                        $chardata2[$i + 1]['char'] = $this->unicode->uni_diacritics[($chardata2[$i + 1]['char'])];
                    }
                }
            }
            // Remove marked characters.
            foreach ($chardata2 as $key => $value) {
                if ($value['char'] === false) {
                    unset($chardata2[$key]);
                }
            }
            $chardata = array_values($chardata2);
            $numchars = count($chardata);
            unset($chardata2);
            unset($arabicarr);
            unset($laaletter);
            unset($charal);
        }

        for ($j = $maxlevel; $j > 0; $j--) {
            $ordarray = Array();
            $revarr = Array();
            $onlevel = false;
            for ($i = 0; $i < $numchars; ++$i) {
                if ($chardata[$i]['level'] >= $j) {
                    $onlevel = true;
                    if (isset($this->unicode->uni_mirror[$chardata[$i]['char']])) {
                        $chardata[$i]['char'] = $this->unicode->uni_mirror[$chardata[$i]['char']];
                    }
                    $revarr[] = $chardata[$i];
                } else {
                    if ($onlevel) {
                        $revarr = array_reverse($revarr);
                        $ordarray = array_merge($ordarray, $revarr);
                        $revarr = Array();
                        $onlevel = false;
                    }
                    $ordarray[] = $chardata[$i];
                }
            }
            if ($onlevel) {
                $revarr = array_reverse($revarr);
                $ordarray = array_merge($ordarray, $revarr);
            }
            $chardata = $ordarray;
        }

        $ordarray = array();
        for ($i = 0; $i < $numchars; ++$i) {
            $ordarray[] = $chardata[$i]['char'];
            // Store char values for subsetting.
            $this->currentfont['subsetchars'][$chardata[$i]['char']] = true;
        }
        // Update font subsetchars.
        $this->setfontsubbuffer($this->currentfont['fontkey'], 'subsetchars', $this->currentfont['subsetchars']);
        return $ordarray;
    }

    // END OF BIDIRECTIONAL TEXT SECTION.

    /**
     * Encode a name object.
     */
    protected function encodenameobject($name) {
        $escname = '';
        $length = strlen($name);
        for ($i = 0; $i < $length; ++$i) {
            $chr = $name[$i];
            if (preg_match('/[0-9a-zA-Z]/', $chr) == 1) {
                $escname .= $chr;
            } else {
                $escname .= sprintf('#%02X', ord($chr));
            }
        }
        return $escname;
    }

    /**
     * Add a Named Destination.
     * NOTE: destination names are unique, so only last entry will be saved.
     */
    public function setdestination($name, $y = -1, $page = '') {
        // Remove unsupported characters.
        $name = $this->encodenameobject($name);
        if ($this->empty_string($name)) {
            return false;
        }
        if ($y == -1) {
            $y = $this->gety();
        }
        if (empty($page)) {
            $page = $this->pageno();
            if (empty($page)) {
                return;
            }
        }
        $this->dests[$name] = array('y' => $y, 'p' => $page);
        return $name;
    }

    /**
     * Return the Named Destination array.
     */
    public function getdestination() {
        return $this->dests;
    }

    /**
     * Create a javascript PDF string.
     */
    protected function _putdests() {
        if (empty($this->dests)) {
            return;
        }
        $this->ndests = $this->_newobj();
        $out = ' <<';
        foreach ($this->dests as $name => $o) {
            $out .= ' /'.$name.' '.sprintf('[%u 0 R /XYZ 0 %F null]', $this->pageobjid[($o['p'])],
                   ($this->pagedim[$o['p']]['h'] - ($o['y'] * $this->k)));
        }
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
    }

    /**
     * Adds a bookmark - alias for bookmark().
     */
    public function setbookmark($txt, $level = 0, $y = -1, $page = '', $style = '', $color = array(0, 0, 0)) {
        $this->bookmark($txt, $level, $y, $page, $style, $color);
    }

    /**
     * Adds a bookmark.
     */
    public function bookmark($txt, $level = 0, $y = -1, $page = '', $style = '', $color = array(0, 0, 0)) {
        if ($level < 0) {
            $level = 0;
        }
        if (isset($this->outlines[0])) {
            $lastoutline = end($this->outlines);
            $maxlevel = $lastoutline['l'] + 1;
        } else {
            $maxlevel = 0;
        }
        if ($level > $maxlevel) {
            $level = $maxlevel;
        }
        if ($y == -1) {
            $y = $this->gety();
        }
        if (empty($page)) {
            $page = $this->pageno();
            if (empty($page)) {
                return;
            }
        }
        $this->outlines[] = array('t' => $txt, 'l' => $level, 'y' => $y, 'p' => $page, 's' => strtoupper($style),
                                  'c' => $color);
    }

    /**
     * Sort bookmarks for page and key.
     */
    protected function sortbookmarks() {
        // Get sorting columns.
        $outlinep = array();
        $outliney = array();
        foreach ($this->outlines as $key => $row) {
            $outlinep[$key] = $row['p'];
            $outlinek[$key] = $key;
        }
        // Sort outlines by page and original position.
        array_multisort($outlinep, SORT_NUMERIC, SORT_ASC, $outlinek, SORT_NUMERIC, SORT_ASC, $this->outlines);
    }

    /**
     * Create a bookmark PDF string.
     */
    protected function _putbookmarks() {
        $nb = count($this->outlines);
        if ($nb == 0) {
            return;
        }
        // Sort bookmarks.
        $this->sortbookmarks();
        $lru = array();
        $level = 0;
        foreach ($this->outlines as $i => $o) {
            if ($o['l'] > 0) {
                $parent = $lru[($o['l'] - 1)];
                // Set parent and last pointers.
                $this->outlines[$i]['parent'] = $parent;
                $this->outlines[$parent]['last'] = $i;
                if ($o['l'] > $level) {
                    // Level increasing: set first pointer.
                    $this->outlines[$parent]['first'] = $i;
                }
            } else {
                $this->outlines[$i]['parent'] = $nb;
            }
            if (($o['l'] <= $level) AND ($i > 0)) {
                // Set prev and next pointers.
                $prev = $lru[$o['l']];
                $this->outlines[$prev]['next'] = $i;
                $this->outlines[$i]['prev'] = $prev;
            }
            $lru[$o['l']] = $i;
            $level = $o['l'];
        }
        // Outline items.
        $n = $this->n + 1;
        $nltags = '/<br[\s]?\/>|<\/(blockquote|dd|dl|div|dt|h1|h2|h3|h4|h5|h6|hr|li|ol|p|pre|ul|tcpdf|table|tr|td)>/si';
        foreach ($this->outlines as $i => $o) {
            $oid = $this->_newobj();
            // Convert HTML title to string.
            $title = preg_replace($nltags, "\n", $o['t']);
            $title = preg_replace("/[\r]+/si", '', $title);
            $title = preg_replace("/[\n]+/si", "\n", $title);
            $title = strip_tags($title);
            $title = $this->stringtrim($title);
            $out = '<</Title '.$this->_textstring($title, $oid);
            $out .= ' /Parent '.($n + $o['parent']).' 0 R';
            if (isset($o['prev'])) {
                $out .= ' /Prev '.($n + $o['prev']).' 0 R';
            }
            if (isset($o['next'])) {
                $out .= ' /Next '.($n + $o['next']).' 0 R';
            }
            if (isset($o['first'])) {
                $out .= ' /First '.($n + $o['first']).' 0 R';
            }
            if (isset($o['last'])) {
                $out .= ' /Last '.($n + $o['last']).' 0 R';
            }
            if (isset($this->pageobjid[($o['p'])])) {
                $out .= ' '.sprintf('/Dest [%u 0 R /XYZ 0 %F null]', $this->pageobjid[($o['p'])],
                                    ($this->pagedim[$o['p']]['h'] - ($o['y'] * $this->k)));
            }
            // Set font style.
            $style = 0;
            if (!empty($o['s'])) {
                // Bold.
                if (strpos($o['s'], 'B') !== false) {
                    $style |= 2;
                }
                // Oblique.
                if (strpos($o['s'], 'I') !== false) {
                    $style |= 1;
                }
            }
            $out .= sprintf(' /F %d', $style);
            // Set bookmark color.
            if (isset($o['c']) AND is_array($o['c']) AND (count($o['c']) == 3)) {
                $color = array_values($o['c']);
                $out .= sprintf(' /C [%F %F %F]', ($color[0] / 255), ($color[1] / 255), ($color[2] / 255));
            } else {
                // Black.
                $out .= ' /C [0.0 0.0 0.0]';
            }
            $out .= ' /Count 0'; // Normally closed item.
            $out .= ' >>';
            $out .= "\n".'endobj';
            $this->_out($out);
        }
        // Outline root.
        $this->outlineroot = $this->_newobj();
        $this->_out('<< /Type /Outlines /First '.$n.' 0 R /Last '.($n + $lru[0]).' 0 R >>'."\n".'endobj');
    }

    // JAVASCRIPT.

    /**
     * Adds a javascript
     */
    public function includejs($script) {
        $this->javascript .= $script;
    }

    /**
     * Adds a javascript object and return object ID
     */
    public function addjavascriptobject($script, $onload=false) {
        if ($this->pdfamode) {
            // Javascript is not allowed in PDF/A mode.
            return false;
        }
        ++$this->n;
        $this->jsobjects[$this->n] = array('n' => $this->n, 'js' => $script, 'onload' => $onload);
        return $this->n;
    }

    /**
     * Create a javascript PDF string.
     */
    protected function _putjavascript() {
        if ($this->pdfamode OR (empty($this->javascript) AND empty($this->jsobjects))) {
            return;
        }
        if (strpos($this->javascript, 'this.addField') > 0) {
            // The following two lines are used to avoid form fields duplication after saving.
            // The addField method only works when releasing user rights (UR3).
            $jsa = sprintf("ftcpdfdocsaved=this.addField('%s','%s',%d,[%F,%F,%F,%F]);", 'tcpdfdocsaved', 'text',
                            0, 0, 1, 0, 1);
            $jsb = "getField('tcpdfdocsaved').value='saved';";
            $this->javascript = $jsa."\n".$this->javascript."\n".$jsb;
        }
        $this->njs = $this->_newobj();
        $out = ' << /Names [';
        if (!empty($this->javascript)) {
            $out .= ' (EmbeddedJS) '.($this->n + 1).' 0 R';
        }
        if (!empty($this->jsobjects)) {
            foreach ($this->jsobjects as $key => $val) {
                if ($val['onload']) {
                    $out .= ' (JS'.$key.') '.$key.' 0 R';
                }
            }
        }
        $out .= ' ] >>';
        $out .= "\n".'endobj';
        $this->_out($out);
        // Default Javascript object.
        if (!empty($this->javascript)) {
            $objid = $this->_newobj();
            $out = '<< /S /JavaScript';
            $out .= ' /JS '.$this->_textstring($this->javascript, $objid);
            $out .= ' >>';
            $out .= "\n".'endobj';
            $this->_out($out);
        }
        // Additional Javascript objects.
        if (!empty($this->jsobjects)) {
            foreach ($this->jsobjects as $key => $val) {
                $out = $this->_getobj($key)."\n".' << /S /JavaScript /JS '.$this->_textstring($val['js'], $key).
                                      ' >>'."\n".'endobj';
                $this->_out($out);
            }
        }
    }

    /**
     * Convert color to javascript color.
     */
    protected function _jscolor($color) {
        static $acolors = array('transparent', 'black', 'white', 'red', 'green', 'blue', 'cyan', 'magenta',
                                'yellow', 'dkGray', 'gray', 'ltGray');
        if (substr($color, 0, 1) == '#') {
            return sprintf("['RGB',%F,%F,%F]", hexdec(substr($color, 1, 2)) / 255, hexdec(substr($color, 3, 2)) / 255,
                             hexdec(substr($color, 5, 2)) / 255);
        }
        if (!in_array($color, $acolors)) {
            $this->errord('Invalid color: '.$color);
        }
        return 'color.'.$color;
    }

    /**
     * Adds a javascript form field.
     */
    protected function _addfield($type, $name, $x, $y, $w, $h, $prop) {
        if ($this->rtl) {
            $x = $x - $w;
        }
        // The followind avoid fields duplication after saving the document.
        $this->javascript .= "if (getField('tcpdfdocsaved').value != 'saved') {";
        $k = $this->k;
        $this->javascript .= sprintf("f".$name."=this.addField('%s','%s',%u,[%F,%F,%F,%F]);", $name, $type,
                             $this->pageno() - 1, $x * $k, ($this->h - $y) * $k + 1, ($x + $w) * $k,
                             ($this->h - $y - $h) * $k + 1)."\n";
        $this->javascript .= 'f'.$name.'.textSize='.$this->fontsizept.";\n";
        while (list($key, $val) = each($prop)) {
            if (strcmp(substr($key, -5), 'Color') == 0) {
                $val = $this->_jscolor($val);
            } else {
                $val = "'".$val."'";
            }
            $this->javascript .= 'f'.$name.'.'.$key.'='.$val.";\n";
        }
        if ($this->rtl) {
            $this->x -= $w;
        } else {
            $this->x += $w;
        }
        $this->javascript .= '}';
    }

    // FORM FIELDS.

    /**
     * Convert JavaScript form fields properties array to annotation Properties array.
     */
    protected function getannotoptfromjsprop($prop) {
        if (isset($prop['aopt']) AND is_array($prop['aopt'])) {
            // The annotation options area lready defined.
            return $prop['aopt'];
        }
        $opt = array(); // Value to be returned.
        // Alignment: Controls how the text is laid out within the text field.
        if (isset($prop['alignment'])) {
            switch ($prop['alignment']) {
                case 'left': {
                    $opt['q'] = 0;
                    break;
                }
                case 'center': {
                    $opt['q'] = 1;
                    break;
                }
                case 'right': {
                    $opt['q'] = 2;
                    break;
                }
                default: {
                    $opt['q'] = ($this->rtl) ? 2 : 0;
                    break;
                }
            }
        }
        // LineWidth: Specifies the thickness of the border when stroking the perimeter of a field's rectangle.
        if (isset($prop['lineWidth'])) {
            $linewidth = intval($prop['lineWidth']);
        } else {
            $linewidth = 1;
        }
        // BorderStyle: The border style for a field.
        if (isset($prop['borderStyle'])) {
            switch ($prop['borderStyle']) {
                case 'border.d':
                case 'dashed': {
                    $opt['border'] = array(0, 0, $linewidth, array(3, 2));
                    $opt['bs'] = array('w' => $linewidth, 's' => 'D', 'd' => array(3, 2));
                    break;
                }
                case 'border.b':
                case 'beveled': {
                    $opt['border'] = array(0, 0, $linewidth);
                    $opt['bs'] = array('w' => $linewidth, 's' => 'B');
                    break;
                }
                case 'border.i':
                case 'inset': {
                    $opt['border'] = array(0, 0, $linewidth);
                    $opt['bs'] = array('w' => $linewidth, 's' => 'I');
                    break;
                }
                case 'border.u':
                case 'underline': {
                    $opt['border'] = array(0, 0, $linewidth);
                    $opt['bs'] = array('w' => $linewidth, 's' => 'U');
                    break;
                }
                case 'border.s':
                case 'solid': {
                    $opt['border'] = array(0, 0, $linewidth);
                    $opt['bs'] = array('w' => $linewidth, 's' => 'S');
                    break;
                }
                default: {
                    break;
                }
            }
        }
        if (isset($prop['border']) AND is_array($prop['border'])) {
            $opt['border'] = $prop['border'];
        }
        if (!isset($opt['mk'])) {
            $opt['mk'] = array();
        }
        if (!isset($opt['mk']['if'])) {
            $opt['mk']['if'] = array();
        }
        $opt['mk']['if']['a'] = array(0.5, 0.5);
        if (isset($prop['buttonAlignX'])) {
            $opt['mk']['if']['a'][0] = $prop['buttonAlignX'];
        }
        if (isset($prop['buttonAlignY'])) {
            $opt['mk']['if']['a'][1] = $prop['buttonAlignY'];
        }
        if (isset($prop['buttonFitBounds']) AND ($prop['buttonFitBounds'] == 'true')) {
            $opt['mk']['if']['fb'] = true;
        }
        if (isset($prop['buttonscaleHow'])) {
            switch ($prop['buttonscaleHow']) {
                case 'scaleHow.proportional': {
                    $opt['mk']['if']['s'] = 'P';
                    break;
                }
                case 'scaleHow.anamorphic': {
                    $opt['mk']['if']['s'] = 'A';
                    break;
                }
            }
        }
        if (isset($prop['buttonscaleWhen'])) {
            switch ($prop['buttonscaleWhen']) {
                case 'scaleWhen.always': {
                    $opt['mk']['if']['sw'] = 'A';
                    break;
                }
                case 'scaleWhen.never': {
                    $opt['mk']['if']['sw'] = 'N';
                    break;
                }
                case 'scaleWhen.tooBig': {
                    $opt['mk']['if']['sw'] = 'B';
                    break;
                }
                case 'scaleWhen.tooSmall': {
                    $opt['mk']['if']['sw'] = 'S';
                    break;
                }
            }
        }
        if (isset($prop['buttonPosition'])) {
            switch ($prop['buttonPosition']) {
                case 0:
                case 'position.textOnly': {
                    $opt['mk']['tp'] = 0;
                    break;
                }
                case 1:
                case 'position.iconOnly': {
                    $opt['mk']['tp'] = 1;
                    break;
                }
                case 2:
                case 'position.icontextV': {
                    $opt['mk']['tp'] = 2;
                    break;
                }
                case 3:
                case 'position.textIconV': {
                    $opt['mk']['tp'] = 3;
                    break;
                }
                case 4:
                case 'position.icontextH': {
                    $opt['mk']['tp'] = 4;
                    break;
                }
                case 5:
                case 'position.textIconH': {
                    $opt['mk']['tp'] = 5;
                    break;
                }
                case 6:
                case 'position.overlay': {
                    $opt['mk']['tp'] = 6;
                    break;
                }
            }
        }
        // FillColor: Specifies the background color for a field.
        if (isset($prop['fillColor'])) {
            if (is_array($prop['fillColor'])) {
                $opt['mk']['bg'] = $prop['fillColor'];
            } else {
                $opt['mk']['bg'] = $this->converthtmlcolortodec($prop['fillColor']);
            }
        }
        // StrokeColor: Specifies the stroke color for a field that is used to stroke the rectangle of the
        // field with a line as large as the line width.
        if (isset($prop['strokeColor'])) {
            if (is_array($prop['strokeColor'])) {
                $opt['mk']['bc'] = $prop['strokeColor'];
            } else {
                $opt['mk']['bc'] = $this->converthtmlcolortodec($prop['strokeColor']);
            }
        }
        // Rotation: The rotation of a widget in counterclockwise increments.
        if (isset($prop['rotation'])) {
            $opt['mk']['r'] = $prop['rotation'];
        }
        // CharLimit: Limits the number of characters that a user can type into a text field.
        if (isset($prop['charLimit'])) {
            $opt['maxlen'] = intval($prop['charLimit']);
        }
        if (!isset($ff)) {
            $ff = 0; // Default value.
        }
        // Readonly: The read-only characteristic of a field. If a field is read-only,
        // the user can see the field but cannot change it.
        if (isset($prop['readonly']) AND ($prop['readonly'] == 'true')) {
            $ff += 1 << 0;
        }
        // Required: Specifies whether a field requires a value.
        if (isset($prop['required']) AND ($prop['required'] == 'true')) {
            $ff += 1 << 1;
        }
        // Multiline: Controls how text is wrapped within the field.
        if (isset($prop['multiline']) AND ($prop['multiline'] == 'true')) {
            $ff += 1 << 12;
        }
        // Password: Specifies whether the field should display asterisks when data is entered in the field.
        if (isset($prop['password']) AND ($prop['password'] == 'true')) {
            $ff += 1 << 13;
        }
        // NoToggleToOff: If set, exactly one radio button shall be selected at all times
        // selecting the currently selected button has no effect.
        if (isset($prop['NoToggleToOff']) AND ($prop['NoToggleToOff'] == 'true')) {
            $ff += 1 << 14;
        }
        // Radio: If set, the field is a set of radio buttons.
        if (isset($prop['Radio']) AND ($prop['Radio'] == 'true')) {
            $ff += 1 << 15;
        }
        // Pushbutton: If set, the field is a pushbutton that does not retain a permanent value.
        if (isset($prop['Pushbutton']) AND ($prop['Pushbutton'] == 'true')) {
            $ff += 1 << 16;
        }
        // Combo: If set, the field is a combo box; if clear, the field is a list box.
        if (isset($prop['Combo']) AND ($prop['Combo'] == 'true')) {
            $ff += 1 << 17;
        }
        // Editable: Controls whether a combo box is editable.
        if (isset($prop['editable']) AND ($prop['editable'] == 'true')) {
            $ff += 1 << 18;
        }
        // Sort: If set, the field's option items shall be sorted alphabetically.
        if (isset($prop['Sort']) AND ($prop['Sort'] == 'true')) {
            $ff += 1 << 19;
        }
        // FileSelect: If true, sets the file-select flag in the Options tab of the text field.
        if (isset($prop['fileSelect']) AND ($prop['fileSelect'] == 'true')) {
            $ff += 1 << 20;
        }
        // MultipleSelection: If true, indicates that a list box allows a multiple selection of items.
        if (isset($prop['multipleSelection']) AND ($prop['multipleSelection'] == 'true')) {
            $ff += 1 << 21;
        }
        // DoNotSpellCheck: If true, spell checking is not performed on this editable text field.
        if (isset($prop['doNotSpellCheck']) AND ($prop['doNotSpellCheck'] == 'true')) {
            $ff += 1 << 22;
        }
        // DoNotScroll: If true, the text field does not scroll and the user, therefore, is limited by
        // the rectangular region designed for the field.
        if (isset($prop['doNotScroll']) AND ($prop['doNotScroll'] == 'true')) {
            $ff += 1 << 23;
        }
        // Comb: If set to true, the field background is drawn as series of boxes
        // (one for each character in the value of the field) and each character of the content is drawn within
        // those boxes. The number of boxes drawn is determined from the charLimit property. It applies only to
        // text fields. The setter will also raise if any of the following field properties are also set multiline,
        // password, and fileSelect. A side-effect of setting this property is that the doNotScroll property is also set.
        if (isset($prop['comb']) AND ($prop['comb'] == 'true')) {
            $ff += 1 << 24;
        }
        // RadiosInUnison: If false, even if a group of radio buttons have the same name and export value, they behave
        // in a mutually exclusive fashion, like HTML radio buttons.
        if (isset($prop['radiosInUnison']) AND ($prop['radiosInUnison'] == 'true')) {
            $ff += 1 << 25;
        }
        // Richtext: If true, the field allows rich text formatting.
        if (isset($prop['richtext']) AND ($prop['richtext'] == 'true')) {
            $ff += 1 << 25;
        }
        // CommitOnSelChange: Controls whether a field value is committed after a selection change.
        if (isset($prop['commitOnSelChange']) AND ($prop['commitOnSelChange'] == 'true')) {
            $ff += 1 << 26;
        }
        $opt['ff'] = $ff;
        // DefaultValue: The default value of a field - that is, the value that the field is set to when the form is reset.
        if (isset($prop['defaultValue'])) {
            $opt['dv'] = $prop['defaultValue'];
        }
        $f = 4; // Default value for annotation flags.
        // Readonly: The read-only characteristic of a field. If a field is read-only, the user can see.
        // the field but cannot change it.
        if (isset($prop['readonly']) AND ($prop['readonly'] == 'true')) {
            $f += 1 << 6;
        }
        // Display: Controls whether the field is hidden or visible on screen and in print.
        if (isset($prop['display'])) {
            if ($prop['display'] == 'display.hidden') {
                $f += 1 << 1;
            } else if ($prop['display'] == 'display.noPrint') {
                $f -= 1 << 2;
            } else if ($prop['display'] == 'display.noView') {
                $f += 1 << 5;
            }
        }
        $opt['f'] = $f;
        // CurrentValueIndices: Reads and writes single or multiple values of a list box or combo box.
        if (isset($prop['currentValueIndices']) AND is_array($prop['currentValueIndices'])) {
            $opt['i'] = $prop['currentValueIndices'];
        }
        // Value: The value of the field data that the user has entered.
        if (isset($prop['value'])) {
            if (is_array($prop['value'])) {
                $opt['opt'] = array();
                foreach ($prop['value'] as $key => $optval) {
                    // ExportValues: An array of strings representing the export values for the field.
                    if (isset($prop['exportValues'][$key])) {
                        $opt['opt'][$key] = array($prop['exportValues'][$key], $prop['value'][$key]);
                    } else {
                        $opt['opt'][$key] = $prop['value'][$key];
                    }
                }
            } else {
                $opt['v'] = $prop['value'];
            }
        }
        // RichValue: This property specifies the text contents and formatting of a rich text field.
        if (isset($prop['richValue'])) {
            $opt['rv'] = $prop['richValue'];
        }
        // SubmitName: If nonempty, used during form submission instead of name. Only applicable if
        // submitting in HTML format (that is, URL-encoded).
        if (isset($prop['submitName'])) {
            $opt['tm'] = $prop['submitName'];
        }
        // Name: Fully qualified field name.
        if (isset($prop['name'])) {
            $opt['t'] = $prop['name'];
        }
        // UserName: The user name (short description string) of the field.
        if (isset($prop['userName'])) {
            $opt['tu'] = $prop['userName'];
        }
        // Highlight: Defines how a button reacts when a user clicks it.
        if (isset($prop['highlight'])) {
            switch ($prop['highlight']) {
                case 'none':
                case 'highlight.n': {
                    $opt['h'] = 'N';
                    break;
                }
                case 'invert':
                case 'highlight.i': {
                    $opt['h'] = 'i';
                    break;
                }
                case 'push':
                case 'highlight.p': {
                    $opt['h'] = 'P';
                    break;
                }
                case 'outline':
                case 'highlight.o': {
                    $opt['h'] = 'O';
                    break;
                }
            }
        }
        return $opt;
    }

    /**
     * Set default properties for form fields.
     */
    public function setformdefaultprop($prop = array()) {
        $this->defaultformprop = $prop;
    }

    /**
     * Return the default properties for form fields.
     */
    public function getformdefaultprop() {
        return $this->defaultformprop;
    }

    /**
     * Creates a text field
     */
    public function textfield($name, $w, $h, $prop = array(), $opt = array(), $x = '', $y = '', $js = false) {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        if ($js) {
            $this->_addfield('text', $name, $x, $y, $w, $h, $prop);
            return;
        }
        // Get default style.
        $prop = array_merge($this->getformdefaultprop(), $prop);
        // Get annotation data.
        $popt = $this->getannotoptfromjsprop($prop);
        // Set default appearance stream.
        $this->annotationfonts[$this->currentfont['fontkey']] = $this->currentfont['i'];
        $fontstyle = sprintf('/F%d %F Tf %s', $this->currentfont['i'], $this->fontsizept, $this->textcolor);
        $popt['da'] = $fontstyle;
        // Build appearance stream.
        $popt['ap'] = array();
        $popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
        $text = '';
        if (isset($prop['value']) AND !empty($prop['value'])) {
            $text = $prop['value'];
        } else if (isset($opt['v']) AND !empty($opt['v'])) {
            $text = $opt['v'];
        }
        $tmpid = $this->starttemplate($w, $h, false);
        $this->multicell($w, $h, $text, 0, '', false, 0, 0, 0, true, 0, false, true, 0, 'T', false);
        $this->endtemplate();
        --$this->n;
        $popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
        unset($this->xobjects[$tmpid]);
        $popt['ap']['n'] .= 'Q EMC';
        // Merge options.
        $opt = array_merge($popt, $opt);
        // Remove some conflicting options.
        unset($opt['bs']);
        // Set remaining annotation data.
        $opt['Subtype'] = 'Widget';
        $opt['ft'] = 'Tx';
        $opt['t'] = $name;
        // Additional annotation's parameters (check _putannotsobj() method).
        unset($opt['mk']['ca']);
        unset($opt['mk']['rc']);
        unset($opt['mk']['ac']);
        unset($opt['mk']['i']);
        unset($opt['mk']['ri']);
        unset($opt['mk']['ix']);
        unset($opt['mk']['if']);
        unset($opt['mk']['tp']);
        $this->annotation($x, $y, $w, $h, $name, $opt, 0);
        if ($this->rtl) {
            $this->x -= $w;
        } else {
            $this->x += $w;
        }
    }

    /**
     * Creates a radiobutton field.
     */
    public function radiobutton($name, $w, $prop = array(), $opt = array(), $onvalue = 'On', $checked = false,
                                $x = '', $y = '', $js = false) {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($w, $x, $y);
        if ($js) {
            $this->_addfield('radiobutton', $name, $x, $y, $w, $w, $prop);
            return;
        }
        if ($this->empty_string($onvalue)) {
            $onvalue = 'On';
        }
        if ($checked) {
            $defval = $onvalue;
        } else {
            $defval = 'Off';
        }
        // Set font.
        $font = 'zapfdingbats';
        if ($this->pdfamode) {
            // All fonts must be embedded.
            $font = 'pdfa'.$font;
        }
        $this->addfont($font);
        $tmpfont = $this->getfontbuffer($font);
        // Set data for parent group.
        if (!isset($this->radiobuttongroups[$this->page])) {
            $this->radiobuttongroups[$this->page] = array();
        }
        if (!isset($this->radiobuttongroups[$this->page][$name])) {
            $this->radiobuttongroups[$this->page][$name] = array();
            ++$this->n;
            $this->radiobuttongroups[$this->page][$name]['n'] = $this->n;
            $this->radiogroups[] = $this->n;
        }
        $kid = ($this->n + 1);
        // Save object ID to be added on Kids entry on parent object.
        $this->radiobuttongroups[$this->page][$name][] = array('kid' => $kid, 'def' => $defval);
        // Get default style.
        $prop = array_merge($this->getformdefaultprop(), $prop);
        $prop['NoToggleToOff'] = 'true';
        $prop['Radio'] = 'true';
        $prop['borderStyle'] = 'inset';
        // Get annotation data.
        $popt = $this->getannotoptfromjsprop($prop);
        // Set additional default options.
        $this->annotationfonts[$tmpfont['fontkey']] = $tmpfont['i'];
        $fontstyle = sprintf('/F%d %F Tf %s', $tmpfont['i'], $this->fontsizept, $this->textcolor);
        $popt['da'] = $fontstyle;
        // Build appearance stream.
        $popt['ap'] = array();
        $popt['ap']['n'] = array();
        $fy = (($w - ((($tmpfont['desc']['Ascent'] - $tmpfont['desc']['Descent']) *
                $this->fontsizept / 1000) / $this->k)) * $this->k);
        $popt['ap']['n'][$onvalue] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(108).') Tj ET Q',
                                     $this->textcolor, $tmpfont['i'], $this->fontsizept, 0, $fy);
        $popt['ap']['n']['Off'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(109).') Tj ET Q',
                                  $this->textcolor, $tmpfont['i'], $this->fontsizept, 0, $fy);
        if (!isset($popt['mk'])) {
            $popt['mk'] = array();
        }
        $popt['mk']['ca'] = '(l)';
        // Merge options.
        $opt = array_merge($popt, $opt);
        // Set remaining annotation data.
        $opt['Subtype'] = 'Widget';
        $opt['ft'] = 'Btn';
        if ($checked) {
            $opt['v'] = array('/'.$onvalue);
            $opt['as'] = $onvalue;
        } else {
            $opt['as'] = 'Off';
        }
        // Store readonly flag.
        if (!isset($this->radiobuttongroups[$this->page][$name]['#readonly#'])) {
            $this->radiobuttongroups[$this->page][$name]['#readonly#'] = false;
        }
        $this->radiobuttongroups[$this->page][$name]['#readonly#'] |= ($opt['f'] & 64);
        $this->annotation($x, $y, $w, $w, $name, $opt, 0);
        if ($this->rtl) {
            $this->x -= $w;
        } else {
            $this->x += $w;
        }
    }

    /**
     * Creates a List-box field
     */
    public function listbox($name, $w, $h, $values, $prop = array(), $opt = array(), $x = '', $y = '', $js = false) {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        if ($js) {
            $this->_addfield('listbox', $name, $x, $y, $w, $h, $prop);
            $s = '';
            foreach ($values as $value) {
                if (is_array($value)) {
                    $s .= ',[\''.addslashes($value[1]).'\',\''.addslashes($value[0]).'\']';
                } else {
                    $s .= ',[\''.addslashes($value).'\',\''.addslashes($value).'\']';
                }
            }
            $this->javascript .= 'f'.$name.'.setItems('.substr($s, 1).');'."\n";
            return;
        }
        // Get default style.
        $prop = array_merge($this->getformdefaultprop(), $prop);
        // Get annotation data.
        $popt = $this->getannotoptfromjsprop($prop);
        // Set additional default values.
        $this->annotationfonts[$this->currentfont['fontkey']] = $this->currentfont['i'];
        $fontstyle = sprintf('/F%d %F Tf %s', $this->currentfont['i'], $this->fontsizept, $this->textcolor);
        $popt['da'] = $fontstyle;
        // Build appearance stream.
        $popt['ap'] = array();
        $popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
        $text = '';
        foreach ($values as $item) {
            if (is_array($item)) {
                $text .= $item[1]."\n";
            } else {
                $text .= $item."\n";
            }
        }
        $tmpid = $this->starttemplate($w, $h, false);
        $this->multicell($w, $h, $text, 0, '', false, 0, 0, 0, true, 0, false, true, 0, 'T', false);
        $this->endtemplate();
        --$this->n;
        $popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
        unset($this->xobjects[$tmpid]);
        $popt['ap']['n'] .= 'Q EMC';
        // Merge options.
        $opt = array_merge($popt, $opt);
        // Set remaining annotation data.
        $opt['Subtype'] = 'Widget';
        $opt['ft'] = 'Ch';
        $opt['t'] = $name;
        $opt['opt'] = $values;
        unset($opt['mk']['ca']);
        unset($opt['mk']['rc']);
        unset($opt['mk']['ac']);
        unset($opt['mk']['i']);
        unset($opt['mk']['ri']);
        unset($opt['mk']['ix']);
        unset($opt['mk']['if']);
        unset($opt['mk']['tp']);
        $this->annotation($x, $y, $w, $h, $name, $opt, 0);
        if ($this->rtl) {
            $this->x -= $w;
        } else {
            $this->x += $w;
        }
    }

    /**
     * Creates a Combo-box field
     */
    public function combobox($name, $w, $h, $values, $prop = array(), $opt = array(), $x = '', $y = '', $js = false) {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        if ($js) {
            $this->_addfield('combobox', $name, $x, $y, $w, $h, $prop);
            $s = '';
            foreach ($values as $value) {
                if (is_array($value)) {
                    $s .= ',[\''.addslashes($value[1]).'\',\''.addslashes($value[0]).'\']';
                } else {
                    $s .= ',[\''.addslashes($value).'\',\''.addslashes($value).'\']';
                }
            }
            $this->javascript .= 'f'.$name.'.setItems('.substr($s, 1).');'."\n";
            return;
        }
        // Get default style.
        $prop = array_merge($this->getformdefaultprop(), $prop);
        $prop['Combo'] = true;
        // Get annotation data.
        $popt = $this->getannotoptfromjsprop($prop);
        // Set additional default options.
        $this->annotationfonts[$this->currentfont['fontkey']] = $this->currentfont['i'];
        $fontstyle = sprintf('/F%d %F Tf %s', $this->currentfont['i'], $this->fontsizept, $this->textcolor);
        $popt['da'] = $fontstyle;
        // Build appearance stream.
        $popt['ap'] = array();
        $popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
        $text = '';
        foreach ($values as $item) {
            if (is_array($item)) {
                $text .= $item[1]."\n";
            } else {
                $text .= $item."\n";
            }
        }
        $tmpid = $this->starttemplate($w, $h, false);
        $this->multicell($w, $h, $text, 0, '', false, 0, 0, 0, true, 0, false, true, 0, 'T', false);
        $this->endtemplate();
        --$this->n;
        $popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
        unset($this->xobjects[$tmpid]);
        $popt['ap']['n'] .= 'Q EMC';
        // Merge options.
        $opt = array_merge($popt, $opt);
        // Set remaining annotation data.
        $opt['Subtype'] = 'Widget';
        $opt['ft'] = 'Ch';
        $opt['t'] = $name;
        $opt['opt'] = $values;
        unset($opt['mk']['ca']);
        unset($opt['mk']['rc']);
        unset($opt['mk']['ac']);
        unset($opt['mk']['i']);
        unset($opt['mk']['ri']);
        unset($opt['mk']['ix']);
        unset($opt['mk']['if']);
        unset($opt['mk']['tp']);
        $this->annotation($x, $y, $w, $h, $name, $opt, 0);
        if ($this->rtl) {
            $this->x -= $w;
        } else {
            $this->x += $w;
        }
    }

    /**
     * Creates a checkbox field
     */
    public function checkbox($name, $w, $checked = false, $prop = array(), $opt = array(), $onvalue = 'Yes',
                             $x = '', $y = '', $js = false) {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($w, $x, $y);
        if ($js) {
            $this->_addfield('checkbox', $name, $x, $y, $w, $w, $prop);
            return;
        }
        if (!isset($prop['value'])) {
            $prop['value'] = array('Yes');
        }
        // Get default style.
        $prop = array_merge($this->getformdefaultprop(), $prop);
        $prop['borderStyle'] = 'inset';
        // Get annotation data.
        $popt = $this->getannotoptfromjsprop($prop);
        // Set additional default options.
        $font = 'zapfdingbats';
        if ($this->pdfamode) {
            // All fonts must be embedded.
            $font = 'pdfa'.$font;
        }
        $this->addfont($font);
        $tmpfont = $this->getfontbuffer($font);
        $this->annotationfonts[$tmpfont['fontkey']] = $tmpfont['i'];
        $fontstyle = sprintf('/F%d %F Tf %s', $tmpfont['i'], $this->fontsizept, $this->textcolor);
        $popt['da'] = $fontstyle;
        // Build appearance stream.
        $popt['ap'] = array();
        $popt['ap']['n'] = array();
        $fy = ((($tmpfont['desc']['Ascent'] + $tmpfont['desc']['Descent']) * $this->fontsizept) / (1000 * $this->k));
        $fy = (($w - ((($tmpfont['desc']['Ascent'] - $tmpfont['desc']['Descent']) * $this->fontsizept / 1000) / $this->k))
                * $this->k);
        $popt['ap']['n']['Yes'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(110).') Tj ET Q', $this->textcolor, $tmpfont['i'],
                                  $this->fontsizept, 0, $fy);
        $popt['ap']['n']['Off'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(111).') Tj ET Q', $this->textcolor, $tmpfont['i'],
                                  $this->fontsizept, 0, $fy);
        // Merge options.
        $opt = array_merge($popt, $opt);
        // Set remaining annotation data.
        $opt['Subtype'] = 'Widget';
        $opt['ft'] = 'Btn';
        $opt['t'] = $name;
        if ($this->empty_string($onvalue)) {
            $onvalue = 'Yes';
        }
        $opt['opt'] = array($onvalue);
        if ($checked) {
            $opt['v'] = array('/Yes');
            $opt['as'] = 'Yes';
        } else {
            $opt['v'] = array('/Off');
            $opt['as'] = 'Off';
        }
        $this->annotation($x, $y, $w, $w, $name, $opt, 0);
        if ($this->rtl) {
            $this->x -= $w;
        } else {
            $this->x += $w;
        }
    }

    /**
     * Creates a button field
     */
    public function button($name, $w, $h, $caption, $action, $prop = array(), $opt = array(), $x = '',
                           $y = '', $js = false) {
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        if ($js) {
            $this->_addfield('button', $name, $this->x, $this->y, $w, $h, $prop);
            $this->javascript .= 'f'.$name.".buttonSetCaption('".addslashes($caption)."');\n";
            $this->javascript .= 'f'.$name.".setAction('MouseUp','".addslashes($action)."');\n";
            $this->javascript .= 'f'.$name.".highlight='push';\n";
            $this->javascript .= 'f'.$name.".print=false;\n";
            return;
        }
        // Get default style.
        $prop = array_merge($this->getformdefaultprop(), $prop);
        $prop['Pushbutton'] = 'true';
        $prop['highlight'] = 'push';
        $prop['display'] = 'display.noPrint';
        // Get annotation data.
        $popt = $this->getannotoptfromjsprop($prop);
        $this->annotationfonts[$this->currentfont['fontkey']] = $this->currentfont['i'];
        $fontstyle = sprintf('/F%d %F Tf %s', $this->currentfont['i'], $this->fontsizept, $this->textcolor);
        $popt['da'] = $fontstyle;
        // Build appearance stream.
        $popt['ap'] = array();
        $popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
        $tmpid = $this->starttemplate($w, $h, false);
        $bw = (2 / $this->k); // Border width.
        $border = array(
            'L' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(231)),
            'R' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(51)),
            'T' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(231)),
            'B' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(51)));
        $this->setfillcolor(204);
        $this->cell($w, $h, $caption, $border, 0, 'C', true, '', 1, false, 'T', 'M');
        $this->endtemplate();
        --$this->n;
        $popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
        unset($this->xobjects[$tmpid]);
        $popt['ap']['n'] .= 'Q EMC';
        // Set additional default options.
        if (!isset($popt['mk'])) {
            $popt['mk'] = array();
        }
        $annobjid = ($this->n + 1);
        if (!empty($action) AND !is_array($action)) {
            $annobjid = ($this->n + 2);
        }
        $popt['mk']['ca'] = $this->_textstring($caption, $annobjid);
        $popt['mk']['rc'] = $this->_textstring($caption, $annobjid);
        $popt['mk']['ac'] = $this->_textstring($caption, $annobjid);
        // Merge options.
        $opt = array_merge($popt, $opt);
        // Set remaining annotation data.
        $opt['Subtype'] = 'Widget';
        $opt['ft'] = 'Btn';
        $opt['t'] = $caption;
        $opt['v'] = $name;
        if (!empty($action)) {
            if (is_array($action)) {
                // Form action options as on section 12.7.5 of PDF32000_2008.
                $opt['aa'] = '/D <<';
                $bmode = array('SubmitForm', 'ResetForm', 'ImportData');
                foreach ($action as $key => $val) {
                    if (($key == 'S') AND in_array($val, $bmode)) {
                        $opt['aa'] .= ' /S /'.$val;
                    } else if (($key == 'F') AND (!empty($val))) {
                        $opt['aa'] .= ' /F '.$this->_datastring($val, $annobjid);
                    } else if (($key == 'Fields') AND is_array($val) AND !empty($val)) {
                        $opt['aa'] .= ' /Fields [';
                        foreach ($val as $field) {
                            $opt['aa'] .= ' '.$this->_textstring($field, $annobjid);
                        }
                        $opt['aa'] .= ']';
                    } else if (($key == 'Flags')) {
                        $ff = 0;
                        if (is_array($val)) {
                            foreach ($val as $flag) {
                                switch ($flag) {
                                    case 'Include/Exclude': {
                                        $ff += 1 << 0;
                                        break;
                                    }
                                    case 'IncludeNoValueFields': {
                                        $ff += 1 << 1;
                                        break;
                                    }
                                    case 'ExportFormat': {
                                        $ff += 1 << 2;
                                        break;
                                    }
                                    case 'GetMethod': {
                                        $ff += 1 << 3;
                                        break;
                                    }
                                    case 'SubmitCoordinates': {
                                        $ff += 1 << 4;
                                        break;
                                    }
                                    case 'XFDF': {
                                        $ff += 1 << 5;
                                        break;
                                    }
                                    case 'IncludeAppendSaves': {
                                        $ff += 1 << 6;
                                        break;
                                    }
                                    case 'Includeannotations': {
                                        $ff += 1 << 7;
                                        break;
                                    }
                                    case 'SubmitPDF': {
                                        $ff += 1 << 8;
                                        break;
                                    }
                                    case 'CanonicalFormat': {
                                        $ff += 1 << 9;
                                        break;
                                    }
                                    case 'ExclNonUserAnnots': {
                                        $ff += 1 << 10;
                                        break;
                                    }
                                    case 'ExclFKey': {
                                        $ff += 1 << 11;
                                        break;
                                    }
                                    case 'EmbedForm': {
                                        $ff += 1 << 13;
                                        break;
                                    }
                                }
                            }
                        } else {
                            $ff = intval($val);
                        }
                        $opt['aa'] .= ' /Flags '.$ff;
                    }
                }
                $opt['aa'] .= ' >>';
            } else {
                // Javascript action or raw action command.
                $jsobjid = $this->addjavascriptobject($action);
                $opt['aa'] = '/D '.$jsobjid.' 0 R';
            }
        }
        $this->annotation($x, $y, $w, $h, $name, $opt, 0);
        if ($this->rtl) {
            $this->x -= $w;
        } else {
            $this->x += $w;
        }
    }

    // END FORMS FIELDS.

    /**
     * Add certification signature (DocMDP or UR3)
     * You can set only one signature type
     */
    protected function _putsignature() {
        if ((!$this->sign) OR (!isset($this->signaturedata['certtype']))) {
            return;
        }
        $sigobjid = ($this->sigobjid + 1);
        $out = $this->_getobj($sigobjid)."\n";
        $out .= '<< /Type /Sig';
        $out .= ' /Filter /Adobe.PPKLite';
        $out .= ' /SubFilter /adbe.pkcs7.detached';
        $out .= ' '.$this->byterangestring;
        $out .= ' /Contents<'.str_repeat('0', $this->signaturemaxlength).'>';
        $out .= ' /Reference ['; // Array of signature reference dictionaries.
        $out .= ' << /Type /SigRef';
        if ($this->signaturedata['certtype'] > 0) {
            $out .= ' /transformMethod /DocMDP';
            $out .= ' /transformParams <<';
            $out .= ' /Type /transformParams';
            $out .= ' /P '.$this->signaturedata['certtype'];
            $out .= ' /V /1.2';
        } else {
            $out .= ' /transformMethod /UR3';
            $out .= ' /transformParams <<';
            $out .= ' /Type /transformParams';
            $out .= ' /V /2.2';
            if (!$this->empty_string($this->ur['document'])) {
                $out .= ' /Document['.$this->ur['document'].']';
            }
            if (!$this->empty_string($this->ur['form'])) {
                $out .= ' /Form['.$this->ur['form'].']';
            }
            if (!$this->empty_string($this->ur['signature'])) {
                $out .= ' /Signature['.$this->ur['signature'].']';
            }
            if (!$this->empty_string($this->ur['annots'])) {
                $out .= ' /Annots['.$this->ur['annots'].']';
            }
            if (!$this->empty_string($this->ur['ef'])) {
                $out .= ' /EF['.$this->ur['ef'].']';
            }
            if (!$this->empty_string($this->ur['formex'])) {
                $out .= ' /FormEX['.$this->ur['formex'].']';
            }
        }
        $out .= ' >>';
        $out .= ' >>';
        $out .= ' ]'; // End of reference.
        if (isset($this->signaturedata['info']['Name']) AND
                  !$this->empty_string($this->signaturedata['info']['Name'])) {
            $out .= ' /Name '.$this->_textstring($this->signaturedata['info']['Name'], $sigobjid);
        }
        if (isset($this->signaturedata['info']['Location']) AND
                  !$this->empty_string($this->signaturedata['info']['Location'])) {
            $out .= ' /Location '.$this->_textstring($this->signaturedata['info']['Location'], $sigobjid);
        }
        if (isset($this->signaturedata['info']['Reason']) AND
                  !$this->empty_string($this->signaturedata['info']['Reason'])) {
            $out .= ' /Reason '.$this->_textstring($this->signaturedata['info']['Reason'], $sigobjid);
        }
        if (isset($this->signaturedata['info']['ContactInfo']) AND
                  !$this->empty_string($this->signaturedata['info']['ContactInfo'])) {
            $out .= ' /ContactInfo '.$this->_textstring($this->signaturedata['info']['ContactInfo'], $sigobjid);
        }
        $out .= ' /M '.$this->_datestring($sigobjid, $this->docmodificationtimestamp);
        $out .= ' >>';
        $out .= "\n".'endobj';
        $this->_out($out);
    }

    /**
     * Set User's Rights for PDF Reader
     * WARNING: This is experimental and currently do not work.
     * Check the PDF Reference 8.7.1 transform Methods.
     */
    public function setuserrights(
            $enable=true,
            $document='/FullSave',
            $annots='/Create/Delete/Modify/Copy/Import/Export',
            $form='/Add/Delete/FillIn/Import/Export/SubmitStandalone/SpawnTemplate',
            $signature='/Modify',
            $ef='/Create/Delete/Modify/Import',
            $formex='') {
        $this->ur['enabled'] = $enable;
        $this->ur['document'] = $document;
        $this->ur['annots'] = $annots;
        $this->ur['form'] = $form;
        $this->ur['signature'] = $signature;
        $this->ur['ef'] = $ef;
        $this->ur['formex'] = $formex;
        if (!$this->sign) {
            $this->setsignature('', '', '', '', 0, array());
        }
    }

    /**
     * Enable document signature (requires the OpenSSL Library).
     * The digital signature improve document authenticity and integrity and allows o enable extra features on
       Acrobat Reader.
     */
    public function setsignature($signingcert = '', $privatekey = '', $privatekeypassword = '', $extracerts = '',
                                 $certtype = 2, $info = array()) {
        $this->sign = true;
        ++$this->n;
        $this->sigobjid = $this->n; // Signature widget.
        ++$this->n; // Signature object.
        $this->signaturedata = array();
        if (strlen($signingcert) == 0) {
            $signingcert = 'file://'.dirname(__FILE__).'/tcpdf.crt';
            $privatekeypassword = 'tcpdfdemo';
        }
        if (strlen($privatekey) == 0) {
            $privatekey = $signingcert;
        }
        $this->signaturedata['signcert'] = $signingcert;
        $this->signaturedata['privkey'] = $privatekey;
        $this->signaturedata['password'] = $privatekeypassword;
        $this->signaturedata['extracerts'] = $extracerts;
        $this->signaturedata['certtype'] = $certtype;
        $this->signaturedata['info'] = $info;
    }

    /**
     * Set the digital signature appearance (a cliccable rectangle area to get signature properties)
     */
    public function setsignatureappearance($x = 0, $y = 0, $w = 0, $h = 0, $page = -1) {
        $this->signatureappearance = $this->getsignatureappearancearray($x, $y, $w, $h, $page);
    }

    /**
     * Add an empty digital signature appearance (a cliccable rectangle area to get signature properties)
     */
    public function addemptysignatureappearance($x = 0, $y = 0, $w = 0, $h = 0, $page = -1) {
        ++$this->n;
        $this->emptysignatureappearance[] = array('objid' => $this->n) +
        $this->getsignatureappearancearray($x, $y, $w, $h, $page);
    }

    /**
     * Get the array that defines the signature appearance (page and rectangle coordinates).
     */
    protected function getsignatureappearancearray($x = 0, $y = 0, $w = 0, $h = 0, $page = -1) {
        $sigapp = array();
        if (($page < 1) OR ($page > $this->numpages)) {
            $sigapp['page'] = $this->page;
        } else {
            $sigapp['page'] = intval($page);
        }
        $a = $x * $this->k;
        $b = $this->pagedim[($sigapp['page'])]['h'] - (($y + $h) * $this->k);
        $c = $w * $this->k;
        $d = $h * $this->k;
        $sigapp['rect'] = sprintf('%F %F %F %F', $a, $b, ($a + $c), ($b + $d));
        return $sigapp;
    }

    /**
     * Create a new page group.
     * NOTE: call this function before calling addpage()
     */
    public function startpagegroup($page = '') {
        if (empty($page)) {
            $page = $this->page + 1;
        }
        $this->newpagegroup[$page] = count($this->newpagegroup) + 1;
    }

    /**
     * Set the starting page number.
     */
    public function setstartingpagenumber($num = 1) {
        $this->startingpagenumber = max(0, intval($num));
    }

    /**
     * Returns the string alias used right align page numbers.
     * If the current font is unicode type, the returned string wil contain an additional open curly brace.
     */

    public function getaliasrightshift() {
        // Calculate aproximatively the ratio between widths of aliases and replacements.
        $ref = '{'.$this->aliasrightshift.'}{'.$this->aliastotpages.'}{'.$this->aliasnumpage.'}';
        $rep = str_repeat(' ', $this->getnumchars($ref));
        $wdiff = max(1, ($this->getstringwidth($ref) / $this->getstringwidth($rep)));
        $sdiff = sprintf('%F', $wdiff);
        $alias = $this->aliasrightshift.$sdiff.'}';
        if ($this->isunicodefont()) {
            $alias = '{'.$alias;
        }
        return $alias;
    }

    /**
     * Returns the string alias used for the total number of pages.
     * If the current font is unicode type, the returned string is surrounded by additional curly braces.
     * This alias will be replaced by the total number of pages in the document.
     */
    public function getaliasnbpages() {
        if ($this->isunicodefont()) {
            return '{'.$this->aliastotpages.'}';
        }
        return $this->aliastotpages;
    }

    /**
     * Returns the string alias used for the page number.
     * If the current font is unicode type, the returned string is surrounded by additional curly braces.
     * This alias will be replaced by the page number.
     */
    public function getaliasnumpage() {
        if ($this->isunicodefont()) {
            return '{'.$this->aliasnumpage.'}';
        }
        return $this->aliasnumpage;
    }

    /**
     * Return the alias for the total number of pages in the current page group.
     * If the current font is unicode type, the returned string is surrounded by additional curly braces.
     * This alias will be replaced by the total number of pages in this group.
     */
    public function getpagegroupalias() {
        if ($this->isunicodefont()) {
            return '{'.$this->aliasgrouptotpages.'}';
        }
        return $this->aliasgrouptotpages;
    }

    /**
     * Return the alias for the page number on the current page group.
     * If the current font is unicode type, the returned string is surrounded by additional curly braces.
     * This alias will be replaced by the page number (relative to the belonging group).
     */
    public function getpagenumgroupalias() {
        if ($this->isunicodefont()) {
            return '{'.$this->aliasgroupnumpage.'}';
        }
        return $this->aliasgroupnumpage;
    }

    /**
     * Return the current page in the group.
     * @return current page in the group
     */
    public function getgrouppageno() {
        return $this->pagegroups[$this->currpagegroup];
    }

    /**
     * Returns the current group page number formatted as a string.
     * @see PaneNo(), formatpagenumber()
     */
    public function getgrouppagenoformatted() {
        return $this->formatpagenumber($this->getgrouppageno());
    }

    /**
     * Format the page numbers.
     * This method can be overriden for custom formats.
     */
    protected function formatpagenumber($num) {
        return number_format((float)$num, 0, '', '.');
    }

    /**
     * Format the page numbers on the Table Of Content.
     * This method can be overriden for custom formats.
     * @see addtoc(), addhtmltoc()
     */
    protected function formattocpagenumber($num) {
        return number_format((float)$num, 0, '', '.');
    }

    /**
     * Returns the current page number formatted as a string.
     * @see PaneNo(), formatpagenumber()
     */
    public function pagenoformatted() {
        return $this->formatpagenumber($this->pageno());
    }

    /**
     * Put pdf layers.
     */
    protected function _putocg() {
        if (empty($this->pdflayers)) {
            return;
        }
        foreach ($this->pdflayers as $key => $layer) {
             $this->pdflayers[$key]['objid'] = $this->_newobj();
             $out = '<< /Type /OCG';
             $out .= ' /Name '.$this->_textstring($layer['name'], $this->pdflayers[$key]['objid']);
             $out .= ' /Usage <<';
             $out .= ' /Print <</PrintState /'.($layer['print'] ? 'ON' : 'OFF').'>>';
             $out .= ' /View <</ViewState /'.($layer['view'] ? 'ON' : 'OFF').'>>';
             $out .= ' >> >>';
             $out .= "\n".'endobj';
             $this->_out($out);
        }
    }

    /**
     * Start a new pdf layer.
     */
    public function startlayer($name = '', $print = true, $view = true) {
        $layer = sprintf('LYR%03d', (count($this->pdflayers) + 1));
        if (empty($name)) {
            $name = $layer;
        } else {
            $name = preg_replace('/[^a-zA-Z0-9_\-]/', '', $name);
        }
        $this->pdflayers[] = array('layer' => $layer, 'name' => $name, 'print' => $print, 'view' => $view);
        $this->openmarkedcontent = true;
        $this->_out('/OC /'.$layer.' BDC');
    }

    /**
     * End the current PDF layer.
     */
    public function endlayer() {
        if ($this->openmarkedcontent) {
            // Close existing open marked-content layer.
            $this->_out('EMC');
            $this->openmarkedcontent = false;
        }
    }

    /**
     * Set the visibility of the successive elements.
     * This can be useful, for instance, to put a background
     * image or color that will show on screen but won't print.
     */
    public function setvisibility($v) {
        $this->endlayer();
        switch($v) {
            case 'print': {
                $this->startlayer('Print', true, false);
                break;
            }
            case 'view':
            case 'screen': {
                $this->startlayer('View', false, true);
                break;
            }
            case 'all': {
                $this->_out('');
                break;
            }
            default: {
                $this->errord('Incorrect visibility: '.$v);
                break;
            }
        }
    }

    /**
     * Add transparency parameters to the current extgstate
     */
    protected function addextgstate($parms) {
        if ($this->pdfamode) {
            // Transparencies are not allowed in PDF/A mode.
            return;
        }
        // Check if this ExtGState already exist.
        foreach ($this->extgstates as $i => $ext) {
            if ($ext['parms'] == $parms) {
                if ($this->inxobj) {
                    // We are inside an XObject template.
                    $this->xobjects[$this->xobjid]['extgstates'][$i] = $ext;
                }
                // Return reference to existing ExtGState.
                return $i;
            }
        }
        $n = (count($this->extgstates) + 1);
        $this->extgstates[$n] = array('parms' => $parms);
        if ($this->inxobj) {
            // We are inside an XObject template.
            $this->xobjects[$this->xobjid]['extgstates'][$n] = $this->extgstates[$n];
        }
        return $n;
    }

    /**
     * Add an extgstate
     */
    protected function setextgstate($gs) {
        if ($this->pdfamode) {
            // Transparency is not allowed in PDF/A mode.
            return;
        }
        $this->_out(sprintf('/GS%d gs', $gs));
    }

    /**
     * Put extgstates for object transparency
     */
    protected function _putextgstates() {
        foreach ($this->extgstates as $i => $ext) {
            $this->extgstates[$i]['n'] = $this->_newobj();
            $out = '<< /Type /ExtGState';
            foreach ($ext['parms'] as $k => $v) {
                if (is_float($v)) {
                    $v = sprintf('%F', $v);
                } else if ($v === true) {
                    $v = 'true';
                } else if ($v === false) {
                    $v = 'false';
                }
                $out .= ' /'.$k.' '.$v;
            }
            $out .= ' >>';
            $out .= "\n".'endobj';
            $this->_out($out);
        }
    }

    /**
     * Set overprint mode for stroking (OP) and non-stroking (op) painting operations.
     * (Check the "Entries in a Graphics State Parameter Dictionary" on PDF 32000-1:2008).
     */
    public function setoverprint($stroking = true, $nonstroking = '', $mode = 0) {
        $stroking = $stroking ? true : false;
        if ($this->empty_string($nonstroking)) {
            // Default value if not set.
            $nonstroking = $stroking;
        } else {
            $nonstroking = $nonstroking ? true : false;
        }
        if (($mode != 0) AND ($mode != 1)) {
            $mode = 0;
        }
        $this->overprint = array('OP' => $stroking, 'op' => $nonstroking, 'OPM' => $mode);
        $gs = $this->addextgstate($this->overprint);
        $this->setextgstate($gs);
    }

    /**
     * Get the overprint mode array (OP, op, OPM).
     * (Check the "Entries in a Graphics State Parameter Dictionary" on PDF 32000-1:2008).
     */
    public function getoverprint() {
        return $this->overprint;
    }

    /**
     * Set alpha for stroking (CA) and non-stroking (ca) operations.
     */
    public function setalpha($stroking = 1, $bm = 'Normal', $nonstroking = '', $ais = false) {
        if ($this->pdfamode) {
            // Transparency is not allowed in PDF/A mode.
            return;
        }
        $stroking = floatval($stroking);
        if ($this->empty_string($nonstroking)) {
            // Default value if not set.
            $nonstroking = $stroking;
        } else {
            $nonstroking = floatval($nonstroking);
        }
        if ($bm[0] == '/') {
            // Remove trailing slash.
            $bm = substr($bm, 1);
        }
        if (!in_array($bm, array('Normal', 'Multiply', 'Screen', 'Overlay', 'Darken', 'Lighten', 'ColorDodge', 'ColorBurn',
                                 'HardLight', 'SoftLight', 'Difference', 'Exclusion', 'Hue', 'Saturation', 'Color',
                                 'Luminosity'))) {
            $bm = 'Normal';
        }
        $ais = $ais ? true : false;
        $this->alpha = array('CA' => $stroking, 'ca' => $nonstroking, 'BM' => '/'.$bm, 'AIS' => $ais);
        $gs = $this->addextgstate($this->alpha);
        $this->setextgstate($gs);
    }

    /**
     * Get the alpha mode array (CA, ca, BM, AIS).
     * (Check the "Entries in a Graphics State Parameter Dictionary" on PDF 32000-1:2008).
     */
    public function getalpha() {
        return $this->alpha;
    }

    /**
     * Set the default JPEG compression quality (1-100)
     */
    public function setjpegquality($quality) {
        if (($quality < 1) OR ($quality > 100)) {
            $quality = 75;
        }
        $this->jpegquality = intval($quality);
    }

    /**
     * Set the default number of columns in a row for HTML tables.
     */
    public function setdefaulttablecolumns($cols = 4) {
        $this->defaulttablecolumns = intval($cols);
    }

    /**
     * Set the height of the cell (line height) respect the font height.
     */
    public function setcellheightratio($h) {
        $this->cellheightratio = $h;
    }

    /**
     * return the height of cell repect font height.
     */
    public function getcellheightratio() {
        return $this->cellheightratio;
    }

    /**
     * Set the PDF version (check PDF reference for valid values).
     */
    public function setpdfversion($version='1.7') {
        if ($this->pdfamode) {
            // PDF/A mode.
            $this->pdfversion = '1.4';
        } else {
            $this->pdfversion = $version;
        }
    }

    /**
     * Set the viewer preferences dictionary controlling the way the document is to be presented on the screen
       or in print.
     */
    public function setviewerpreferences($preferences) {
        $this->viewerpreferences = $preferences;
    }

    /**
     * Paints color transition registration bars
     */
    public function colorregistrationbar($x, $y, $w, $h, $transition = true, $vertical = false,
                                         $colors = 'A, R, G, B, C, M, Y, K') {
        $bars = explode(',', $colors);
        $numbars = count($bars); // Number of bars to print.
        // Set bar measures.
        if ($vertical) {
            $coords = array(0, 0, 0, 1);
            $wb = $w / $numbars; // Bar width.
            $hb = $h; // Bar height.
            $xd = $wb; // Delta x.
            $yd = 0; // Delta y.
        } else {
            $coords = array(1, 0, 0, 0);
            $wb = $w; // Bar width.
            $hb = $h / $numbars; // Bar height.
            $xd = 0; // Delta x.
            $yd = $hb; // Delta y.
        }
        $xb = $x;
        $yb = $y;
        foreach ($bars as $col) {
            switch ($col) {
                // Set transition colors.
                case 'A': { // BLACK.
                    $cola = array(255);
                    $colb = array(0);
                    break;
                }
                case 'W': { // WHITE.
                    $cola = array(0);
                    $colb = array(255);
                    break;
                }
                case 'R': { // R.
                    $cola = array(255, 255, 255);
                    $colb = array(255, 0, 0);
                    break;
                }
                case 'G': { // G.
                    $cola = array(255, 255, 255);
                    $colb = array(0, 255, 0);
                    break;
                }
                case 'B': { // B.
                    $cola = array(255, 255, 255);
                    $colb = array(0, 0, 255);
                    break;
                }
                case 'C': { // C.
                    $cola = array(0, 0, 0, 0);
                    $colb = array(100, 0, 0, 0);
                    break;
                }
                case 'M': { // M.
                    $cola = array(0, 0, 0, 0);
                    $colb = array(0, 100, 0, 0);
                    break;
                }
                case 'Y': { // Y.
                    $cola = array(0, 0, 0, 0);
                    $colb = array(0, 0, 100, 0);
                    break;
                }
                case 'K': { // K.
                    $cola = array(0, 0, 0, 0);
                    $colb = array(0, 0, 0, 100);
                    break;
                }
                default: { // GRAY.
                    $cola = array(255);
                    $colb = array(0);
                    break;
                }
            }
            if ($transition) {
                // Color gradient.
                $this->lineargradient($xb, $yb, $wb, $hb, $cola, $colb, $coords);
            } else {
                // Color rectangle.
                $this->setfillcolorarray($colb);
                $this->rect($xb, $yb, $wb, $hb, 'F', array());
            }
            $xb += $xd;
            $yb += $yd;
        }
    }

    /**
     * Paints crop marks.
     */
    public function cropmark($x, $y, $w, $h, $type ='T, R, B, L', $color = array(0, 0, 0)) {
        $this->setlinestyle(array('width' => (0.5 / $this->k), 'cap' => 'butt', 'join' => 'miter',
                            'dash' => 0, 'color' => $color));
        $type = strtoupper($type);
        $type = preg_replace('/[^A-Z\-\,]*/', '', $type);
        // Split type in single components.
        $type = str_replace('-', ',', $type);
        $type = str_replace('TL', 'T,L', $type);
        $type = str_replace('TR', 'T,R', $type);
        $type = str_replace('BL', 'F,L', $type);
        $type = str_replace('BR', 'F,R', $type);
        $type = str_replace('A', 'T,L', $type);
        $type = str_replace('B', 'T,R', $type);
        $type = str_replace('T,RO', 'BO', $type);
        $type = str_replace('C', 'F,L', $type);
        $type = str_replace('D', 'F,R', $type);
        $crops = explode(',', strtoupper($type));
        // Remove duplicates.
        $crops = array_unique($crops);
        $dw = ($w / 4); // Horizontal space to leave before the intersection point.
        $dh = ($h / 4); // Vertical space to leave before the intersection point.
        foreach ($crops as $crop) {
            switch ($crop) {
                case 'T':
                case 'TOP': {
                    $x1 = $x;
                    $y1 = ($y - $h);
                    $x2 = $x;
                    $y2 = ($y - $dh);
                    break;
                }
                case 'F':
                case 'BOTTOM': {
                    $x1 = $x;
                    $y1 = ($y + $dh);
                    $x2 = $x;
                    $y2 = ($y + $h);
                    break;
                }
                case 'L':
                case 'LEFT': {
                    $x1 = ($x - $w);
                    $y1 = $y;
                    $x2 = ($x - $dw);
                    $y2 = $y;
                    break;
                }
                case 'R':
                case 'RIGHT': {
                    $x1 = ($x + $dw);
                    $y1 = $y;
                    $x2 = ($x + $w);
                    $y2 = $y;
                    break;
                }
            }
            $this->line($x1, $y1, $x2, $y2);
        }
    }

    /**
     * Paints a registration mark
     * @public
     */
    public function registrationmark($x, $y, $r, $double = false, $cola = array(0, 0, 0),
                                     $colb = array(255, 255, 255)) {
        $linestyle = array('width' => (0.5 / $this->k), 'cap' => 'butt', 'join' => 'miter', 'dash' => 0,
                           'color' => $cola);
        $this->setfillcolorarray($cola);
        $this->piesector($x, $y, $r, 90, 180, 'F');
        $this->piesector($x, $y, $r, 270, 360, 'F');
        $this->circle($x, $y, $r, 0, 360, 'C', $linestyle, array(), 8);
        if ($double) {
            $r2 = $r * 0.5;
            $this->setfillcolorarray($colb);
            $this->piesector($x, $y, $r2, 90, 180, 'F');
            $this->piesector($x, $y, $r2, 270, 360, 'F');
            $this->setfillcolorarray($cola);
            $this->piesector($x, $y, $r2, 0, 90, 'F');
            $this->piesector($x, $y, $r2, 180, 270, 'F');
            $this->circle($x, $y, $r2, 0, 360, 'C', $linestyle, array(), 8);
        }
    }

    /**
     * Paints a linear colour gradient.
     */
    public function lineargradient($x, $y, $w, $h, $col1 = array(), $col2 = array(), $coords = array(0, 0, 1, 0)) {
        $this->clip($x, $y, $w, $h);
        $this->gradient(2, $coords, array(array('color' => $col1, 'offset' => 0, 'exponent' => 1),
                        array('color' => $col2, 'offset' => 1, 'exponent' => 1)), array(), false);
    }

    /**
     * Paints a radial colour gradient.
     */
    public function radialgradient($x, $y, $w, $h, $col1 = array(), $col2 = array(),
                                   $coords = array(0.5, 0.5, 0.5, 0.5, 1)) {
        $this->clip($x, $y, $w, $h);
        $this->gradient(3, $coords, array(array('color' => $col1, 'offset' => 0, 'exponent' => 1),
                        array('color' => $col2, 'offset' => 1, 'exponent' => 1)), array(), false);
    }

    /**
     * Paints a coons patch mesh.
     */
    public function coonspatchmesh($x, $y, $w, $h, $col1 = array(), $col2 = array(), $col3 = array(), $col4 = array(),
                                   $coords = array(0.00, 0.0, 0.33, 0.00, 0.67, 0.00, 1.00, 0.00, 1.00, 0.33, 1.00, 0.67,
                                   1.00, 1.00, 0.67, 1.00, 0.33, 1.00, 0.00, 1.00, 0.00, 0.67, 0.00, 0.33),
                                   $coordsmin = 0, $coordsmax = 1, $antialias = false) {
        if ($this->pdfamode) {
            return;
        }
        $this->clip($x, $y, $w, $h);
        $n = count($this->gradients) + 1;
        $this->gradients[$n] = array();
        $this->gradients[$n]['type'] = 6; // Coons patch mesh.
        $this->gradients[$n]['coords'] = array();
        $this->gradients[$n]['antialias'] = $antialias;
        $this->gradients[$n]['colors'] = array();
        $this->gradients[$n]['transparency'] = false;
        // Check the coords array if it is the simple array or the multi patch array.
        if (!isset($coords[0]['f'])) {
            // Simple array -> convert to multi patch array.
            if (!isset($col1[1])) {
                $col1[1] = $col1[2] = $col1[0];
            }
            if (!isset($col2[1])) {
                $col2[1] = $col2[2] = $col2[0];
            }
            if (!isset($col3[1])) {
                $col3[1] = $col3[2] = $col3[0];
            }
            if (!isset($col4[1])) {
                $col4[1] = $col4[2] = $col4[0];
            }
            $patcharray[0]['f'] = 0;
            $patcharray[0]['points'] = $coords;
            $patcharray[0]['colors'][0]['r'] = $col1[0];
            $patcharray[0]['colors'][0]['g'] = $col1[1];
            $patcharray[0]['colors'][0]['b'] = $col1[2];
            $patcharray[0]['colors'][1]['r'] = $col2[0];
            $patcharray[0]['colors'][1]['g'] = $col2[1];
            $patcharray[0]['colors'][1]['b'] = $col2[2];
            $patcharray[0]['colors'][2]['r'] = $col3[0];
            $patcharray[0]['colors'][2]['g'] = $col3[1];
            $patcharray[0]['colors'][2]['b'] = $col3[2];
            $patcharray[0]['colors'][3]['r'] = $col4[0];
            $patcharray[0]['colors'][3]['g'] = $col4[1];
            $patcharray[0]['colors'][3]['b'] = $col4[2];
        } else {
            // Multi patch array.
            $patcharray = $coords;
        }
        $bpcd = 65535;
        // Build the data stream.
        $this->gradients[$n]['stream'] = '';
        $countpatch = count($patcharray);
        for ($i = 0; $i < $countpatch; ++$i) {
            $this->gradients[$n]['stream'] .= chr($patcharray[$i]['f']); // Start with the edge flag as 8 bit.
            $countpoints = count($patcharray[$i]['points']);
            for ($j = 0; $j < $countpoints; ++$j) {
                // Each point as 16 bit.
                $patcharray[$i]['points'][$j] = (($patcharray[$i]['points'][$j] - $coordsmin) /
                                                  ($coordsmax - $coordsmin)) * $bpcd;
                if ($patcharray[$i]['points'][$j] < 0) {
                    $patcharray[$i]['points'][$j] = 0;
                }
                if ($patcharray[$i]['points'][$j] > $bpcd) {
                    $patcharray[$i]['points'][$j] = $bpcd;
                }
                $this->gradients[$n]['stream'] .= chr(floor($patcharray[$i]['points'][$j] / 256));
                $this->gradients[$n]['stream'] .= chr(floor($patcharray[$i]['points'][$j] % 256));
            }
            $countcols = count($patcharray[$i]['colors']);
            for ($j = 0; $j < $countcols; ++$j) {
                // Each color component as 8 bit.
                $this->gradients[$n]['stream'] .= chr($patcharray[$i]['colors'][$j]['r']);
                $this->gradients[$n]['stream'] .= chr($patcharray[$i]['colors'][$j]['g']);
                $this->gradients[$n]['stream'] .= chr($patcharray[$i]['colors'][$j]['b']);
            }
        }
        // Paint the gradient.
        $this->_out('/Sh'.$n.' sh');
        // Restore previous Graphic State.
        $this->_out('Q');
        if ($this->inxobj) {
            // We are inside an XObject template.
            $this->xobjects[$this->xobjid]['gradients'][$n] = $this->gradients[$n];
        }
    }

    /**
     * Set a rectangular clipping area.
     */
    protected function clip($x, $y, $w, $h) {
        if ($this->rtl) {
            $x = $this->w - $x - $w;
        }
        // Save current Graphic State.
        $s = 'q';
        // Set clipping area.
        $s .= sprintf(' %F %F %F %F re W n', $x * $this->k, ($this->h - $y) * $this->k, $w * $this->k, - $h * $this->k);
        // Set up transformation matrix for gradient.
        $s .= sprintf(' %F 0 0 %F %F %F cm', $w * $this->k, $h * $this->k, $x * $this->k, ($this->h - ($y + $h)) * $this->k);
        $this->_out($s);
    }

    /**
     * output gradient.
     */
    public function gradient($type, $coords, $stops, $background = array(), $antialias = false) {
        if ($this->pdfamode) {
            return;
        }
        $n = count($this->gradients) + 1;
        $this->gradients[$n] = array();
        $this->gradients[$n]['type'] = $type;
        $this->gradients[$n]['coords'] = $coords;
        $this->gradients[$n]['antialias'] = $antialias;
        $this->gradients[$n]['colors'] = array();
        $this->gradients[$n]['transparency'] = false;
        // Color space.
        $numcolspace = count($stops[0]['color']);
        $bcolor = array_values($background);
        switch($numcolspace) {
            case 4: { // CMYK.
                $this->gradients[$n]['colspace'] = 'DeviceCMYK';
                if (!empty($background)) {
                    $this->gradients[$n]['background'] = sprintf('%F %F %F %F', $bcolor[0] / 100, $bcolor[1] / 100,
                                                         $bcolor[2] / 100, $bcolor[3] / 100);
                }
                break;
            }
            case 3: { // RGB.
                $this->gradients[$n]['colspace'] = 'DeviceRGB';
                if (!empty($background)) {
                    $this->gradients[$n]['background'] = sprintf('%F %F %F', $bcolor[0] / 255, $bcolor[1] / 255,
                                                         $bcolor[2] / 255);
                }
                break;
            }
            case 1: { // Gray scale.
                $this->gradients[$n]['colspace'] = 'DeviceGray';
                if (!empty($background)) {
                    $this->gradients[$n]['background'] = sprintf('%F', $bcolor[0] / 255);
                }
                break;
            }
        }
        $numstops = count($stops);
        $laststopid = $numstops - 1;
        foreach ($stops as $key => $stop) {
            $this->gradients[$n]['colors'][$key] = array();
            // Offset represents a location along the gradient vector.
            if (isset($stop['offset'])) {
                $this->gradients[$n]['colors'][$key]['offset'] = $stop['offset'];
            } else {
                if ($key == 0) {
                    $this->gradients[$n]['colors'][$key]['offset'] = 0;
                } else if ($key == $laststopid) {
                    $this->gradients[$n]['colors'][$key]['offset'] = 1;
                } else {
                    $offsetstep = (1 - $this->gradients[$n]['colors'][($key - 1)]['offset']) / ($numstops - $key);
                    $this->gradients[$n]['colors'][$key]['offset'] =
                    $this->gradients[$n]['colors'][($key - 1)]['offset'] + $offsetstep;
                }
            }
            if (isset($stop['opacity'])) {
                $this->gradients[$n]['colors'][$key]['opacity'] = $stop['opacity'];
                if ((!$this->pdfamode) AND ($stop['opacity'] < 1)) {
                    $this->gradients[$n]['transparency'] = true;
                }
            } else {
                $this->gradients[$n]['colors'][$key]['opacity'] = 1;
            }
            // Exponent for the exponential interpolation function.
            if (isset($stop['exponent'])) {
                $this->gradients[$n]['colors'][$key]['exponent'] = $stop['exponent'];
            } else {
                $this->gradients[$n]['colors'][$key]['exponent'] = 1;
            }
            // Set colors.
            $color = array_values($stop['color']);
            switch($numcolspace) {
                case 4: { // CMYK.
                    $this->gradients[$n]['colors'][$key]['color'] = sprintf('%F %F %F %F',
                           $color[0] / 100, $color[1] / 100, $color[2] / 100, $color[3] / 100);
                    break;
                }
                case 3: { // RGB.
                    $this->gradients[$n]['colors'][$key]['color'] = sprintf('%F %F %F',
                           $color[0] / 255, $color[1] / 255, $color[2] / 255);
                    break;
                }
                case 1: { // Gray scale.
                    $this->gradients[$n]['colors'][$key]['color'] = sprintf('%F', $color[0] / 255);
                    break;
                }
            }
        }
        if ($this->gradients[$n]['transparency']) {
            // Paint luminosity gradient.
            $this->_out('/TGS'.$n.' gs');
        }
        // Paint the gradient.
        $this->_out('/Sh'.$n.' sh');
        // Restore previous Graphic State.
        $this->_out('Q');
        if ($this->inxobj) {
            // We are inside an XObject template.
            $this->xobjects[$this->xobjid]['gradients'][$n] = $this->gradients[$n];
        }
    }

    /**
     * output gradient shaders.
     */
    public function _putshaders() {
        if ($this->pdfamode) {
            return;
        }
        $idt = count($this->gradients); // Index for transparency gradients.
        foreach ($this->gradients as $id => $grad) {
            if (($grad['type'] == 2) OR ($grad['type'] == 3)) {
                $fc = $this->_newobj();
                $out = '<<';
                $out .= ' /FunctionType 3';
                $out .= ' /Domain [0 1]';
                $functions = '';
                $bounds = '';
                $encode = '';
                $i = 1;
                $numcols = count($grad['colors']);
                $lastcols = $numcols - 1;
                for ($i = 1; $i < $numcols; ++$i) {
                    $functions .= ($fc + $i).' 0 R ';
                    if ($i < $lastcols) {
                        $bounds .= sprintf('%F ', $grad['colors'][$i]['offset']);
                    }
                    $encode .= '0 1 ';
                }
                $out .= ' /Functions ['.trim($functions).']';
                $out .= ' /Bounds ['.trim($bounds).']';
                $out .= ' /Encode ['.trim($encode).']';
                $out .= ' >>';
                $out .= "\n".'endobj';
                $this->_out($out);
                for ($i = 1; $i < $numcols; ++$i) {
                    $this->_newobj();
                    $out = '<<';
                    $out .= ' /FunctionType 2';
                    $out .= ' /Domain [0 1]';
                    $out .= ' /C0 ['.$grad['colors'][($i - 1)]['color'].']';
                    $out .= ' /C1 ['.$grad['colors'][$i]['color'].']';
                    $out .= ' /N '.$grad['colors'][$i]['exponent'];
                    $out .= ' >>';
                    $out .= "\n".'endobj';
                    $this->_out($out);
                }
                // Set transparency fuctions.
                if ($grad['transparency']) {
                    $ft = $this->_newobj();
                    $out = '<<';
                    $out .= ' /FunctionType 3';
                    $out .= ' /Domain [0 1]';
                    $functions = '';
                    $i = 1;
                    $numcols = count($grad['colors']);
                    for ($i = 1; $i < $numcols; ++$i) {
                        $functions .= ($ft + $i).' 0 R ';
                    }
                    $out .= ' /Functions ['.trim($functions).']';
                    $out .= ' /Bounds ['.trim($bounds).']';
                    $out .= ' /Encode ['.trim($encode).']';
                    $out .= ' >>';
                    $out .= "\n".'endobj';
                    $this->_out($out);
                    for ($i = 1; $i < $numcols; ++$i) {
                        $this->_newobj();
                        $out = '<<';
                        $out .= ' /FunctionType 2';
                        $out .= ' /Domain [0 1]';
                        $out .= ' /C0 ['.$grad['colors'][($i - 1)]['opacity'].']';
                        $out .= ' /C1 ['.$grad['colors'][$i]['opacity'].']';
                        $out .= ' /N '.$grad['colors'][$i]['exponent'];
                        $out .= ' >>';
                        $out .= "\n".'endobj';
                        $this->_out($out);
                    }
                }
            }
            // Set shading object.
            $this->_newobj();
            $out = '<< /ShadingType '.$grad['type'];
            if (isset($grad['colspace'])) {
                $out .= ' /ColorSpace /'.$grad['colspace'];
            } else {
                $out .= ' /ColorSpace /DeviceRGB';
            }
            if (isset($grad['background']) AND !empty($grad['background'])) {
                $out .= ' /Background ['.$grad['background'].']';
            }
            if (isset($grad['antialias']) AND ($grad['antialias'] === true)) {
                $out .= ' /AntiAlias true';
            }
            if ($grad['type'] == 2) {
                $out .= ' '.sprintf('/Coords [%F %F %F %F]', $grad['coords'][0], $grad['coords'][1],
                            $grad['coords'][2], $grad['coords'][3]);
                $out .= ' /Domain [0 1]';
                $out .= ' /Function '.$fc.' 0 R';
                $out .= ' /Extend [true true]';
                $out .= ' >>';
            } else if ($grad['type'] == 3) {
                // At this this time radius of inner circle is 0.
                $out .= ' '.sprintf('/Coords [%F %F 0 %F %F %F]', $grad['coords'][0], $grad['coords'][1],
                            $grad['coords'][2], $grad['coords'][3], $grad['coords'][4]);
                $out .= ' /Domain [0 1]';
                $out .= ' /Function '.$fc.' 0 R';
                $out .= ' /Extend [true true]';
                $out .= ' >>';
            } else if ($grad['type'] == 6) {
                $out .= ' /BitsPerCoordinate 16';
                $out .= ' /BitsPerComponent 8';
                $out .= ' /Decode[0 1 0 1 0 1 0 1 0 1]';
                $out .= ' /BitsPerFlag 8';
                $stream = $this->_getrawstream($grad['stream']);
                $out .= ' /Length '.strlen($stream);
                $out .= ' >>';
                $out .= ' stream'."\n".$stream."\n".'endstream';
            }
            $out .= "\n".'endobj';
            $this->_out($out);
            if ($grad['transparency']) {
                $shadingtransparency = preg_replace('/\/ColorSpace \/[^\s]+/si', '/ColorSpace /DeviceGray',
                                        $out);
                $shadingtransparency = preg_replace('/\/Function [0-9]+ /si', '/Function '.$ft.' ',
                                        $shadingtransparency);
            }
            $this->gradients[$id]['id'] = $this->n;
            // Set pattern object.
            $this->_newobj();
            $out = '<< /Type /Pattern /PatternType 2';
            $out .= ' /Shading '.$this->gradients[$id]['id'].' 0 R';
            $out .= ' >>';
            $out .= "\n".'endobj';
            $this->_out($out);
            $this->gradients[$id]['pattern'] = $this->n;
            // Set shading and pattern for transparency mask.
            if ($grad['transparency']) {
                // Luminosity pattern.
                $idgs = $id + $idt;
                $this->_newobj();
                $this->_out($shadingtransparency);
                $this->gradients[$idgs]['id'] = $this->n;
                $this->_newobj();
                $out = '<< /Type /Pattern /PatternType 2';
                $out .= ' /Shading '.$this->gradients[$idgs]['id'].' 0 R';
                $out .= ' >>';
                $out .= "\n".'endobj';
                $this->_out($out);
                $this->gradients[$idgs]['pattern'] = $this->n;
                // Luminosity XObject.
                $oid = $this->_newobj();
                $this->xobjects['LX'.$oid] = array('n' => $oid);
                $filter = '';
                $stream = 'q /a0 gs /Pattern cs /p'.$idgs.' scn 0 0 '.$this->wpt.' '.$this->hpt.' re f Q';
                if ($this->compress) {
                    $filter = ' /Filter /FlateDecode';
                    $stream = gzcompress($stream);
                }
                $stream = $this->_getrawstream($stream);
                $out = '<< /Type /XObject /Subtype /Form /FormType 1'.$filter;
                $out .= ' /Length '.strlen($stream);
                $rect = sprintf('%F %F', $this->wpt, $this->hpt);
                $out .= ' /BBox [0 0 '.$rect.']';
                $out .= ' /Group << /Type /Group /S /Transparency /CS /DeviceGray >>';
                $out .= ' /Resources <<';
                $out .= ' /ExtGState << /a0 << /ca 1 /CA 1 >> >>';
                $out .= ' /Pattern << /p'.$idgs.' '.$this->gradients[$idgs]['pattern'].' 0 R >>';
                $out .= ' >>';
                $out .= ' >> ';
                $out .= ' stream'."\n".$stream."\n".'endstream';
                $out .= "\n".'endobj';
                $this->_out($out);
                // SMask.
                $this->_newobj();
                $out = '<< /Type /Mask /S /Luminosity /G '.($this->n - 1).' 0 R >>'."\n".'endobj';
                $this->_out($out);
                // ExtGState.
                $this->_newobj();
                $out = '<< /Type /ExtGState /SMask '.($this->n - 1).' 0 R /AIS false >>'."\n".'endobj';
                $this->_out($out);
                $this->extgstates[] = array('n' => $this->n, 'name' => 'TGS'.$id);
            }
        }
    }

    /**
     * Draw the sector of a circle.
     */
    public function piesector($xc, $yc, $r, $a, $b, $style='FD', $cw=true, $o=90) {
        $this->piesectorxy($xc, $yc, $r, $r, $a, $b, $style, $cw, $o);
    }

    /**
     * Draw the sector of an ellipse.
     */
    public function piesectorxy($xc, $yc, $rx, $ry, $a, $b, $style='FD', $cw=false, $o=0, $nc=2) {
        if ($this->rtl) {
            $xc = $this->w - $xc;
        }
        $op = $this->getpathpaintoperator($style);
        if ($op == 'f') {
            $linestyle = array();
        }
        if ($cw) {
            $d = $b;
            $b = 360 - $a + $o;
            $a = 360 - $d + $o;
        } else {
            $b += $o;
            $a += $o;
        }
        $this->_outellipticalarc($xc, $yc, $rx, $ry, 0, $a, $b, true, $nc);
        $this->_out($op);
    }

    /**
     * Embed vector-based Adobe Illustrator (AI) or AI-compatible EPS files.
     * NOTE: EPS is not yet fully implemented, use the setrasterizevectorimages() method to enable/disable rasterization of
       vector images using ImageMagick library.
     * Only vector drawing is supported, not text or bitmap.
     * Although the script was successfully tested with various AI format versions, best results are probably achieved with
       files that were exported in the AI3 format (tested with Illustrator CS2, Freehand MX and Photoshop CS2).
     */
    public function imageeps($file, $x = '', $y = '', $w = 0, $h = 0, $link = '', $useboundingbox = true, $align = '',
                             $palign = '', $border = 0, $fitonpage = false, $fixoutvals = false) {
        if ($this->rasterizevectorimages AND ($w > 0) AND ($h > 0)) {
            // Convert EPS to raster image using GD or ImageMagick libraries.
            return $this->imageq($file, $x, $y, $w, $h, 'EPS', $link, $align, true, 300, $palign, false, false, $border,
                                false, false, $fitonpage);
        }
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        $k = $this->k;
        if ($file{0} === '@') { // Image from string.
            $data = substr($file, 1);
        } else { // EPS/AI file.
            $data = file_get_contents($file);
        }
        if ($data === false) {
            $this->errord('EPS file not found: '.$file);
        }
        $regs = array();
        // EPS/AI compatibility check (only checks files created by Adobe Illustrator!).
        preg_match("/%%Creator:([^\r\n]+)/", $data, $regs); // Find Creator.
        if (count($regs) > 1) {
            $versionstr = trim($regs[1]); // Adobe Illustrator(R) 8.0.
            if (strpos($versionstr, 'Adobe Illustrator') !== false) {
                $versexp = explode(' ', $versionstr);
                $version = (float)array_pop($versexp);
                if ($version >= 9) {
                    $this->errord('This version of Adobe Illustrator file is not supported: '.$file);
                }
            }
        }
        // Strip binary bytes in front of PS-header.
        $start = strpos($data, '%!PS-Adobe');
        if ($start > 0) {
            $data = substr($data, $start);
        }
        // Find BoundingBox params.
        preg_match("/%%BoundingBox:([^\r\n]+)/", $data, $regs);
        if (count($regs) > 1) {
            list($x1, $y1, $x2, $y2) = explode(' ', trim($regs[1]));
        } else {
            $this->errord('No BoundingBox found in EPS/AI file: '.$file);
        }
        $start = strpos($data, '%%EndSetup');
        if ($start === false) {
            $start = strpos($data, '%%EndProlog');
        }
        if ($start === false) {
            $start = strpos($data, '%%BoundingBox');
        }
        $data = substr($data, $start);
        $end = strpos($data, '%%PageTrailer');
        if ($end === false) {
            $end = strpos($data, 'showpage');
        }
        if ($end) {
            $data = substr($data, 0, $end);
        }
        // Calculate image width and height on document.
        if (($w <= 0) AND ($h <= 0)) {
            $w = ($x2 - $x1) / $k;
            $h = ($y2 - $y1) / $k;
        } else if ($w <= 0) {
            $w = ($x2 - $x1) / $k * ($h / (($y2 - $y1) / $k));
        } else if ($h <= 0) {
            $h = ($y2 - $y1) / $k * ($w / (($x2 - $x1) / $k));
        }
        // Fit the image on available space.
        list($w, $h, $x, $y) = $this->fitblock($w, $h, $x, $y, $fitonpage);
        if ($this->rasterizevectorimages) {
            // Convert EPS to raster image using GD or ImageMagick libraries.
            return $this->imageq($file, $x, $y, $w, $h, 'EPS', $link, $align, true, 300, $palign, false, false,
                                $border, false, false, $fitonpage);
        }
        // Set scaling factors.
        $scalex = $w / (($x2 - $x1) / $k);
        $scaley = $h / (($y2 - $y1) / $k);
        // Set alignment.
        $this->imgrby = $y + $h;
        // Set alignment.
        if ($this->rtl) {
            if ($palign == 'L') {
                $ximg = $this->lmargin;
            } else if ($palign == 'C') {
                $ximg = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $ximg = $this->w - $this->rmargin - $w;
            } else {
                $ximg = $x - $w;
            }
            $this->imgrbx = $ximg;
        } else {
            if ($palign == 'L') {
                $ximg = $this->lmargin;
            } else if ($palign == 'C') {
                $ximg = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $ximg = $this->w - $this->rmargin - $w;
            } else {
                $ximg = $x;
            }
            $this->imgrbx = $ximg + $w;
        }
        if ($useboundingbox) {
            $dx = $ximg * $k - $x1;
            $dy = $y * $k - $y1;
        } else {
            $dx = $ximg * $k;
            $dy = $y * $k;
        }
        // Save the current graphic state.
        $this->_out('q'.$this->epsmarker);
        // Translate.
        $this->_out(sprintf('%F %F %F %F %F %F cm', 1, 0, 0, 1, $dx, $dy + ($this->hpt - (2 * $y * $k) -
                    ($y2 - $y1))));
        // Scale.
        if (isset($scalex)) {
            $this->_out(sprintf('%F %F %F %F %F %F cm', $scalex, 0, 0, $scaley, $x1 * (1 - $scalex), $y2 *
                       (1 - $scaley)));
        }
        // Handle pc/unix/mac line endings.
        $lines = preg_split('/[\r\n]+/si', $data, -1, PREG_SPLIT_NO_EMPTY);
        $u = 0;
        $cnt = count($lines);
        for ($i = 0; $i < $cnt; ++$i) {
            $line = $lines[$i];
            if (($line == '') OR ($line{0} == '%')) {
                continue;
            }
            $len = strlen($line);
            // Check for spot color names.
            $colorname = '';
            if (strcasecmp('x', substr(trim($line), -1)) == 0) {
                if (preg_match('/\([^\)]*\)/', $line, $matches) > 0) {
                    // Extract spot color name.
                    $colorname = $matches[0];
                    // Remove color name from string.
                    $line = str_replace(' '.$colorname, '', $line);
                    // Remove pharentesis from color name.
                    $colorname = substr($colorname, 1, -1);
                }
            }
            $chunks = explode(' ', $line);
            $cmd = trim(array_pop($chunks));
            // RGB.
            if (($cmd == 'Xa') OR ($cmd == 'XA')) {
                $b = array_pop($chunks);
                $g = array_pop($chunks);
                $r = array_pop($chunks);
                $this->_out(''.$r.' '.$g.' '.$b.' '.($cmd == 'Xa' ? 'rg' : 'RG'));
                continue;
            }
            $skip = false;
            if ($fixoutvals) {
                // Check for values outside the bounding box.
                switch ($cmd) {
                    case 'm':
                    case 'l':
                    case 'L': {
                        // Skip values outside bounding box.
                        foreach ($chunks as $key => $val) {
                            if ((($key % 2) == 0) AND (($val < $x1) OR ($val > $x2))) {
                                $skip = true;
                            } else if ((($key % 2) != 0) AND (($val < $y1) OR ($val > $y2))) {
                                $skip = true;
                            }
                        }
                    }
                }
            }
            switch ($cmd) {
                case 'm':
                case 'l':
                case 'v':
                case 'y':
                case 'c':
                case 'k':
                case 'K':
                case 'g':
                case 'G':
                case 's':
                case 'S':
                case 'J':
                case 'j':
                case 'w':
                case 'M':
                case 'd':
                case 'n': {
                    if ($skip) {
                        break;
                    }
                    $this->_out($line);
                    break;
                }
                case 'x': { // Custom fill color.
                    if (empty($colorname)) {
                        // CMYK color.
                        list($colc, $colm, $coly, $colk) = $chunks;
                        $this->_out(''.$colc.' '.$colm.' '.$coly.' '.$colk.' k');
                    } else {
                        // Spot Color.
                        list($colc, $colm, $coly, $colk, $colt) = $chunks;
                        $this->addspotcolor($colorname, ($colc * 100), ($colm * 100), ($coly * 100), ($colk * 100));
                        $colorcmd = sprintf('/CS%d cs %F scn', $this->spotcolors[$colorname]['i'], (1 - $colt));
                        $this->_out($colorcmd);
                    }
                    break;
                }
                case 'X': { // Custom stroke color.
                    if (empty($colorname)) {
                        // CMYK color.
                        list($colc, $colm, $coly, $colk) = $chunks;
                        $this->_out(''.$colc.' '.$colm.' '.$coly.' '.$colk.' K');
                    } else {
                        // Spot Color.
                        list($colc, $colm, $coly, $colk, $colt) = $chunks;
                        $this->addspotcolor($colorname, ($colc * 100), ($colm * 100), ($coly * 100), ($colk * 100));
                        $colorcmd = sprintf('/CS%d CS %F SCN', $this->spotcolors[$colorname]['i'], (1 - $colt));
                        $this->_out($colorcmd);
                    }
                    break;
                }
                case 'Y':
                case 'N':
                case 'V':
                case 'L':
                case 'C': {
                    if ($skip) {
                        break;
                    }
                    $line[($len - 1)] = strtolower($cmd);
                    $this->_out($line);
                    break;
                }
                case 'b':
                case 'B': {
                    $this->_out($cmd . '*');
                    break;
                }
                case 'f':
                case 'F': {
                    if ($u > 0) {
                        $isu = false;
                        $max = min(($i + 5), $cnt);
                        for ($j = ($i + 1); $j < $max; ++$j) {
                            $isu = ($isu OR (($lines[$j] == 'U') OR ($lines[$j] == '*U')));
                        }
                        if ($isu) {
                            $this->_out('f*');
                        }
                    } else {
                        $this->_out('f*');
                    }
                    break;
                }
                case '*u': {
                    ++$u;
                    break;
                }
                case '*U': {
                    --$u;
                    break;
                }
            }
        }
        // Restore previous graphic state.
        $this->_out($this->epsmarker.'Q');
        if (!empty($border)) {
            $bx = $this->x;
            $by = $this->y;
            $this->x = $ximg;
            if ($this->rtl) {
                $this->x += $w;
            }
            $this->y = $y;
            $this->cell($w, $h, '', $border, 0, '', 0, '', 0, true);
            $this->x = $bx;
            $this->y = $by;
        }
        if ($link) {
            $this->link($ximg, $y, $w, $h, $link, 0);
        }
        // Set pointer to align the next text/objects.
        switch($align) {
            case 'T':{
                $this->y = $y;
                $this->x = $this->imgrbx;
                break;
            }
            case 'M':{
                $this->y = $y + round($h / 2);
                $this->x = $this->imgrbx;
                break;
            }
            case 'B':{
                $this->y = $this->imgrby;
                $this->x = $this->imgrbx;
                break;
            }
            case 'N':{
                $this->sety($this->imgrby);
                break;
            }
            default:{
                break;
            }
        }
        $this->endlinex = $this->imgrbx;
    }

    /**
     * Set document barcode.
     */
    public function setbarcode($bc = '') {
        $this->barcode = $bc;
    }

    /**
     * Get current barcode.
     * @return string
     */
    public function getbarcode() {
        return $this->barcode;
    }

    /**
     * Print a linear Barcode.
     */
    public function write1dbarcode($code, $type, $x = '', $y = '', $w = '', $h = '', $xres = '', $style = '',
                                   $align = '') {
        if ($this->empty_string(trim($code))) {
            return;
        }
        require_once(dirname(__FILE__).'/barcodes.php');
        // Save current graphic settings..
        $gvars = $this->getgraphicvars();
        // Create new barcode object.
        $barcodeobj = new TCPDFBarcode($code, $type);
        $arrcode = $barcodeobj->getbarcodeArray();
        if ($arrcode === false) {
            $this->errord('errord in 1D barcode string');
        }
        // Set default values.
        if (!isset($style['position'])) {
            $style['position'] = '';
        } else if ($style['position'] == 'S') {
            // Keep this for backward compatibility.
            $style['position'] = '';
            $style['stretch'] = true;
        }
        if (!isset($style['fitwidth'])) {
            if (!isset($style['stretch'])) {
                $style['fitwidth'] = true;
            } else {
                $style['fitwidth'] = false;
            }
        }
        if ($style['fitwidth']) {
            // Disable stretch.
            $style['stretch'] = false;
        }
        if (!isset($style['stretch'])) {
            if (($w === '') OR ($w <= 0)) {
                $style['stretch'] = false;
            } else {
                $style['stretch'] = true;
            }
        }
        if (!isset($style['fgcolor'])) {
            $style['fgcolor'] = array(0, 0, 0); // Default black.
        }
        if (!isset($style['bgcolor'])) {
            $style['bgcolor'] = false; // Default transparent.
        }
        if (!isset($style['border'])) {
            $style['border'] = false;
        }
        $fontsize = 0;
        if (!isset($style['text'])) {
            $style['text'] = false;
        }
        if ($style['text'] AND isset($style['font'])) {
            if (isset($style['fontsize'])) {
                $fontsize = $style['fontsize'];
            }
            $this->setfont($style['font'], '', $fontsize);
        }
        if (!isset($style['stretchtext'])) {
            $style['stretchtext'] = 4;
        }
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        if (($w === '') OR ($w <= 0)) {
            if ($this->rtl) {
                $w = $x - $this->lmargin;
            } else {
                $w = $this->w - $this->rmargin - $x;
            }
        }
        // Padding.
        if (!isset($style['padding'])) {
            $padding = 0;
        } else if ($style['padding'] === 'auto') {
            $padding = 10 * ($w / ($arrcode['maxw'] + 20));
        } else {
            $padding = floatval($style['padding']);
        }
        // Horizontal padding.
        if (!isset($style['hpadding'])) {
            $hpadding = $padding;
        } else if ($style['hpadding'] === 'auto') {
            $hpadding = 10 * ($w / ($arrcode['maxw'] + 20));
        } else {
            $hpadding = floatval($style['hpadding']);
        }
        // Vertical padding.
        if (!isset($style['vpadding'])) {
            $vpadding = $padding;
        } else if ($style['vpadding'] === 'auto') {
            $vpadding = ($hpadding / 2);
        } else {
            $vpadding = floatval($style['vpadding']);
        }
        // Calculate xres (single bar width).
        $maxxres = ($w - (2 * $hpadding)) / $arrcode['maxw'];
        if ($style['stretch']) {
            $xres = $maxxres;
        } else {
            if ($this->empty_string($xres)) {
                $xres = (0.141 * $this->k); // Default bar width = 0.4 mm.
            }
            if ($xres > $maxxres) {
                // Correct xres to fit on $w.
                $xres = $maxxres;
            }
            if ((isset($style['padding']) AND ($style['padding'] === 'auto'))
                OR (isset($style['hpadding']) AND ($style['hpadding'] === 'auto'))) {
                $hpadding = 10 * $xres;
                if (isset($style['vpadding']) AND ($style['vpadding'] === 'auto')) {
                    $vpadding = ($hpadding / 2);
                }
            }
        }
        if ($style['fitwidth']) {
            $wold = $w;
            $w = (($arrcode['maxw'] * $xres) + (2 * $hpadding));
            if (isset($style['cellfitalign'])) {
                switch ($style['cellfitalign']) {
                    case 'L': {
                        if ($this->rtl) {
                            $x -= ($wold - $w);
                        }
                        break;
                    }
                    case 'R': {
                        if (!$this->rtl) {
                            $x += ($wold - $w);
                        }
                        break;
                    }
                    case 'C': {
                        if ($this->rtl) {
                            $x -= (($wold - $w) / 2);
                        } else {
                            $x += (($wold - $w) / 2);
                        }
                        break;
                    }
                    default : {
                        break;
                    }
                }
            }
        }
        $textheight = ($this->cellheightratio * $fontsize / $this->k);
        // Height.
        if (($h === '') OR ($h <= 0)) {
            // Set default height.
            $h = (($arrcode['maxw'] * $xres) / 3) + (2 * $vpadding) + $textheight;
        }
        $barh = $h - $textheight - (2 * $vpadding);
        if ($barh <= 0) {
            // Try to reduce font or padding to fit barcode on available height.
            if ($textheight > $h) {
                $fontsize = (($h * $this->k) / (4 * $this->cellheightratio));
                $textheight = ($this->cellheightratio * $fontsize / $this->k);
                $this->setfont($style['font'], '', $fontsize);
            }
            if ($vpadding > 0) {
                $vpadding = (($h - $textheight) / 4);
            }
            $barh = $h - $textheight - (2 * $vpadding);
        }
        // Fit the barcode on available space.
        list($w, $h, $x, $y) = $this->fitblock($w, $h, $x, $y, false);
        // Set alignment.
        $this->imgrby = $y + $h;
        // Set alignment.
        if ($this->rtl) {
            if ($style['position'] == 'L') {
                $xpos = $this->lmargin;
            } else if ($style['position'] == 'C') {
                $xpos = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($style['position'] == 'R') {
                $xpos = $this->w - $this->rmargin - $w;
            } else {
                $xpos = $x - $w;
            }
            $this->imgrbx = $xpos;
        } else {
            if ($style['position'] == 'L') {
                $xpos = $this->lmargin;
            } else if ($style['position'] == 'C') {
                $xpos = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($style['position'] == 'R') {
                $xpos = $this->w - $this->rmargin - $w;
            } else {
                $xpos = $x;
            }
            $this->imgrbx = $xpos + $w;
        }
        $xposrect = $xpos;
        if (!isset($style['align'])) {
            $style['align'] = 'C';
        }
        switch ($style['align']) {
            case 'L': {
                $xpos = $xposrect + $hpadding;
                break;
            }
            case 'R': {
                $xpos = $xposrect + ($w - ($arrcode['maxw'] * $xres)) - $hpadding;
                break;
            }
            case 'C':
            default : {
                $xpos = $xposrect + (($w - ($arrcode['maxw'] * $xres)) / 2);
                break;
            }
        }
        $xpostext = $xpos;
        // Barcode is always printed in LTR direction.
        $temprtl = $this->rtl;
        $this->rtl = false;
        // Print background color.
        if ($style['bgcolor']) {
            $this->rect($xposrect, $y, $w, $h, $style['border'] ? 'DF' : 'F', '', $style['bgcolor']);
        } else if ($style['border']) {
            $this->rect($xposrect, $y, $w, $h, 'D');
        }
        // Set foreground color.
        $this->setdrawcolorarray($style['fgcolor']);
        $this->settextcolorarray($style['fgcolor']);
        // Print bars.
        foreach ($arrcode['bcode'] as $k => $v) {
            $bw = ($v['w'] * $xres);
            if ($v['t']) {
                // Draw a vertical bar.
                $ypos = $y + $vpadding + ($v['p'] * $barh / $arrcode['maxh']);
                $this->rect($xpos, $ypos, $bw, ($v['h'] * $barh / $arrcode['maxh']), 'F', array(), $style['fgcolor']);
            }
            $xpos += $bw;
        }
        // Print text.
        if ($style['text']) {
            if (isset($style['label']) AND !$this->empty_string($style['label'])) {
                $label = $style['label'];
            } else {
                $label = $code;
            }
            $txtwidth = ($arrcode['maxw'] * $xres);
            if ($this->getstringwidth($label) > $txtwidth) {
                $style['stretchtext'] = 2;
            }
            // Print text.
            $this->x = $xpostext;
            $this->y = $y + $vpadding + $barh;
            $cellpadding = $this->cellpadding;
            $this->setcellpadding(0);
            $this->cell($txtwidth, '', $label, 0, 0, 'C', false, '', $style['stretchtext'], false, 'T', 'T');
            $this->cellpadding = $cellpadding;
        }
        // Restore original direction.
        $this->rtl = $temprtl;
        // Restore previous settings.
        $this->setgraphicvars($gvars);
        // Set pointer to align the next text/objects.
        switch($align) {
            case 'T':{
                $this->y = $y;
                $this->x = $this->imgrbx;
                break;
            }
            case 'M':{
                $this->y = $y + round($h / 2);
                $this->x = $this->imgrbx;
                break;
            }
            case 'B':{
                $this->y = $this->imgrby;
                $this->x = $this->imgrbx;
                break;
            }
            case 'N':{
                $this->sety($this->imgrby);
                break;
            }
            default:{
                break;
            }
        }
        $this->endlinex = $this->imgrbx;
    }

    /**
     * This function is DEPRECATED, please use the new write1dbarcode() function.
     * @see write1dbarcode()
     */
    public function writebarcode($x, $y, $w, $h, $type, $style, $font, $xres, $code) {
        // Convert old settings for the new write1dbarcode() function.
        $xres = 1 / $xres;
        $newstyle = array(
            'position' => '',
            'align' => '',
            'stretch' => false,
            'fitwidth' => false,
            'cellfitalign' => '',
            'border' => false,
            'padding' => 0,
            'fgcolor' => array(0, 0, 0),
            'bgcolor' => false,
            'text' => true,
            'font' => $font,
            'fontsize' => 8,
            'stretchtext' => 4
        );
        if ($style & 1) {
            $newstyle['border'] = true;
        }
        if ($style & 2) {
            $newstyle['bgcolor'] = false;
        }
        if ($style & 4) {
            $newstyle['position'] = 'C';
        } else if ($style & 8) {
            $newstyle['position'] = 'L';
        } else if ($style & 16) {
            $newstyle['position'] = 'R';
        }
        if ($style & 128) {
            $newstyle['text'] = true;
        }
        if ($style & 256) {
            $newstyle['stretchtext'] = 4;
        }
        $this->write1dbarcode($code, $type, $x, $y, $w, $h, $xres, $newstyle, '');
    }

    /**
     * Print 2D Barcode.
     */
    public function write2dbarcode($code, $type, $x = '', $y = '', $w = '', $h = '', $style = '', $align = '',
                                   $distort = false) {
        if ($this->empty_string(trim($code))) {
            return;
        }
        require_once(dirname(__FILE__).'/2dbarcodes.php');
        // Save current graphic settings.
        $gvars = $this->getgraphicvars();
        // Create new barcode object.
        $barcodeobj = new TCPDF2DBarcode($code, $type);
        $arrcode = $barcodeobj->getbarcodeArray();
        if (($arrcode === false) OR empty($arrcode)) {
            $this->errord('errord in 2D barcode string');
        }
        // Set default values.
        if (!isset($style['position'])) {
            $style['position'] = '';
        }
        if (!isset($style['fgcolor'])) {
            $style['fgcolor'] = array(0, 0, 0); // Default black.
        }
        if (!isset($style['bgcolor'])) {
            $style['bgcolor'] = false; // Default transparent.
        }
        if (!isset($style['border'])) {
            $style['border'] = false;
        }
        // Padding.
        if (!isset($style['padding'])) {
            $style['padding'] = 0;
        } else if ($style['padding'] === 'auto') {
            $style['padding'] = 4;
        }
        if (!isset($style['hpadding'])) {
            $style['hpadding'] = $style['padding'];
        } else if ($style['hpadding'] === 'auto') {
            $style['hpadding'] = 4;
        }
        if (!isset($style['vpadding'])) {
            $style['vpadding'] = $style['padding'];
        } else if ($style['vpadding'] === 'auto') {
            $style['vpadding'] = 4;
        }
        $hpad = (2 * $style['hpadding']);
        $vpad = (2 * $style['vpadding']);
        // Cell (module) dimension.
        if (!isset($style['module_width'])) {
            $style['module_width'] = 1; // Width of a single module in points.
        }
        if (!isset($style['module_height'])) {
            $style['module_height'] = 1; // Height of a single module in points.
        }
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        // Number of barcode columns and rows.
        $rows = $arrcode['num_rows'];
        $cols = $arrcode['numcols'];
        // Module width and height.
        $mw = $style['module_width'];
        $mh = $style['module_height'];
        // Get max dimensions.
        if ($this->rtl) {
            $maxw = $x - $this->lmargin;
        } else {
            $maxw = $this->w - $this->rmargin - $x;
        }
        $maxh = ($this->h - $this->tmargin - $this->bmargin);
        $ratiohw = ((($rows * $mh) + $hpad) / (($cols * $mw) + $vpad));
        $ratiowh = ((($cols * $mw) + $vpad) / (($rows * $mh) + $hpad));
        if (!$distort) {
            if (($maxw * $ratiohw) > $maxh) {
                $maxw = $maxh * $ratiowh;
            }
            if (($maxh * $ratiowh) > $maxw) {
                $maxh = $maxw * $ratiohw;
            }
        }
        // Set maximum dimesions.
        if ($w > $maxw) {
            $w = $maxw;
        }
        if ($h > $maxh) {
            $h = $maxh;
        }
        // Set dimensions.
        if ((($w === '') OR ($w <= 0)) AND (($h === '') OR ($h <= 0))) {
            $w = ($cols + $hpad) * ($mw / $this->k);
            $h = ($rows + $vpad) * ($mh / $this->k);
        } else if (($w === '') OR ($w <= 0)) {
            $w = $h * $ratiowh;
        } else if (($h === '') OR ($h <= 0)) {
            $h = $w * $ratiohw;
        }
        // Barcode size (excluding padding).
        $bw = ($w * $cols) / ($cols + $hpad);
        $bh = ($h * $rows) / ($rows + $vpad);
        // Dimension of single barcode cell unit.
        $cw = $bw / $cols;
        $ch = $bh / $rows;
        if (!$distort) {
            if (($cw / $ch) > ($mw / $mh)) {
                // Correct horizontal distortion.
                $cw = $ch * $mw / $mh;
                $bw = $cw * $cols;
                $style['hpadding'] = ($w - $bw) / (2 * $cw);
            } else {
                // Correct vertical distortion.
                $ch = $cw * $mh / $mw;
                $bh = $ch * $rows;
                $style['vpadding'] = ($h - $bh) / (2 * $ch);
            }
        }
        // Fit the barcode on available space.
        list($w, $h, $x, $y) = $this->fitblock($w, $h, $x, $y, false);
        // Set alignment.
        $this->imgrby = $y + $h;
        // Set alignment.
        if ($this->rtl) {
            if ($style['position'] == 'L') {
                $xpos = $this->lmargin;
            } else if ($style['position'] == 'C') {
                $xpos = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($style['position'] == 'R') {
                $xpos = $this->w - $this->rmargin - $w;
            } else {
                $xpos = $x - $w;
            }
            $this->imgrbx = $xpos;
        } else {
            if ($style['position'] == 'L') {
                $xpos = $this->lmargin;
            } else if ($style['position'] == 'C') {
                $xpos = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($style['position'] == 'R') {
                $xpos = $this->w - $this->rmargin - $w;
            } else {
                $xpos = $x;
            }
            $this->imgrbx = $xpos + $w;
        }
        $xstart = $xpos + ($style['hpadding'] * $cw);
        $ystart = $y + ($style['vpadding'] * $ch);
        // Barcode is always printed in LTR direction.
        $temprtl = $this->rtl;
        $this->rtl = false;
        // Print background color.
        if ($style['bgcolor']) {
            $this->rect($xpos, $y, $w, $h, $style['border'] ? 'DF' : 'F', '', $style['bgcolor']);
        } else if ($style['border']) {
            $this->rect($xpos, $y, $w, $h, 'D');
        }
        // Set foreground color.
        $this->setdrawcolorarray($style['fgcolor']);
        // Print barcode cells.
        // For each row.
        for ($r = 0; $r < $rows; ++$r) {
            $xr = $xstart;
            // For each column.
            for ($c = 0; $c < $cols; ++$c) {
                if ($arrcode['bcode'][$r][$c] == 1) {
                    // Draw a single barcode cell.
                    $this->rect($xr, $ystart, $cw, $ch, 'F', array(), $style['fgcolor']);
                }
                $xr += $cw;
            }
            $ystart += $ch;
        }
        // Restore original direction.
        $this->rtl = $temprtl;
        // Restore previous settings.
        $this->setgraphicvars($gvars);
        // Set pointer to align the next text/objects.
        switch($align) {
            case 'T':{
                $this->y = $y;
                $this->x = $this->imgrbx;
                break;
            }
            case 'M':{
                $this->y = $y + round($h / 2);
                $this->x = $this->imgrbx;
                break;
            }
            case 'B':{
                $this->y = $this->imgrby;
                $this->x = $this->imgrbx;
                break;
            }
            case 'N':{
                $this->sety($this->imgrby);
                break;
            }
            default:{
                break;
            }
        }
        $this->endlinex = $this->imgrbx;
    }

    /**
     * Returns an array containing current margins
     */
    public function getmargins() {
        $ret = array(
            'left' => $this->lmargin,
            'right' => $this->rmargin,
            'top' => $this->tmargin,
            'bottom' => $this->bmargin,
            'header' => $this->headermargin,
            'footer' => $this->footermargin,
            'cell' => $this->cellpadding,
            'padding_left' => $this->cellpadding['L'],
            'padding_top' => $this->cellpadding['T'],
            'padding_right' => $this->cellpadding['R'],
            'padding_bottom' => $this->cellpadding['B']
        );
        return $ret;
    }

    /**
     * Returns an array containing original margins
     */
    public function getoriginalmargins() {
             $ret = array(
            'left' => $this->originallmargin,
            'right' => $this->originalrmargin
        );
        return $ret;
    }

    /**
     * Returns the current font size.
     */
    public function getfontsize() {
        return $this->fontsize;
    }

    /**
     * Returns the current font size in points unit.
     */
    public function getfontsizept() {
        return $this->fontsizept;
    }

    /**
     * Returns the current font family name.
     */
    public function getfontfamily() {
        return $this->fontfamily;
    }

    /**
     * Returns the current font style.
     */
    public function getfontstyle() {
        return $this->fontstyle;
    }

    /**
     * Cleanup HTML code (requires HTML Tidy library).
     * @see sethtmlvspace()
     */
    public function fixhtmlcode($html, $defaultcss = '', $tagvs = '', $tidyoptions = '') {
        // Configure parameters for HTML Tidy.
        if ($tidyoptions === '') {
            $tidyoptions = array (
                'clean' => 1,
                'drop-empty-paras' => 0,
                'drop-proprietary-attributes' => 1,
                'fix-backslash' => 1,
                'hide-comments' => 1,
                'join-styles' => 1,
                'lower-literals' => 1,
                'merge-divs' => 1,
                'merge-spans' => 1,
                'output-xhtml' => 1,
                'word-2000' => 1,
                'wrap' => 0,
                'output-bom' => 0,
            );
        }
        // Clean up the HTML code.
        $tidy = tidy_parse_string($html, $tidyoptions);
        // Fix the HTML.
        $tidy->cleanRepair();
        // Get the CSS part.
        $tidyhead = tidy_get_head($tidy);
        $css = $tidyhead->value;
        $css = preg_replace('/<style([^>]+)>/ims', '<style>', $css);
        $css = preg_replace('/<\/style>(.*)<style>/ims', "\n", $css);
        $css = str_replace('/*<![CDATA[*/', '', $css);
        $css = str_replace('/*]]>*/', '', $css);
        preg_match('/<style>(.*)<\/style>/ims', $css, $matches);
        if (isset($matches[1])) {
            $css = strtolower($matches[1]);
        } else {
            $css = '';
        }
        // Include default css.
        $css = '<style>'.$defaultcss.$css.'</style>';
        // Get the body part.
        $tidybody = tidy_get_body($tidy);
        $html = $tidybody->value;
        // Fix some self-closing tags.
        $html = str_replace('<br>', '<br />', $html);
        // Remove some empty tag blocks.
        $html = preg_replace('/<div([^\>]*)><\/div>/', '', $html);
        $html = preg_replace('/<p([^\>]*)><\/p>/', '', $html);
        if ($tagvs !== '') {
            // Set vertical space for some XHTML tags.
            $this->sethtmlvspace($tagvs);
        }
        // Return the cleaned XHTML code + CSS.
        return $css.$html;
    }

    /**
     * Extracts the CSS properties from a CSS string.
     */
    protected function extractcssproperties($cssdata) {
        if (empty($cssdata)) {
            return array();
        }
        // Remove comments.
        $cssdata = preg_replace('/\/\*[^\*]*\*\//', '', $cssdata);
        // Remove newlines and multiple spaces.
        $cssdata = preg_replace('/[\s]+/', ' ', $cssdata);
        // Remove some spaces.
        $cssdata = preg_replace('/[\s]*([;:\{\}]{1})[\s]*/', '\\1', $cssdata);
        // Remove empty blocks.
        $cssdata = preg_replace('/([^\}\{]+)\{\}/', '', $cssdata);
        // Replace media type parenthesis.
        $cssdata = preg_replace('/@media[\s]+([^\{]*)\{/i', '@media \\1', $cssdata);
        $cssdata = preg_replace('/\}\}/si', '}', $cssdata);
        // Trim string.
        $cssdata = trim($cssdata);
        // Find media blocks (all, braille, embossed, handheld, print, projection, screen, speech, tty, tv).
        $cssblocks = array();
        $matches = array();
        if (preg_match_all('/@media[\s]+([^\]*)([^]*)/i', $cssdata, $matches) > 0) {
            foreach ($matches[1] as $key => $type) {
                $cssblocks[$type] = $matches[2][$key];
            }
            // Remove media blocks.
            $cssdata = preg_replace('/@media[\s]+([^\]*)([^]*)/i', '', $cssdata);
        }
        // Keep 'all' and 'print' media, other media types are discarded.
        if (isset($cssblocks['all']) AND !empty($cssblocks['all'])) {
            $cssdata .= $cssblocks['all'];
        }
        if (isset($cssblocks['print']) AND !empty($cssblocks['print'])) {
            $cssdata .= $cssblocks['print'];
        }
        // Reset css blocks array.
        $cssblocks = array();
        $matches = array();
        // Explode css data string into array.
        if (substr($cssdata, -1) == '}') {
            // Remove last parethesis.
            $cssdata = substr($cssdata, 0, -1);
        }
        $matches = explode('}', $cssdata);
        foreach ($matches as $key => $block) {
            // Index 0 contains the CSS selector, index 1 contains CSS properties.
            $cssblocks[$key] = explode('{', $block);
            if (!isset($cssblocks[$key][1])) {
                // Remove empty definitions.
                unset($cssblocks[$key]);
            }
        }
        // Split groups of selectors (comma-separated list of selectors).
        foreach ($cssblocks as $key => $block) {
            if (strpos($block[0], ',') > 0) {
                $selectors = explode(',', $block[0]);
                foreach ($selectors as $sel) {
                    $cssblocks[] = array(0 => trim($sel), 1 => $block[1]);
                }
                unset($cssblocks[$key]);
            }
        }
        // Convert array to selector => properties.
        $cssdata = array();
        foreach ($cssblocks as $block) {
            $selector = $block[0];
            // Calculate selector's specificity.
            $matches = array();
            $a = 0; // The declaration is not from is a 'style' attribute.
            $b = intval(preg_match_all('/[\#]/', $selector, $matches)); // Number of ID attributes.
            $c = intval(preg_match_all('/[\[\.]/', $selector, $matches)); // Number of other attributes.
            $c += intval(preg_match_all('/[\:]link|visited|hover|active|focus|target|lang|enabled|disabled|checked|
                                         indeterminate|root|nth|first|last|only|empty|contains|not/i',
                                         $selector, $matches)); // Number of pseudo-classes.
            $d = intval(preg_match_all('/[\>\+\~\s]{1}[a-zA-Z0-9]+/', ' '.$selector, $matches)); // Number of element names.
            $d += intval(preg_match_all('/[\:][\:]/', $selector, $matches)); // Number of pseudo-elements.
            $specificity = $a.$b.$c.$d;
            // Add specificity to the beginning of the selector.
            $cssdata[$specificity.' '.$selector] = $block[1];
        }
        // Sort selectors alphabetically to account for specificity.
        ksort($cssdata, SORT_STRING);
        // Return array.
        return $cssdata;
    }

    /**
     * Returns true if the CSS selector is valid for the selected HTML tag
     */
    protected function isvalidcssselectorfortag($dom, $key, $selector) {
        $valid = false; // Value to be returned.
        $tag = $dom[$key]['value'];
        $class = array();
        if (isset($dom[$key]['attribute']['class']) AND !empty($dom[$key]['attribute']['class'])) {
            $class = explode(' ', strtolower($dom[$key]['attribute']['class']));
        }
        $id = '';
        if (isset($dom[$key]['attribute']['id']) AND !empty($dom[$key]['attribute']['id'])) {
            $id = strtolower($dom[$key]['attribute']['id']);
        }
        $selector = preg_replace('/([\>\+\~\s]{1})([\.]{1})([^\>\+\~\s]*)/si', '\\1*.\\3', $selector);
        $matches = array();
        if (preg_match_all('/([\>\+\~\s]{1})([a-zA-Z0-9\*]+)([^\>\+\~\s]*)/si', $selector, $matches,
                           PREG_PATTERN_ORDER | PREG_OFFSET_CAPTURE) > 0) {
            $parentop = array_pop($matches[1]);
            $operator = $parentop[0];
            $offset = $parentop[1];
            $lasttag = array_pop($matches[2]);
            $lasttag = strtolower(trim($lasttag[0]));
            if (($lasttag == '*') OR ($lasttag == $tag)) {
                // The last element on selector is our tag or 'any tag'.
                $attrib = array_pop($matches[3]);
                $attrib = strtolower(trim($attrib[0]));
                if (!empty($attrib)) {
                    // Check if matches class, id, attribute, pseudo-class or pseudo-element.
                    switch ($attrib{0}) {
                        case '.': { // Class.
                            if (in_array(substr($attrib, 1), $class)) {
                                $valid = true;
                            }
                            break;
                        }
                        case '#': { // ID.
                            if (substr($attrib, 1) == $id) {
                                $valid = true;
                            }
                            break;
                        }
                        case '[': { // Attribute.
                            $attrmatch = array();
                            if (preg_match('/\[([a-zA-Z0-9]*)[\s]*([\~\^\$\*\|\=]*)[\s]*["]?([^"\]]*)["]?\]/i',
                                $attrib, $attrmatch) > 0) {
                                $att = strtolower($attrmatch[1]);
                                $val = $attrmatch[3];
                                if (isset($dom[$key]['attribute'][$att])) {
                                    switch ($attrmatch[2]) {
                                        case '=': {
                                            if ($dom[$key]['attribute'][$att] == $val) {
                                                $valid = true;
                                            }
                                            break;
                                        }
                                        case '~=': {
                                            if (in_array($val, explode(' ', $dom[$key]['attribute'][$att]))) {
                                                $valid = true;
                                            }
                                            break;
                                        }
                                        case '^=': {
                                            if ($val == substr($dom[$key]['attribute'][$att], 0, strlen($val))) {
                                                $valid = true;
                                            }
                                            break;
                                        }
                                        case '$=': {
                                            if ($val == substr($dom[$key]['attribute'][$att], -strlen($val))) {
                                                $valid = true;
                                            }
                                            break;
                                        }
                                        case '*=': {
                                            if (strpos($dom[$key]['attribute'][$att], $val) !== false) {
                                                $valid = true;
                                            }
                                            break;
                                        }
                                        case '|=': {
                                            if ($dom[$key]['attribute'][$att] == $val) {
                                                $valid = true;
                                            } else if (preg_match('/'.$val.'[\-]{1}/i', $dom[$key]['attribute'][$att]) > 0) {
                                                $valid = true;
                                            }
                                            break;
                                        }
                                        default: {
                                            $valid = true;
                                        }
                                    }
                                }
                            }
                            break;
                        }
                    } // End of switch.
                } else {
                    $valid = true;
                }
                if ($valid AND ($offset > 0)) {
                    $valid = false;
                    // Check remaining selector part.
                    $selector = substr($selector, 0, $offset);
                    switch ($operator) {
                        case ' ': { // Descendant of an element.
                            while ($dom[$key]['parent'] > 0) {
                                if ($this->isvalidcssselectorfortag($dom, $dom[$key]['parent'], $selector)) {
                                    $valid = true;
                                    break;
                                } else {
                                    $key = $dom[$key]['parent'];
                                }
                            }
                            break;
                        }
                        case '>': { // Child of an element.
                            $valid = $this->isvalidcssselectorfortag($dom, $dom[$key]['parent'], $selector);
                            break;
                        }
                        case '+': { // Immediately preceded by an element.
                            for ($i = ($key - 1); $i > $dom[$key]['parent']; --$i) {
                                if ($dom[$i]['tag'] AND $dom[$i]['opening']) {
                                    $valid = $this->isvalidcssselectorfortag($dom, $i, $selector);
                                    break;
                                }
                            }
                            break;
                        }
                        case '~': { // Preceded by an element.
                            for ($i = ($key - 1); $i > $dom[$key]['parent']; --$i) {
                                if ($dom[$i]['tag'] AND $dom[$i]['opening']) {
                                    if ($this->isvalidcssselectorfortag($dom, $i, $selector)) {
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        return $valid;
    }

    /**
     * Returns the styles array that apply for the selected HTML tag.
     */
    protected function getcssdataarray($dom, $key, $css) {
        $cssarray = array(); // Style to be returned.
        // Get parent CSS selectors.
        $selectors = array();
        if (isset($dom[($dom[$key]['parent'])]['csssel'])) {
            $selectors = $dom[($dom[$key]['parent'])]['csssel'];
        }
        // Get all styles that apply.
        foreach ($css as $selector => $style) {
            $pos = strpos($selector, ' ');
            // Get specificity.
            $specificity = substr($selector, 0, $pos);
            // Remove specificity.
            $selector = substr($selector, $pos);
            // Check if this selector apply to current tag.
            if ($this->isvalidcssselectorfortag($dom, $key, $selector)) {
                if (!in_array($selector, $selectors)) {
                    // Add style if not already added on parent selector.
                    $cssarray[] = array('k' => $selector, 's' => $specificity, 'c' => $style);
                    $selectors[] = $selector;
                }
            }
        }
        if (isset($dom[$key]['attribute']['style'])) {
            // Attach inline style (latest properties have high priority).
            $cssarray[] = array('k' => '', 's' => '1000', 'c' => $dom[$key]['attribute']['style']);
        }
        // Order the css array to account for specificity.
        $cssordered = array();
        foreach ($cssarray as $key => $val) {
            $skey = sprintf('%04d', $key);
            $cssordered[$val['s'].'_'.$skey] = $val;
        }
        // Sort selectors alphabetically to account for specificity.
        ksort($cssordered, SORT_STRING);
        return array($selectors, $cssordered);
    }

    /**
     * Compact CSS data array into single string.
     */
    protected function gettagstylefromcssarray($css) {
        $tagstyle = ''; // Value to be returned.
        foreach ($css as $style) {
            // Split single css commands.
            $csscmds = explode(';', $style['c']);
            foreach ($csscmds as $cmd) {
                if (!empty($cmd)) {
                    $pos = strpos($cmd, ':');
                    if ($pos !== false) {
                        $cmd = substr($cmd, 0, ($pos + 1));
                        if (strpos($tagstyle, $cmd) !== false) {
                            // Remove duplicate commands (last commands have high priority).
                            $tagstyle = preg_replace('/'.$cmd.'[^;]+/i', '', $tagstyle);
                        }
                    }
                }
            }
            $tagstyle .= ';'.$style['c'];
        }
        // Remove multiple semicolons.
        $tagstyle = preg_replace('/[;]+/', ';', $tagstyle);
        return $tagstyle;
    }

    /**
     * Returns the border width from CSS property
     */
    protected function getcssborderwidth($width) {
        if ($width == 'thin') {
            $width = (2 / $this->k);
        } else if ($width == 'medium') {
            $width = (4 / $this->k);
        } else if ($width == 'thick') {
            $width = (6 / $this->k);
        } else {
            $width = $this->gethtmlunittounits($width, 1, 'px', false);
        }
        return $width;
    }

    /**
     * Returns the border dash style from CSS property
     */
    protected function getcssborderdashstyle($style) {
        switch (strtolower($style)) {
            case 'none':
            case 'hidden': {
                $dash = -1;
                break;
            }
            case 'dotted': {
                $dash = 1;
                break;
            }
            case 'dashed': {
                $dash = 3;
                break;
            }
            case 'double':
            case 'groove':
            case 'ridge':
            case 'inset':
            case 'outset':
            case 'solid':
            default: {
                $dash = 0;
                break;
            }
        }
        return $dash;
    }

    /**
     * Returns the border style array from CSS border properties
     */
    protected function getcssborderstyle($cssborder) {
        $bprop = preg_split('/[\s]+/', trim($cssborder));
        $border = array(); // Value to be returned.
        switch (count($bprop)) {
            case 3: {
                $width = $bprop[0];
                $style = $bprop[1];
                $color = $bprop[2];
                break;
            }
            case 2: {
                $width = 'medium';
                $style = $bprop[0];
                $color = $bprop[1];
                break;
            }
            case 1: {
                $width = 'medium';
                $style = $bprop[0];
                $color = 'black';
                break;
            }
            default: {
                $width = 'medium';
                $style = 'solid';
                $color = 'black';
                break;
            }
        }
        if ($style == 'none') {
            return array();
        }
        $border['cap'] = 'square';
        $border['join'] = 'miter';
        $border['dash'] = $this->getcssborderdashstyle($style);
        if ($border['dash'] < 0) {
            return array();
        }
        $border['width'] = $this->getcssborderwidth($width);
        $border['color'] = $this->converthtmlcolortodec($color);
        return $border;
    }

    /**
     * Get the internal cell padding from CSS attribute.
     */
    public function getcsspadding($csspadding, $width = 0) {
        $padding = preg_split('/[\s]+/', trim($csspadding));
        $cellpadding = array(); // Value to be returned.
        switch (count($padding)) {
            case 4: {
                $cellpadding['T'] = $padding[0];
                $cellpadding['R'] = $padding[1];
                $cellpadding['B'] = $padding[2];
                $cellpadding['L'] = $padding[3];
                break;
            }
            case 3: {
                $cellpadding['T'] = $padding[0];
                $cellpadding['R'] = $padding[1];
                $cellpadding['B'] = $padding[2];
                $cellpadding['L'] = $padding[1];
                break;
            }
            case 2: {
                $cellpadding['T'] = $padding[0];
                $cellpadding['R'] = $padding[1];
                $cellpadding['B'] = $padding[0];
                $cellpadding['L'] = $padding[1];
                break;
            }
            case 1: {
                $cellpadding['T'] = $padding[0];
                $cellpadding['R'] = $padding[0];
                $cellpadding['B'] = $padding[0];
                $cellpadding['L'] = $padding[0];
                break;
            }
            default: {
                return $this->cellpadding;
            }
        }
        if ($width == 0) {
            $width = $this->w - $this->lmargin - $this->rmargin;
        }
        $cellpadding['T'] = $this->gethtmlunittounits($cellpadding['T'], $width, 'px', false);
        $cellpadding['R'] = $this->gethtmlunittounits($cellpadding['R'], $width, 'px', false);
        $cellpadding['B'] = $this->gethtmlunittounits($cellpadding['B'], $width, 'px', false);
        $cellpadding['L'] = $this->gethtmlunittounits($cellpadding['L'], $width, 'px', false);
        return $cellpadding;
    }

    /**
     * Get the internal cell margin from CSS attribute.
     */
    public function getcssmargin($cssmargin, $width = 0) {
        $margin = preg_split('/[\s]+/', trim($cssmargin));
        $cellmargin = array(); // Value to be returned.
        switch (count($margin)) {
            case 4: {
                $cellmargin['T'] = $margin[0];
                $cellmargin['R'] = $margin[1];
                $cellmargin['B'] = $margin[2];
                $cellmargin['L'] = $margin[3];
                break;
            }
            case 3: {
                $cellmargin['T'] = $margin[0];
                $cellmargin['R'] = $margin[1];
                $cellmargin['B'] = $margin[2];
                $cellmargin['L'] = $margin[1];
                break;
            }
            case 2: {
                $cellmargin['T'] = $margin[0];
                $cellmargin['R'] = $margin[1];
                $cellmargin['B'] = $margin[0];
                $cellmargin['L'] = $margin[1];
                break;
            }
            case 1: {
                $cellmargin['T'] = $margin[0];
                $cellmargin['R'] = $margin[0];
                $cellmargin['B'] = $margin[0];
                $cellmargin['L'] = $margin[0];
                break;
            }
            default: {
                return $this->cellmargin;
            }
        }
        if ($width == 0) {
            $width = $this->w - $this->lmargin - $this->rmargin;
        }
        $cellmargin['T'] = $this->gethtmlunittounits(str_replace('auto', '0', $cellmargin['T']), $width, 'px', false);
        $cellmargin['R'] = $this->gethtmlunittounits(str_replace('auto', '0', $cellmargin['R']), $width, 'px', false);
        $cellmargin['B'] = $this->gethtmlunittounits(str_replace('auto', '0', $cellmargin['B']), $width, 'px', false);
        $cellmargin['L'] = $this->gethtmlunittounits(str_replace('auto', '0', $cellmargin['L']), $width, 'px', false);
        return $cellmargin;
    }

    /**
     * Get the border-spacing from CSS attribute.
     */
    public function getcssbordermargin($cssbspace, $width=0) {
        $space = preg_split('/[\s]+/', trim($cssbspace));
        $borderspacing = array(); // Value to be returned.
        switch (count($space)) {
            case 2: {
                $borderspacing['H'] = $space[0];
                $borderspacing['V'] = $space[1];
                break;
            }
            case 1: {
                $borderspacing['H'] = $space[0];
                $borderspacing['V'] = $space[0];
                break;
            }
            default: {
                return array('H' => 0, 'V' => 0);
            }
        }
        if ($width == 0) {
            $width = $this->w - $this->lmargin - $this->rmargin;
        }
        $borderspacing['H'] = $this->gethtmlunittounits($borderspacing['H'], $width, 'px', false);
        $borderspacing['V'] = $this->gethtmlunittounits($borderspacing['V'], $width, 'px', false);
        return $borderspacing;
    }

    /**
     * Returns the letter-spacing value from CSS value
     */
    protected function getcssfontspacing($spacing, $parent = 0) {
        $val = 0; // Value to be returned.
        $spacing = trim($spacing);
        switch ($spacing) {
            case 'normal': {
                $val = 0;
                break;
            }
            case 'inherit': {
                if ($parent == 'normal') {
                    $val = 0;
                } else {
                    $val = $parent;
                }
                break;
            }
            default: {
                $val = $this->gethtmlunittounits($spacing, 0, 'px', false);
            }
        }
            return $val;
    }

    /**
     * Returns the percentage of font stretching from CSS value
     */
    protected function getcssfontstretching($stretch, $parent = 100) {
        $val = 100; // Value to be returned.
        $stretch = trim($stretch);
        switch ($stretch) {
            case 'ultra-condensed': {
                $val = 40;
                break;
            }
            case 'extra-condensed': {
                $val = 55;
                break;
            }
            case 'condensed': {
                $val = 70;
                break;
            }
            case 'semi-condensed': {
                $val = 85;
                break;
            }
            case 'normal': {
                $val = 100;
                break;
            }
            case 'semi-expanded': {
                $val = 115;
                break;
            }
            case 'expanded': {
                $val = 130;
                break;
            }
            case 'extra-expanded': {
                $val = 145;
                break;
            }
            case 'ultra-expanded': {
                $val = 160;
                break;
            }
            case 'wider': {
                $val = $parent + 10;
                break;
            }
            case 'narrower': {
                $val = $parent - 10;
                break;
            }
            case 'inherit': {
                if ($parent == 'normal') {
                    $val = 100;
                } else {
                    $val = $parent;
                }
                break;
            }
            default: {
                $val = $this->gethtmlunittounits($stretch, 100, '%', false);
            }
        }
            return $val;
    }

    /**
     * Returns the HTML DOM array.
     */
    protected function gethtmldomarray($html) {
        // Array of CSS styles ( selector => properties).
        $css = array();
        // Get CSS array defined at previous call.
        $matches = array();
        if (preg_match_all('/<cssarray>([^\<]*)<\/cssarray>/isu', $html, $matches) > 0) {
            if (isset($matches[1][0])) {
                $css = array_merge($css, unserialize($this->unhtmlentities($matches[1][0])));
            }
            $html = preg_replace('/<cssarray>(.*?)<\/cssarray>/isu', '', $html);
        }
        // Extract external CSS files.
        $matches = array();
        if (preg_match_all('/<link([^\>]*)>/isu', $html, $matches) > 0) {
            foreach ($matches[1] as $key => $link) {
                $type = array();
                if (preg_match('/type[\s]*=[\s]*"text\/css"/', $link, $type)) {
                    $type = array();
                    preg_match('/media[\s]*=[\s]*"([^"]*)"/', $link, $type);
                    if (empty($type) OR (isset($type[1]) AND (($type[1] == 'all') OR ($type[1] == 'print')))) {
                        $type = array();
                        if (preg_match('/href[\s]*=[\s]*"([^"]*)"/', $link, $type) > 0) {
                            // Read CSS data file.
                            $cssdata = file_get_contents(trim($type[1]));
                            $css = array_merge($css, $this->extractcssproperties($cssdata));
                        }
                    }
                }
            }
        }
        // Extract style tags.
        $matches = array();
        if (preg_match_all('/<style([^\>]*)>([^\<]*)<\/style>/isu', $html, $matches) > 0) {
            foreach ($matches[1] as $key => $media) {
                $type = array();
                preg_match('/media[\s]*=[\s]*"([^"]*)"/', $media, $type);
                if (empty($type) OR (isset($type[1]) AND (($type[1] == 'all') OR ($type[1] == 'print')))) {
                    $cssdata = $matches[2][$key];
                    $css = array_merge($css, $this->extractcssproperties($cssdata));
                }
            }
        }
        // Create a special tag to contain the CSS array (used for table content).
        $csstagarray = '<cssarray>'.htmlentities(serialize($css)).'</cssarray>';
        // Remove head and style blocks.
        $html = preg_replace('/<head([^\>]*)>(.*?)<\/head>/siU', '', $html);
        $html = preg_replace('/<style([^\>]*)>([^\<]*)<\/style>/isu', '', $html);
        // Define block tags.
        $blocktags = array('blockquote', 'br', 'dd', 'dl', 'div', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr',
                           'li', 'ol', 'p', 'pre', 'ul', 'tcpdf', 'table', 'tr', 'td');
        // Define self-closing tags.
        $selfclosingtags = array('area', 'base', 'basefont', 'br', 'hr', 'input', 'img', 'link', 'meta');
        // Remove all unsupported tags (the line below lists all supported tags).
        $html = strip_tags($html, '<marker/><a><b><blockquote><body><br><br/><dd><del><div><dl><dt><em><font>
                                   <form><h1><h2><h3><h4><h5><h6><hr><hr/><i><img><input><label><li><ol><option>
                                   <p><pre><s><select><small>
                                   <span><strike><strong><sub><sup><table><tablehead><tcpdf><td><textarea><th>
                                   <thead><tr><tt><u><ul>');
        // Replace some blank characters.
        $html = preg_replace('/<pre/', '<xre', $html); // Preserve pre tag.
        $html = preg_replace('/<(table|tr|td|th|tcpdf|blockquote|dd|div|dl|dt|form|h1|h2|h3|h4|h5|h6|br|hr|li|ol|ul|p)
                             ([^\>]*)>[\n\r\t]+/', '<\\1\\2>', $html);
        $html = preg_replace('@(\r\n|\r)@', "\n", $html);
        $reptable = array("\t" => ' ', "\0" => ' ', "\x0B" => ' ', "\\" => "\\\\");
        $html = strtr($html, $reptable);
        $offset = 0;
        while (($offset < strlen($html)) AND ($pos = strpos($html, '</pre>', $offset)) !== false) {
            $htmla = substr($html, 0, $offset);
            $htmlb = substr($html, $offset, ($pos - $offset + 6));
            while (preg_match("'<xre([^\>]*)>(.*?)\n(.*?)</pre>'si", $htmlb)) {
                // Preserve newlines on <pre> tag.
                $htmlb = preg_replace("'<xre([^\>]*)>(.*?)\n(.*?)</pre>'si", "<xre\\1>\\2<br />\\3</pre>", $htmlb);
            }
            while (preg_match("'<xre([^\>]*)>(.*?)".$this->respace['p']."(.*?)</pre>'".$this->respace['m'], $htmlb)) {
                // Preserve spaces on <pre> tag.
                $htmlb = preg_replace("'<xre([^\>]*)>(.*?)".$this->respace['p']."(.*?)</pre>'".$this->respace['m'],
                                       "<xre\\1>\\2&nbsp;\\3</pre>", $htmlb);
            }
            $html = $htmla.$htmlb.substr($html, $pos + 6);
            $offset = strlen($htmla.$htmlb);
        }
        $offset = 0;
        while (($offset < strlen($html)) AND ($pos = strpos($html, '</textarea>', $offset)) !== false) {
            $htmla = substr($html, 0, $offset);
            $htmlb = substr($html, $offset, ($pos - $offset + 11));
            while (preg_match("'<textarea([^\>]*)>(.*?)\n(.*?)</textarea>'si", $htmlb)) {
                // Ppreserve newlines on <textarea> tag.
                $htmlb = preg_replace("'<textarea([^\>]*)>(.*?)\n(.*?)</textarea>'si",
                                       "<textarea\\1>\\2<TBR>\\3</textarea>", $htmlb);
                $htmlb = preg_replace("'<textarea([^\>]*)>(.*?)[\"](.*?)</textarea>'si",
                                       "<textarea\\1>\\2''\\3</textarea>", $htmlb);
            }
            $html = $htmla.$htmlb.substr($html, $pos + 11);
            $offset = strlen($htmla.$htmlb);
        }
        $html = preg_replace('/([\s]*)<option/si', '<option', $html);
        $html = preg_replace('/<\/option>([\s]*)/si', '</option>', $html);
        $offset = 0;
        while (($offset < strlen($html)) AND ($pos = strpos($html, '</option>', $offset)) !== false) {
            $htmla = substr($html, 0, $offset);
            $htmlb = substr($html, $offset, ($pos - $offset + 9));
            while (preg_match("'<option([^\>]*)>(.*?)</option>'si", $htmlb)) {
                $htmlb = preg_replace("'<option([\s]+)value=\"([^\"]*)\"([^\>]*)>(.*?)</option>'si",
                                       "\\2#!TaB!#\\4#!NwL!#", $htmlb);
                $htmlb = preg_replace("'<option([^\>]*)>(.*?)</option>'si", "\\2#!NwL!#", $htmlb);
            }
            $html = $htmla.$htmlb.substr($html, $pos + 9);
            $offset = strlen($htmla.$htmlb);
        }
        if (preg_match("'</select'si", $html)) {
            $html = preg_replace("'<select([^\>]*)>'si", "<select\\1 opt=\"", $html);
            $html = preg_replace("'#!NwL!#</select>'si", "\" />", $html);
        }
        $html = str_replace("\n", ' ', $html);
        // Restore textarea newlines.
        $html = str_replace('<TBR>', "\n", $html);
        // Remove extra spaces from code.
        $html = preg_replace('/[\s]+<\/(table|tr|ul|ol|dl)>/', '</\\1>', $html);
        $html = preg_replace('/'.$this->respace['p'].'+<\/(td|th|li|dt|dd)>/'.$this->respace['m'], '</\\1>', $html);
        $html = preg_replace('/[\s]+<(tr|td|th|li|dt|dd)/', '<\\1', $html);
        $html = preg_replace('/'.$this->respace['p'].'+<(ul|ol|dl|br)/'.$this->respace['m'], '<\\1', $html);
        $html = preg_replace('/<\/(table|tr|td|th|blockquote|dd|dt|dl|div|dt|h1|h2|h3|h4|h5|h6|hr|li|ol|ul|p)>[\s]+</',
                             '</\\1><', $html);
        $html = preg_replace('/<\/(td|th)>/', '<marker style="font-size:0"/></\\1>', $html);
        $html = preg_replace('/<\/table>([\s]*)<marker style="font-size:0"\/>/', '</table>', $html);
        $html = preg_replace('/'.$this->respace['p'].'+<img/'.$this->respace['m'], chr(32).'<img', $html);
        $html = preg_replace('/<img([^\>]*)>[\s]+([^\<])/xi', '<img\\1>&nbsp;\\2', $html);
        $html = preg_replace('/<img([^\>]*)>/xi', '<img\\1><span><marker style="font-size:0"/></span>', $html);
        $html = preg_replace('/<xre/', '<pre', $html); // Restore pre tag.
        $html = preg_replace('/<textarea([^\>]*)>([^\<]*)<\/textarea>/xi', '<textarea\\1 value="\\2" />', $html);
        $html = preg_replace('/<li([^\>]*)><\/li>/', '<li\\1>&nbsp;</li>', $html);
        $html = preg_replace('/<li([^\>]*)>'.$this->respace['p'].'*<img/'.$this->respace['m'],
                             '<li\\1><font size="1">&nbsp;</font><img', $html);
        $html = preg_replace('/<([^\>\/]*)>[\s]/', '<\\1>&nbsp;', $html); // Preserve some spaces.
        $html = preg_replace('/[\s]<\/([^\>]*)>/', '&nbsp;</\\1>', $html); // Preserve some spaces.
        $html = preg_replace('/<su([bp])/', '<zws/><su\\1', $html); // Fix sub/sup alignment.
        $html = preg_replace('/<\/su([bp])>/', '</su\\1><zws/>', $html); // Fix sub/sup alignment.
        $html = preg_replace('/'.$this->respace['p'].'+/'.$this->respace['m'], chr(32), $html);
        // Replace multiple spaces with a single space
        // Trim string.
        $html = $this->stringtrim($html);
        // Fix first image tag alignment.
        $html = preg_replace('/^<img/', '<span style="font-size:0"><br /></span> <img', $html, 1);
        // Pattern for generic tag.
        $tagpattern = '/(<[^>]+>)/';
        // Explodes the string.
        $a = preg_split($tagpattern, $html, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
        // Count elements.
        $maxel = count($a);
        $elkey = 0;
        $key = 0;
        // Create an array of elements.
        $dom = array();
        $dom[$key] = array();
        $dom[$key]['tag'] = false;
        $dom[$key]['block'] = false;
        $dom[$key]['value'] = '';
        $dom[$key]['parent'] = 0;
        $dom[$key]['hide'] = false;
        $dom[$key]['fontname'] = $this->fontfamily;
        $dom[$key]['fontstyle'] = $this->fontstyle;
        $dom[$key]['fontsize'] = $this->fontsizept;
        $dom[$key]['font-stretch'] = $this->fontstretching;
        $dom[$key]['letter-spacing'] = $this->fontspacing;
        $dom[$key]['stroke'] = $this->textstrokewidth;
        $dom[$key]['fill'] = (($this->textrendermode % 2) == 0);
        $dom[$key]['clip'] = ($this->textrendermode > 3);
        $dom[$key]['line-height'] = $this->cellheightratio;
        $dom[$key]['bgcolor'] = false;
        $dom[$key]['fgcolor'] = $this->fgcolor; // Color.
        $dom[$key]['strokecolor'] = $this->strokecolor;
        $dom[$key]['align'] = '';
        $dom[$key]['listtype'] = '';
        $dom[$key]['text-indent'] = 0;
        $dom[$key]['border'] = array();
        $dom[$key]['dir'] = $this->rtl ? 'rtl' : 'ltr';
        $thead = false; // True when we are inside the THEAD tag.
        ++$key;
        $level = array();
        array_push($level, 0); // Root.
        while ($elkey < $maxel) {
            $dom[$key] = array();
            $element = $a[$elkey];
            $dom[$key]['elkey'] = $elkey;
            if (preg_match($tagpattern, $element)) {
                // Html tag.
                $element = substr($element, 1, -1);
                // Get tag name.
                preg_match('/[\/]?([a-zA-Z0-9]*)/', $element, $tag);
                $tagname = strtolower($tag[1]);
                // Check if we are inside a table header.
                if ($tagname == 'thead') {
                    if ($element{0} == '/') {
                        $thead = false;
                    } else {
                        $thead = true;
                    }
                    ++$elkey;
                    continue;
                }
                $dom[$key]['tag'] = true;
                $dom[$key]['value'] = $tagname;
                if (in_array($dom[$key]['value'], $blocktags)) {
                    $dom[$key]['block'] = true;
                } else {
                    $dom[$key]['block'] = false;
                }
                if ($element{0} == '/') {
                    // Closing html tag.
                    $dom[$key]['opening'] = false;
                    $dom[$key]['parent'] = end($level);
                    array_pop($level);
                    $dom[$key]['hide'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['hide'];
                    $dom[$key]['fontname'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fontname'];
                    $dom[$key]['fontstyle'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fontstyle'];
                    $dom[$key]['fontsize'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fontsize'];
                    $dom[$key]['font-stretch'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['font-stretch'];
                    $dom[$key]['letter-spacing'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['letter-spacing'];
                    $dom[$key]['stroke'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['stroke'];
                    $dom[$key]['fill'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fill'];
                    $dom[$key]['clip'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['clip'];
                    $dom[$key]['line-height'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['line-height'];
                    $dom[$key]['bgcolor'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['bgcolor'];
                    $dom[$key]['fgcolor'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fgcolor'];
                    $dom[$key]['strokecolor'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['strokecolor'];
                    $dom[$key]['align'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['align'];
                    $dom[$key]['dir'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['dir'];
                    if (isset($dom[($dom[($dom[$key]['parent'])]['parent'])]['listtype'])) {
                        $dom[$key]['listtype'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['listtype'];
                    }
                    // Set the number of columns in table tag.
                    if (($dom[$key]['value'] == 'tr') AND
                       (!isset($dom[($dom[($dom[$key]['parent'])]['parent'])]['cols']))) {
                        $dom[($dom[($dom[$key]['parent'])]['parent'])]['cols'] = $dom[($dom[$key]['parent'])]['cols'];
                    }
                    if (($dom[$key]['value'] == 'td') OR ($dom[$key]['value'] == 'th')) {
                        $dom[($dom[$key]['parent'])]['content'] = $csstagarray;
                        for ($i = ($dom[$key]['parent'] + 1); $i < $key; ++$i) {
                            $dom[($dom[$key]['parent'])]['content'] .= $a[$dom[$i]['elkey']];
                        }
                        $key = $i;
                        // Mark nested tables.
                        $dom[($dom[$key]['parent'])]['content'] = str_replace('<table', '<table nested="true"',
                        $dom[($dom[$key]['parent'])]['content']);
                        // Remove thead sections from nested tables.
                        $dom[($dom[$key]['parent'])]['content'] = str_replace('<thead>', '',
                        $dom[($dom[$key]['parent'])]['content']);
                        $dom[($dom[$key]['parent'])]['content'] = str_replace('</thead>', '',
                        $dom[($dom[$key]['parent'])]['content']);
                    }
                    // Store header rows on a new table.
                    if (($dom[$key]['value'] == 'tr') AND ($dom[($dom[$key]['parent'])]['thead'] === true)) {
                        if ($this->empty_string($dom[($dom[($dom[$key]['parent'])]['parent'])]['thead'])) {
                            $dom[($dom[($dom[$key]['parent'])]['parent'])]['thead'] =
                              $csstagarray.$a[$dom[($dom[($dom[$key]['parent'])]['parent'])]['elkey']];
                        }
                        for ($i = $dom[$key]['parent']; $i <= $key; ++$i) {
                            $dom[($dom[($dom[$key]['parent'])]['parent'])]['thead'] .= $a[$dom[$i]['elkey']];
                        }
                        if (!isset($dom[($dom[$key]['parent'])]['attribute'])) {
                            $dom[($dom[$key]['parent'])]['attribute'] = array();
                        }
                        // Header elements must be always contained in a single page.
                        $dom[($dom[$key]['parent'])]['attribute']['nobr'] = 'true';
                    }
                    if (($dom[$key]['value'] == 'table') AND (!$this->empty_string($dom[($dom[$key]['parent'])]['thead']))) {
                        // Remove the nobr attributes from the table header.
                        $dom[($dom[$key]['parent'])]['thead'] = str_replace(' nobr="true"', '',
                        $dom[($dom[$key]['parent'])]['thead']);
                        $dom[($dom[$key]['parent'])]['thead'] .= '</tablehead>';
                    }
                } else {
                    // Opening or self-closing html tag.
                    $dom[$key]['opening'] = true;
                    $dom[$key]['parent'] = end($level);
                    if ((substr($element, -1, 1) == '/') OR (in_array($dom[$key]['value'], $selfclosingtags))) {
                        // Self-closing tag.
                        $dom[$key]['self'] = true;
                    } else {
                        // Opening tag.
                        array_push($level, $key);
                        $dom[$key]['self'] = false;
                    }
                    // Copy some values from parent.
                    $parentkey = 0;
                    if ($key > 0) {
                        $parentkey = $dom[$key]['parent'];
                        $dom[$key]['hide'] = $dom[$parentkey]['hide'];
                        $dom[$key]['fontname'] = $dom[$parentkey]['fontname'];
                        $dom[$key]['fontstyle'] = $dom[$parentkey]['fontstyle'];
                        $dom[$key]['fontsize'] = $dom[$parentkey]['fontsize'];
                        $dom[$key]['font-stretch'] = $dom[$parentkey]['font-stretch'];
                        $dom[$key]['letter-spacing'] = $dom[$parentkey]['letter-spacing'];
                        $dom[$key]['stroke'] = $dom[$parentkey]['stroke'];
                        $dom[$key]['fill'] = $dom[$parentkey]['fill'];
                        $dom[$key]['clip'] = $dom[$parentkey]['clip'];
                        $dom[$key]['line-height'] = $dom[$parentkey]['line-height'];
                        $dom[$key]['bgcolor'] = $dom[$parentkey]['bgcolor'];
                        $dom[$key]['fgcolor'] = $dom[$parentkey]['fgcolor'];
                        $dom[$key]['strokecolor'] = $dom[$parentkey]['strokecolor'];
                        $dom[$key]['align'] = $dom[$parentkey]['align'];
                        $dom[$key]['listtype'] = $dom[$parentkey]['listtype'];
                        $dom[$key]['text-indent'] = $dom[$parentkey]['text-indent'];
                        $dom[$key]['border'] = array();
                        $dom[$key]['dir'] = $dom[$parentkey]['dir'];
                    }
                    // Get attributes.
                    preg_match_all('/([^=\s]*)[\s]*=[\s]*"([^"]*)"/', $element, $attrarray, PREG_PATTERN_ORDER);
                    $dom[$key]['attribute'] = array(); // Reset attribute array.
                    while (list($id, $name) = each($attrarray[1])) {
                        $dom[$key]['attribute'][strtolower($name)] = $attrarray[2][$id];
                    }
                    if (!empty($css)) {
                        // Merge CSS style to current style.
                        list($dom[$key]['csssel'], $dom[$key]['cssdata']) = $this->getcssdataarray($dom, $key, $css);
                        $dom[$key]['attribute']['style'] = $this->gettagstylefromcssarray($dom[$key]['cssdata']);
                    }
                    // Split style attributes.
                    if (isset($dom[$key]['attribute']['style']) AND !empty($dom[$key]['attribute']['style'])) {
                        // Get style attributes.
                        preg_match_all('/([^;:\s]*):([^;]*)/', $dom[$key]['attribute']['style'], $stylearray,
                                       PREG_PATTERN_ORDER);
                        $dom[$key]['style'] = array(); // Reset style attribute array.
                        while (list($id, $name) = each($stylearray[1])) {
                            // In case of duplicate attribute the last replace the previous.
                            $dom[$key]['style'][strtolower($name)] = trim($stylearray[2][$id]);
                        }
                        // Get some style attributes.
                        // Text direction.
                        if (isset($dom[$key]['style']['direction'])) {
                            $dom[$key]['dir'] = $dom[$key]['style']['direction'];
                        }
                        // Display.
                        if (isset($dom[$key]['style']['display'])) {
                            $dom[$key]['hide'] = (trim(strtolower($dom[$key]['style']['display'])) == 'none');
                        }
                        // Font family.
                        if (isset($dom[$key]['style']['font-family'])) {
                            $dom[$key]['fontname'] = $this->getfontfamilyname($dom[$key]['style']['font-family']);
                        }
                        // List-style-type.
                        if (isset($dom[$key]['style']['list-style-type'])) {
                            $dom[$key]['listtype'] = trim(strtolower($dom[$key]['style']['list-style-type']));
                            if ($dom[$key]['listtype'] == 'inherit') {
                                $dom[$key]['listtype'] = $dom[$parentkey]['listtype'];
                            }
                        }
                        // Text-indent.
                        if (isset($dom[$key]['style']['text-indent'])) {
                            $dom[$key]['text-indent'] = $this->gethtmlunittounits($dom[$key]['style']['text-indent']);
                            if ($dom[$key]['text-indent'] == 'inherit') {
                                $dom[$key]['text-indent'] = $dom[$parentkey]['text-indent'];
                            }
                        }
                        // Font size.
                        if (isset($dom[$key]['style']['font-size'])) {
                            $fsize = trim($dom[$key]['style']['font-size']);
                            switch ($fsize) {
                                // Absolute-size.
                                case 'xx-small': {
                                    $dom[$key]['fontsize'] = $dom[0]['fontsize'] - 4;
                                    break;
                                }
                                case 'x-small': {
                                    $dom[$key]['fontsize'] = $dom[0]['fontsize'] - 3;
                                    break;
                                }
                                case 'small': {
                                    $dom[$key]['fontsize'] = $dom[0]['fontsize'] - 2;
                                    break;
                                }
                                case 'medium': {
                                    $dom[$key]['fontsize'] = $dom[0]['fontsize'];
                                    break;
                                }
                                case 'large': {
                                    $dom[$key]['fontsize'] = $dom[0]['fontsize'] + 2;
                                    break;
                                }
                                case 'x-large': {
                                    $dom[$key]['fontsize'] = $dom[0]['fontsize'] + 4;
                                    break;
                                }
                                case 'xx-large': {
                                    $dom[$key]['fontsize'] = $dom[0]['fontsize'] + 6;
                                    break;
                                }
                                // Relative-size.
                                case 'smaller': {
                                    $dom[$key]['fontsize'] = $dom[$parentkey]['fontsize'] - 3;
                                    break;
                                }
                                case 'larger': {
                                    $dom[$key]['fontsize'] = $dom[$parentkey]['fontsize'] + 3;
                                    break;
                                }
                                default: {
                                    $dom[$key]['fontsize'] = $this->gethtmlunittounits($fsize, $dom[$parentkey]['fontsize'],
                                                             'pt', true);
                                }
                            }
                        }
                        // Font-stretch.
                        if (isset($dom[$key]['style']['font-stretch'])) {
                            $dom[$key]['font-stretch'] = $this->getcssfontstretching($dom[$key]['style']['font-stretch'],
                                $dom[$parentkey]['font-stretch']);
                        }
                        // Letter-spacing.
                        if (isset($dom[$key]['style']['letter-spacing'])) {
                            $dom[$key]['letter-spacing'] = $this->getcssfontspacing($dom[$key]['style']['letter-spacing'],
                                $dom[$parentkey]['letter-spacing']);
                        }
                        // Line-height.
                        if (isset($dom[$key]['style']['line-height'])) {
                            $lineheight = trim($dom[$key]['style']['line-height']);
                            switch ($lineheight) {
                                // A normal line height. This is default.
                                case 'normal': {
                                    $dom[$key]['line-height'] = $dom[0]['line-height'];
                                    break;
                                }
                                default: {
                                    if (is_numeric($lineheight)) {
                                        $lineheight = $lineheight * 100;
                                    }
                                    $dom[$key]['line-height'] = $this->gethtmlunittounits($lineheight, 1, '%', true);
                                }
                            }
                        }
                        // Font style.
                        if (isset($dom[$key]['style']['font-weight'])) {
                            if (strtolower($dom[$key]['style']['font-weight']{0}) == 'n') {
                                if (strpos($dom[$key]['fontstyle'], 'B') !== false) {
                                    $dom[$key]['fontstyle'] = str_replace('B', '', $dom[$key]['fontstyle']);
                                }
                            } else if (strtolower($dom[$key]['style']['font-weight']{0}) == 'b') {
                                $dom[$key]['fontstyle'] .= 'B';
                            }
                        }
                        if (isset($dom[$key]['style']['font-style']) AND
                           (strtolower($dom[$key]['style']['font-style']{0}) == 'i')) {
                            $dom[$key]['fontstyle'] .= 'I';
                        }
                        // Font color.
                        if (isset($dom[$key]['style']['color']) AND (!$this->empty_string($dom[$key]['style']['color']))) {
                            $dom[$key]['fgcolor'] = $this->converthtmlcolortodec($dom[$key]['style']['color']);
                        } else if ($dom[$key]['value'] == 'a') {
                            $dom[$key]['fgcolor'] = $this->htmllinkcolorarray;
                        }
                        // Background color.
                        if (isset($dom[$key]['style']['background-color']) AND
                           (!$this->empty_string($dom[$key]['style']['background-color']))) {
                            $dom[$key]['bgcolor'] = $this->converthtmlcolortodec($dom[$key]['style']['background-color']);
                        }
                        // Text-decoration.
                        if (isset($dom[$key]['style']['text-decoration'])) {
                            $decors = explode(' ', strtolower($dom[$key]['style']['text-decoration']));
                            foreach ($decors as $dec) {
                                $dec = trim($dec);
                                if (!$this->empty_string($dec)) {
                                    if ($dec{0} == 'u') {
                                        // Underline.
                                        $dom[$key]['fontstyle'] .= 'U';
                                    } else if ($dec{0} == 'l') {
                                        // Line-trough.
                                        $dom[$key]['fontstyle'] .= 'D';
                                    } else if ($dec{0} == 'o') {
                                        // Overline.
                                        $dom[$key]['fontstyle'] .= 'O';
                                    }
                                }
                            }
                        } else if ($dom[$key]['value'] == 'a') {
                            $dom[$key]['fontstyle'] = $this->htmllinkfontstyle;
                        }
                        // Check for width attribute.
                        if (isset($dom[$key]['style']['width'])) {
                            $dom[$key]['width'] = $dom[$key]['style']['width'];
                        }
                        // Check for height attribute.
                        if (isset($dom[$key]['style']['height'])) {
                            $dom[$key]['height'] = $dom[$key]['style']['height'];
                        }
                        // Check for text alignment.
                        if (isset($dom[$key]['style']['text-align'])) {
                            $dom[$key]['align'] = strtoupper($dom[$key]['style']['text-align']{0});
                        }
                        // Check for CSS border properties.
                        if (isset($dom[$key]['style']['border'])) {
                            $borderstyle = $this->getcssborderstyle($dom[$key]['style']['border']);
                            if (!empty($borderstyle)) {
                                $dom[$key]['border']['LTRB'] = $borderstyle;
                            }
                        }
                        if (isset($dom[$key]['style']['border-color'])) {
                            $brdcolors = preg_split('/[\s]+/', trim($dom[$key]['style']['border-color']));
                            if (isset($brdcolors[3])) {
                                $dom[$key]['border']['L']['color'] = $this->converthtmlcolortodec($brdcolors[3]);
                            }
                            if (isset($brdcolors[1])) {
                                $dom[$key]['border']['R']['color'] = $this->converthtmlcolortodec($brdcolors[1]);
                            }
                            if (isset($brdcolors[0])) {
                                $dom[$key]['border']['T']['color'] = $this->converthtmlcolortodec($brdcolors[0]);
                            }
                            if (isset($brdcolors[2])) {
                                $dom[$key]['border']['B']['color'] = $this->converthtmlcolortodec($brdcolors[2]);
                            }
                        }
                        if (isset($dom[$key]['style']['border-width'])) {
                            $brdwidths = preg_split('/[\s]+/', trim($dom[$key]['style']['border-width']));
                            if (isset($brdwidths[3])) {
                                $dom[$key]['border']['L']['width'] = $this->getcssborderwidth($brdwidths[3]);
                            }
                            if (isset($brdwidths[1])) {
                                $dom[$key]['border']['R']['width'] = $this->getcssborderwidth($brdwidths[1]);
                            }
                            if (isset($brdwidths[0])) {
                                $dom[$key]['border']['T']['width'] = $this->getcssborderwidth($brdwidths[0]);
                            }
                            if (isset($brdwidths[2])) {
                                $dom[$key]['border']['B']['width'] = $this->getcssborderwidth($brdwidths[2]);
                            }
                        }
                        if (isset($dom[$key]['style']['border-style'])) {
                            $brdstyles = preg_split('/[\s]+/', trim($dom[$key]['style']['border-style']));
                            if (isset($brdstyles[3])) {
                                $dom[$key]['border']['L']['cap'] = 'square';
                                $dom[$key]['border']['L']['join'] = 'miter';
                                $dom[$key]['border']['L']['dash'] = $this->getcssborderdashstyle($brdstyles[3]);
                                if ($dom[$key]['border']['L']['dash'] < 0) {
                                    $dom[$key]['border']['L'] = array();
                                }
                            }
                            if (isset($brdstyles[1])) {
                                $dom[$key]['border']['R']['cap'] = 'square';
                                $dom[$key]['border']['R']['join'] = 'miter';
                                $dom[$key]['border']['R']['dash'] = $this->getcssborderdashstyle($brdstyles[1]);
                                if ($dom[$key]['border']['R']['dash'] < 0) {
                                    $dom[$key]['border']['R'] = array();
                                }
                            }
                            if (isset($brdstyles[0])) {
                                $dom[$key]['border']['T']['cap'] = 'square';
                                $dom[$key]['border']['T']['join'] = 'miter';
                                $dom[$key]['border']['T']['dash'] = $this->getcssborderdashstyle($brdstyles[0]);
                                if ($dom[$key]['border']['T']['dash'] < 0) {
                                    $dom[$key]['border']['T'] = array();
                                }
                            }
                            if (isset($brdstyles[2])) {
                                $dom[$key]['border']['B']['cap'] = 'square';
                                $dom[$key]['border']['B']['join'] = 'miter';
                                $dom[$key]['border']['B']['dash'] = $this->getcssborderdashstyle($brdstyles[2]);
                                if ($dom[$key]['border']['B']['dash'] < 0) {
                                    $dom[$key]['border']['B'] = array();
                                }
                            }
                        }
                        $cellside = array('L' => 'left', 'R' => 'right', 'T' => 'top', 'B' => 'bottom');
                        foreach ($cellside as $bsk => $bsv) {
                            if (isset($dom[$key]['style']['border-'.$bsv])) {
                                $borderstyle = $this->getcssborderstyle($dom[$key]['style']['border-'.$bsv]);
                                if (!empty($borderstyle)) {
                                    $dom[$key]['border'][$bsk] = $borderstyle;
                                }
                            }
                            if (isset($dom[$key]['style']['border-'.$bsv.'-color'])) {
                                $dom[$key]['border'][$bsk]['color'] =
                                  $this->converthtmlcolortodec($dom[$key]['style']['border-'.$bsv.'-color']);
                            }
                            if (isset($dom[$key]['style']['border-'.$bsv.'-width'])) {
                                $dom[$key]['border'][$bsk]['width'] =
                                $this->getcssborderwidth($dom[$key]['style']['border-'.$bsv.'-width']);
                            }
                            if (isset($dom[$key]['style']['border-'.$bsv.'-style'])) {
                                $dom[$key]['border'][$bsk]['dash'] =
                                $this->getcssborderdashstyle($dom[$key]['style']['border-'.$bsv.'-style']);
                                if ($dom[$key]['border'][$bsk]['dash'] < 0) {
                                    $dom[$key]['border'][$bsk] = array();
                                }
                            }
                        }
                        // Check for CSS padding properties.
                        if (isset($dom[$key]['style']['padding'])) {
                            $dom[$key]['padding'] = $this->getcsspadding($dom[$key]['style']['padding']);
                        } else {
                            $dom[$key]['padding'] = $this->cellpadding;
                        }
                        foreach ($cellside as $psk => $psv) {
                            if (isset($dom[$key]['style']['padding-'.$psv])) {
                                $dom[$key]['padding'][$psk] =
                                $this->gethtmlunittounits($dom[$key]['style']['padding-'.$psv], 0, 'px', false);
                            }
                        }
                        // Check for CSS margin properties.
                        if (isset($dom[$key]['style']['margin'])) {
                            $dom[$key]['margin'] = $this->getcssmargin($dom[$key]['style']['margin']);
                        } else {
                            $dom[$key]['margin'] = $this->cellmargin;
                        }
                        foreach ($cellside as $psk => $psv) {
                            if (isset($dom[$key]['style']['margin-'.$psv])) {
                                $dom[$key]['margin'][$psk] =
                                $this->gethtmlunittounits(str_replace('auto', '0', $dom[$key]['style']['margin-'.$psv]), 0,
                                                          'px', false);
                            }
                        }
                        // Check for CSS border-spacing properties.
                        if (isset($dom[$key]['style']['border-spacing'])) {
                            $dom[$key]['border-spacing'] = $this->getcssbordermargin($dom[$key]['style']['border-spacing']);
                        }
                        // Page-break-inside.
                        if (isset($dom[$key]['style']['page-break-inside']) AND
                        ($dom[$key]['style']['page-break-inside'] == 'avoid')) {
                            $dom[$key]['attribute']['nobr'] = 'true';
                        }
                        // Page-break-before.
                        if (isset($dom[$key]['style']['page-break-before'])) {
                            if ($dom[$key]['style']['page-break-before'] == 'always') {
                                $dom[$key]['attribute']['pagebreak'] = 'true';
                            } else if ($dom[$key]['style']['page-break-before'] == 'left') {
                                $dom[$key]['attribute']['pagebreak'] = 'left';
                            } else if ($dom[$key]['style']['page-break-before'] == 'right') {
                                $dom[$key]['attribute']['pagebreak'] = 'right';
                            }
                        }
                        // Page-break-after.
                        if (isset($dom[$key]['style']['page-break-after'])) {
                            if ($dom[$key]['style']['page-break-after'] == 'always') {
                                $dom[$key]['attribute']['pagebreakafter'] = 'true';
                            } else if ($dom[$key]['style']['page-break-after'] == 'left') {
                                $dom[$key]['attribute']['pagebreakafter'] = 'left';
                            } else if ($dom[$key]['style']['page-break-after'] == 'right') {
                                $dom[$key]['attribute']['pagebreakafter'] = 'right';
                            }
                        }
                    }
                    if (isset($dom[$key]['attribute']['display'])) {
                        $dom[$key]['hide'] = (trim(strtolower($dom[$key]['attribute']['display'])) == 'none');
                    }
                    if (isset($dom[$key]['attribute']['border']) AND ($dom[$key]['attribute']['border'] != 0)) {
                        $borderstyle = $this->getcssborderstyle($dom[$key]['attribute']['border'].' solid black');
                        if (!empty($borderstyle)) {
                            $dom[$key]['border']['LTRB'] = $borderstyle;
                        }
                    }
                    // Check for font tag.
                    if ($dom[$key]['value'] == 'font') {
                        // Font family.
                        if (isset($dom[$key]['attribute']['face'])) {
                            $dom[$key]['fontname'] = $this->getfontfamilyname($dom[$key]['attribute']['face']);
                        }
                        // Font size.
                        if (isset($dom[$key]['attribute']['size'])) {
                            if ($key > 0) {
                                if ($dom[$key]['attribute']['size']{0} == '+') {
                                    $dom[$key]['fontsize'] = $dom[($dom[$key]['parent'])]['fontsize'] +
                                    intval(substr($dom[$key]['attribute']['size'], 1));
                                } else if ($dom[$key]['attribute']['size']{0} == '-') {
                                    $dom[$key]['fontsize'] = $dom[($dom[$key]['parent'])]['fontsize'] -
                                    intval(substr($dom[$key]['attribute']['size'], 1));
                                } else {
                                    $dom[$key]['fontsize'] = intval($dom[$key]['attribute']['size']);
                                }
                            } else {
                                $dom[$key]['fontsize'] = intval($dom[$key]['attribute']['size']);
                            }
                        }
                    }
                    // Force natural alignment for lists.
                    if ((($dom[$key]['value'] == 'ul') OR ($dom[$key]['value'] == 'ol') OR
                       ($dom[$key]['value'] == 'dl'))
                        AND (!isset($dom[$key]['align']) OR $this->empty_string($dom[$key]['align']) OR
                             ($dom[$key]['align'] != 'J'))) {
                        if ($this->rtl) {
                            $dom[$key]['align'] = 'R';
                        } else {
                            $dom[$key]['align'] = 'L';
                        }
                    }
                    if (($dom[$key]['value'] == 'small') OR ($dom[$key]['value'] == 'sup') OR
                        ($dom[$key]['value'] == 'sub')) {
                        if (!isset($dom[$key]['attribute']['size']) AND !isset($dom[$key]['style']['font-size'])) {
                            $dom[$key]['fontsize'] = $dom[$key]['fontsize'] * K_SMALL_RATIO;
                        }
                    }
                    if (($dom[$key]['value'] == 'strong') OR ($dom[$key]['value'] == 'b')) {
                        $dom[$key]['fontstyle'] .= 'B';
                    }
                    if (($dom[$key]['value'] == 'em') OR ($dom[$key]['value'] == 'i')) {
                        $dom[$key]['fontstyle'] .= 'I';
                    }
                    if ($dom[$key]['value'] == 'u') {
                        $dom[$key]['fontstyle'] .= 'U';
                    }
                    if (($dom[$key]['value'] == 'del') OR ($dom[$key]['value'] == 's') OR
                        ($dom[$key]['value'] == 'strike')) {
                        $dom[$key]['fontstyle'] .= 'D';
                    }
                    if (!isset($dom[$key]['style']['text-decoration']) AND ($dom[$key]['value'] == 'a')) {
                        $dom[$key]['fontstyle'] = $this->htmllinkfontstyle;
                    }
                    if (($dom[$key]['value'] == 'pre') OR ($dom[$key]['value'] == 'tt')) {
                        $dom[$key]['fontname'] = $this->defaultmonospacedfont;
                    }
                    if (($dom[$key]['value']{0} == 'h') AND (intval($dom[$key]['value']{1}) > 0) AND
                        (intval($dom[$key]['value']{1}) < 7)) {
                        // Headings h1, h2, h3, h4, h5, h6.
                        if (!isset($dom[$key]['attribute']['size']) AND !isset($dom[$key]['style']['font-size'])) {
                            $headsize = (4 - intval($dom[$key]['value']{1})) * 2;
                            $dom[$key]['fontsize'] = $dom[0]['fontsize'] + $headsize;
                        }
                        if (!isset($dom[$key]['style']['font-weight'])) {
                            $dom[$key]['fontstyle'] .= 'B';
                        }
                    }
                    if (($dom[$key]['value'] == 'table')) {
                        $dom[$key]['rows'] = 0; // Number of rows.
                        $dom[$key]['trids'] = array(); // IDs of TR elements.
                        $dom[$key]['thead'] = ''; // Table header rows.
                    }
                    if (($dom[$key]['value'] == 'tr')) {
                        $dom[$key]['cols'] = 0;
                        if ($thead) {
                            $dom[$key]['thead'] = true;
                            // Rows on thead block are printed as a separate table.
                        } else {
                            $dom[$key]['thead'] = false;
                            // Store the number of rows on table element.
                            ++$dom[($dom[$key]['parent'])]['rows'];
                            // Store the TR elements IDs on table element.
                            array_push($dom[($dom[$key]['parent'])]['trids'], $key);
                        }
                    }
                    if (($dom[$key]['value'] == 'th') OR ($dom[$key]['value'] == 'td')) {
                        if (isset($dom[$key]['attribute']['colspan'])) {
                            $colspan = intval($dom[$key]['attribute']['colspan']);
                        } else {
                            $colspan = 1;
                        }
                        $dom[$key]['attribute']['colspan'] = $colspan;
                        $dom[($dom[$key]['parent'])]['cols'] += $colspan;
                    }
                    // Text direction.
                    if (isset($dom[$key]['attribute']['dir'])) {
                        $dom[$key]['dir'] = $dom[$key]['attribute']['dir'];
                    }
                    // Set foreground color attribute.
                    if (isset($dom[$key]['attribute']['color']) AND
                       (!$this->empty_string($dom[$key]['attribute']['color']))) {
                        $dom[$key]['fgcolor'] = $this->converthtmlcolortodec($dom[$key]['attribute']['color']);
                    } else if (!isset($dom[$key]['style']['color']) AND ($dom[$key]['value'] == 'a')) {
                        $dom[$key]['fgcolor'] = $this->htmllinkcolorarray;
                    }
                    // Set background color attribute.
                    if (isset($dom[$key]['attribute']['bgcolor']) AND
                       (!$this->empty_string($dom[$key]['attribute']['bgcolor']))) {
                        $dom[$key]['bgcolor'] = $this->converthtmlcolortodec($dom[$key]['attribute']['bgcolor']);
                    }
                    // Set stroke color attribute.
                    if (isset($dom[$key]['attribute']['strokecolor']) AND
                        (!$this->empty_string($dom[$key]['attribute']['strokecolor']))) {
                        $dom[$key]['strokecolor'] = $this->converthtmlcolortodec($dom[$key]['attribute']['strokecolor']);
                    }
                    // Check for width attribute.
                    if (isset($dom[$key]['attribute']['width'])) {
                        $dom[$key]['width'] = $dom[$key]['attribute']['width'];
                    }
                    // Check for height attribute.
                    if (isset($dom[$key]['attribute']['height'])) {
                        $dom[$key]['height'] = $dom[$key]['attribute']['height'];
                    }
                    // Check for text alignment.
                    if (isset($dom[$key]['attribute']['align']) AND (!$this->empty_string($dom[$key]['attribute']['align']))
                        AND ($dom[$key]['value'] !== 'img')) {
                        $dom[$key]['align'] = strtoupper($dom[$key]['attribute']['align']{0});
                    }
                    // Check for text rendering mode (the following attributes do not exist in HTML).
                    if (isset($dom[$key]['attribute']['stroke'])) {
                        // Font stroke width.
                        $dom[$key]['stroke'] = $this->gethtmlunittounits($dom[$key]['attribute']['stroke'],
                        $dom[$key]['fontsize'], 'pt', true);
                    }
                    if (isset($dom[$key]['attribute']['fill'])) {
                        // Font fill.
                        if ($dom[$key]['attribute']['fill'] == 'true') {
                            $dom[$key]['fill'] = true;
                        } else {
                            $dom[$key]['fill'] = false;
                        }
                    }
                    if (isset($dom[$key]['attribute']['clip'])) {
                        // Clipping mode.
                        if ($dom[$key]['attribute']['clip'] == 'true') {
                            $dom[$key]['clip'] = true;
                        } else {
                            $dom[$key]['clip'] = false;
                        }
                    }
                } // End opening tag.
            } else {
                // Text.
                $dom[$key]['tag'] = false;
                $dom[$key]['block'] = false;
                $dom[$key]['value'] = stripslashes($this->unhtmlentities($element));
                $dom[$key]['parent'] = end($level);
                $dom[$key]['dir'] = $dom[$dom[$key]['parent']]['dir'];
            }
            ++$elkey;
            ++$key;
        }
        return $dom;
    }

    /**
     * Returns the string used to find spaces
     */
    protected function getspacestring() {
        $spacestr = chr(32);
        if ($this->isunicodefont()) {
            $spacestr = chr(0).chr(32);
        }
        return $spacestr;
    }

    /**
     * Prints a cell (rectangular area) with optional borders, background color and html text string.
     * The upper-left corner of the cell corresponds to the current position. After the call, the current
       position moves to the right or to the next line.<br />
     * If automatic page breaking is enabled and the cell goes beyond the limit, a page break is done
       before outputting.
     */
    public function writehtmlcell($w, $h, $x, $y, $html = '', $border = 0, $ln = 0, $fill = false, $reseth = true,
                                  $align = '', $autopadding = true) {
        return $this->multicell($w, $h, $html, $border, $align, $fill, $ln, $x, $y, $reseth, 0, true, $autopadding,
                                0, 'T', false);
    }

    /**
     * Allows to preserve some HTML formatting (limited support).
     * @public
     */
    public function writehtml($html, $ln=true, $fill=false, $reseth=false, $cell=false, $align='') {
        $gvars = $this->getgraphicvars();
        // Store current values.
        $prevcellmargin = $this->cellmargin;
        $prevcellpadding = $this->cellpadding;
        $prevpage = $this->page;
        $prevlmargin = $this->lmargin;
        $prevrmargin = $this->rmargin;
        $curfontname = $this->fontfamily;
        $curfontstyle = $this->fontstyle;
        $curfontsize = $this->fontsizept;
        $curfontascent = $this->getfontascent($curfontname, $curfontstyle, $curfontsize);
        $curfontdescent = $this->getfontdescent($curfontname, $curfontstyle, $curfontsize);
        $curfontstretcing = $this->fontstretching;
        $curfonttracking = $this->fontspacing;
        $this->newline = true;
        $newline = true;
        $startlinepage = $this->page;
        $minstartliney = $this->y;
        $maxbottomliney = 0;
        $startlinex = $this->x;
        $startliney = $this->y;
        $yshift = 0;
        $loop = 0;
        $curpos = 0;
        $thismethodvars = array();
        $undo = false;
        $fontaligned = false;
        $reversedir = false; // True when the text direction is reversed.
        $this->premode = false;
        if ($this->inxobj) {
            // We are inside an XObject template.
            $pask = count($this->xobjects[$this->xobjid]['annotations']);
        } else if (isset($this->pageannots[$this->page])) {
            $pask = count($this->pageannots[$this->page]);
        } else {
            $pask = 0;
        }
        if ($this->inxobj) {
            // We are inside an XObject template.
            $startlinepos = strlen($this->xobjects[$this->xobjid]['outdata']);
        } else if (!$this->infooter) {
            if (isset($this->footerlen[$this->page])) {
                $this->footerpos[$this->page] = $this->pagelen[$this->page] - $this->footerlen[$this->page];
            } else {
                $this->footerpos[$this->page] = $this->pagelen[$this->page];
            }
            $startlinepos = $this->footerpos[$this->page];
        } else {
            // We are inside the footer.
            $startlinepos = $this->pagelen[$this->page];
        }
        $lalign = $align;
        $plalign = $align;
        if ($this->rtl) {
            $w = $this->x - $this->lmargin;
        } else {
            $w = $this->w - $this->rmargin - $this->x;
        }
        $w -= ($this->cellpadding['L'] + $this->cellpadding['R']);
        if ($cell) {
            if ($this->rtl) {
                $this->x -= $this->cellpadding['R'];
                $this->lmargin += $this->cellpadding['R'];
            } else {
                $this->x += $this->cellpadding['L'];
                $this->rmargin += $this->cellpadding['L'];
            }
        }
        if ($this->customlistindent >= 0) {
            $this->listindent = $this->customlistindent;
        } else {
            $this->listindent = $this->getstringwidth('000000');
        }
        $this->listindentlevel = 0;
        // Save previous states.
        $prevcellheightratio = $this->cellheightratio;
        $prevlistnum = $this->listnum;
        $prevlistordered = $this->listordered;
        $prevlistcount = $this->listcount;
        $prevlispacer = $this->lispacer;
        $this->listnum = 0;
        $this->listordered = array();
        $this->listcount = array();
        $this->lispacer = '';
        if (($this->empty_string($this->lasth)) OR ($reseth)) {
            // Reset row height.
            $this->resetlasth();
        }
        $dom = $this->gethtmldomarray($html);
        $maxel = count($dom);
        $key = 0;
        $hiddennodekey = -1;
        while ($key < $maxel) {
            if ($dom[$key]['tag']) {
                if ($dom[$key]['opening']) {
                    if (($hiddennodekey <= 0) AND $dom[$key]['hide']) {
                        // Store the node key.
                        $hiddennodekey = $key;
                    }
                } else if (($hiddennodekey > 0) AND ($dom[$key]['parent'] == $hiddennodekey)) {
                    // We have reached the closing tag of the hidden node.
                    $hiddennodekey = 0;
                }
            }
            if ($hiddennodekey >= 0) {
                // Skip this node.
                ++$key;
                if ($hiddennodekey == 0) {
                    // Reset hidden mode.
                    $hiddennodekey = -1;
                }
                continue;
            }
            if ($dom[$key]['tag'] AND isset($dom[$key]['attribute']['pagebreak'])) {
                // Check for pagebreak.
                if (($dom[$key]['attribute']['pagebreak'] == 'true') OR ($dom[$key]['attribute']['pagebreak'] == 'left')
                    OR ($dom[$key]['attribute']['pagebreak'] == 'right')) {
                    // Add a page (or trig acceptpagebreak() for multicolumn mode).
                    $this->checkpagebreak($this->pagebreaktrigger + 1);
                    $this->htmlvspace = ($this->pagebreaktrigger + 1);
                }
                if ((($dom[$key]['attribute']['pagebreak'] == 'left') AND (((!$this->rtl) AND (($this->page % 2) == 0))
                    OR (($this->rtl) AND (($this->page % 2) != 0))))
                    OR (($dom[$key]['attribute']['pagebreak'] == 'right') AND (((!$this->rtl) AND (($this->page % 2) != 0))
                    OR (($this->rtl) AND (($this->page % 2) == 0))))) {
                    // Add a page (or trig acceptpagebreak() for multicolumn mode).
                    $this->checkpagebreak($this->pagebreaktrigger + 1);
                    $this->htmlvspace = ($this->pagebreaktrigger + 1);
                }
            }
            if ($dom[$key]['tag'] AND $dom[$key]['opening'] AND isset($dom[$key]['attribute']['nobr']) AND
               ($dom[$key]['attribute']['nobr'] == 'true')) {
                if (isset($dom[($dom[$key]['parent'])]['attribute']['nobr']) AND
                    ($dom[($dom[$key]['parent'])]['attribute']['nobr'] == 'true')) {
                    $dom[$key]['attribute']['nobr'] = false;
                } else {
                    // Store current object.
                    $this->starttransaction();
                    // Save this method vars.
                    $thismethodvars['html'] = $html;
                    $thismethodvars['ln'] = $ln;
                    $thismethodvars['fill'] = $fill;
                    $thismethodvars['reseth'] = $reseth;
                    $thismethodvars['cell'] = $cell;
                    $thismethodvars['align'] = $align;
                    $thismethodvars['gvars'] = $gvars;
                    $thismethodvars['prevpage'] = $prevpage;
                    $thismethodvars['prevcellmargin'] = $prevcellmargin;
                    $thismethodvars['prevcellpadding'] = $prevcellpadding;
                    $thismethodvars['prevlmargin'] = $prevlmargin;
                    $thismethodvars['prevrmargin'] = $prevrmargin;
                    $thismethodvars['curfontname'] = $curfontname;
                    $thismethodvars['curfontstyle'] = $curfontstyle;
                    $thismethodvars['curfontsize'] = $curfontsize;
                    $thismethodvars['curfontascent'] = $curfontascent;
                    $thismethodvars['curfontdescent'] = $curfontdescent;
                    $thismethodvars['curfontstretcing'] = $curfontstretcing;
                    $thismethodvars['curfonttracking'] = $curfonttracking;
                    $thismethodvars['minstartliney'] = $minstartliney;
                    $thismethodvars['maxbottomliney'] = $maxbottomliney;
                    $thismethodvars['yshift'] = $yshift;
                    $thismethodvars['startlinepage'] = $startlinepage;
                    $thismethodvars['startlinepos'] = $startlinepos;
                    $thismethodvars['startlinex'] = $startlinex;
                    $thismethodvars['startliney'] = $startliney;
                    $thismethodvars['newline'] = $newline;
                    $thismethodvars['loop'] = $loop;
                    $thismethodvars['curpos'] = $curpos;
                    $thismethodvars['pask'] = $pask;
                    $thismethodvars['lalign'] = $lalign;
                    $thismethodvars['plalign'] = $plalign;
                    $thismethodvars['w'] = $w;
                    $thismethodvars['prevcellheightratio'] = $prevcellheightratio;
                    $thismethodvars['prevlistnum'] = $prevlistnum;
                    $thismethodvars['prevlistordered'] = $prevlistordered;
                    $thismethodvars['prevlistcount'] = $prevlistcount;
                    $thismethodvars['prevlispacer'] = $prevlispacer;
                    $thismethodvars['fontaligned'] = $fontaligned;
                    $thismethodvars['key'] = $key;
                    $thismethodvars['dom'] = $dom;
                }
            }
            // Print THEAD block.
            if (($dom[$key]['value'] == 'tr') AND isset($dom[$key]['thead']) AND $dom[$key]['thead']) {
                if (isset($dom[$key]['parent']) AND isset($dom[$dom[$key]['parent']]['thead']) AND
                !$this->empty_string($dom[$dom[$key]['parent']]['thead'])) {
                    $this->inthead = true;
                    // Print table header (thead).
                    $this->writehtml($this->thead, false, false, false, false, '');
                    // Check if we are on a new page or on a new column.
                    if (($this->y < $this->starttransactiony) OR ($this->checkpagebreak($this->lasth, '', false))) {
                        // We are on a new page or on a new column and the total object height is less than the
                        // available vertical space. Restore previous object.
                        $this->rollbacktransaction(true);
                        // Restore previous values.
                        foreach ($thismethodvars as $vkey => $vval) {
                            $$vkey = $vval;
                        }
                        // Disable table header.
                        $tmpthead = $this->thead;
                        $this->thead = '';
                        // Add a page (or trig acceptpagebreak() for multicolumn mode).
                        $prey = $this->y;
                        if ((!$this->checkpagebreak($this->pagebreaktrigger + 1)) AND ($this->y < $prey)) {
                            // Fix for multicolumn mode.
                            $startliney = $this->y;
                        }
                        $this->starttransactionpage = $this->page;
                        $this->starttransactiony = $this->y;
                        // Restore table header.
                        $this->thead = $tmpthead;
                        // Fix table border properties.
                        if (isset($dom[$dom[$key]['parent']]['attribute']['cellspacing'])) {
                            $tmpcellspacing = $this->gethtmlunittounits($dom[$dom[$key]['parent']]['attribute']['cellspacing'],
                                               1, 'px');
                        } else if (isset($dom[$dom[$key]['parent']]['border-spacing'])) {
                            $tmpcellspacing = $dom[$dom[$key]['parent']]['border-spacing']['V'];
                        } else {
                            $tmpcellspacing = 0;
                        }
                        $dom[$dom[$key]['parent']]['borderposition']['page'] = $this->page;
                        $dom[$dom[$key]['parent']]['borderposition']['column'] = $this->currentcolumn;
                        $dom[$dom[$key]['parent']]['borderposition']['y'] = $this->y + $tmpcellspacing;
                        $xoffset = ($this->x - $dom[$dom[$key]['parent']]['borderposition']['x']);
                        $dom[$dom[$key]['parent']]['borderposition']['x'] += $xoffset;
                        $dom[$dom[$key]['parent']]['borderposition']['xmax'] += $xoffset;
                        // Print table header (thead).
                        $this->writehtml($this->thead, false, false, false, false, '');
                    }
                }
                // Move $key index forward to skip THEAD block.
                while (($key < $maxel) AND (!(
                       ($dom[$key]['tag'] AND $dom[$key]['opening'] AND ($dom[$key]['value'] == 'tr') AND
                    (!isset($dom[$key]['thead']) OR !$dom[$key]['thead']))
                    OR ($dom[$key]['tag'] AND (!$dom[$key]['opening']) AND ($dom[$key]['value'] == 'table'))) )) {
                    ++$key;
                }
            }
            if ($dom[$key]['tag'] OR ($key == 0)) {
                if ((($dom[$key]['value'] == 'table') OR ($dom[$key]['value'] == 'tr')) AND
                    (isset($dom[$key]['align']))) {
                    $dom[$key]['align'] = ($this->rtl) ? 'R' : 'L';
                }
                // Vertically align image in line.
                if ((!$this->newline) AND ($dom[$key]['value'] == 'img') AND (isset($dom[$key]['height'])) AND
                     ($dom[$key]['height'] > 0)) {
                    // Get image height.
                    $imgh = $this->gethtmlunittounits($dom[$key]['height'], $this->lasth, 'px');
                    $autolinebreak = false;
                    if (isset($dom[$key]['width']) AND ($dom[$key]['width'] > 0)) {
                        $imgw = $this->gethtmlunittounits($dom[$key]['width'], 1, 'px', false);
                        if (($imgw <= ($this->w - $this->lmargin - $this->rmargin - $this->cellpadding['L'] -
                             $this->cellpadding['R']))
                            AND ((($this->rtl) AND (($this->x - $imgw) < ($this->lmargin + $this->cellpadding['L'])))
                            OR ((!$this->rtl) AND (($this->x + $imgw) > ($this->w -
                                  $this->rmargin - $this->cellpadding['R']))))) {
                            // Add automatic line break.
                            $autolinebreak = true;
                            $this->ln('', $cell);
                            if ((!$dom[($key - 1)]['tag']) AND ($dom[($key - 1)]['value'] == ' ')) {
                                // Go back to evaluate this line break.
                                --$key;
                            }
                        }
                    }
                    if (!$autolinebreak) {
                        if ($this->inpagebody()) {
                            $prey = $this->y;
                            // Check for page break.
                            if ((!$this->checkpagebreak($imgh)) AND ($this->y < $prey)) {
                                // Fix for multicolumn mode.
                                $startliney = $this->y;
                            }
                        }
                        if ($this->page > $startlinepage) {
                            // Fix line splitted over two pages.
                            if (isset($this->footerlen[$startlinepage])) {
                                $curpos = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
                            }
                            // Line to be moved one page forward.
                            $pagebuff = $this->getpagebuffer($startlinepage);
                            $linebeg = substr($pagebuff, $startlinepos, ($curpos - $startlinepos));
                            $tstart = substr($pagebuff, 0, $startlinepos);
                            $tend = substr($this->getpagebuffer($startlinepage), $curpos);
                            // Remove line from previous page.
                            $this->setpagebuffer($startlinepage, $tstart.''.$tend);
                            $pagebuff = $this->getpagebuffer($this->page);
                            $tstart = substr($pagebuff, 0, $this->cntmrk[$this->page]);
                            $tend = substr($pagebuff, $this->cntmrk[$this->page]);
                            // Add line start to current page.
                            $yshift = ($minstartliney - $this->y);
                            if ($fontaligned) {
                                $yshift += ($curfontsize / $this->k);
                            }
                            $try = sprintf('1 0 0 1 0 %F cm', ($yshift * $this->k));
                            $this->setpagebuffer($this->page, $tstart."\nq\n".$try."\n".$linebeg."\nQ\n".$tend);
                            // Shift the annotations and links.
                            if (isset($this->pageannots[$this->page])) {
                                $nextpask = count($this->pageannots[$this->page]);
                            } else {
                                $nextpask = 0;
                            }
                            if (isset($this->pageannots[$startlinepage])) {
                                foreach ($this->pageannots[$startlinepage] as $pak => $pac) {
                                    if ($pak >= $pask) {
                                        $this->pageannots[$this->page][] = $pac;
                                        unset($this->pageannots[$startlinepage][$pak]);
                                        $npak = count($this->pageannots[$this->page]) - 1;
                                        $this->pageannots[$this->page][$npak]['y'] -= $yshift;
                                    }
                                }
                            }
                            $pask = $nextpask;
                            $startlinepos = $this->cntmrk[$this->page];
                            $startlinepage = $this->page;
                            $startliney = $this->y;
                            $this->newline = false;
                        }
                        $this->y += ((($curfontsize * $this->cellheightratio / $this->k) + $curfontascent
                                      - $curfontdescent) / 2) - $imgh;
                        $minstartliney = min($this->y, $minstartliney);
                        $maxbottomliney = ($startliney + ($this->fontsize * $this->cellheightratio));
                    }
                } else if (isset($dom[$key]['fontname']) OR isset($dom[$key]['fontstyle']) OR isset($dom[$key]['fontsize'])
                           OR isset($dom[$key]['line-height'])) {
                    // Account for different font size.
                    $pfontname = $curfontname;
                    $pfontstyle = $curfontstyle;
                    $pfontsize = $curfontsize;
                    $fontname = isset($dom[$key]['fontname']) ? $dom[$key]['fontname'] : $curfontname;
                    $fontstyle = isset($dom[$key]['fontstyle']) ? $dom[$key]['fontstyle'] : $curfontstyle;
                    $fontsize = isset($dom[$key]['fontsize']) ? $dom[$key]['fontsize'] : $curfontsize;
                    $fontascent = $this->getfontascent($fontname, $fontstyle, $fontsize);
                    $fontdescent = $this->getfontdescent($fontname, $fontstyle, $fontsize);
                    if (($fontname != $curfontname) OR ($fontstyle != $curfontstyle) OR ($fontsize != $curfontsize)
                        OR ($this->cellheightratio != $dom[$key]['line-height'])
                        OR ($dom[$key]['tag'] AND $dom[$key]['opening'] AND ($dom[$key]['value'] == 'li')) ) {
                        if (($key < ($maxel - 1)) AND (
                                ($dom[$key]['tag'] AND $dom[$key]['opening'] AND ($dom[$key]['value'] == 'li'))
                                OR ($this->cellheightratio != $dom[$key]['line-height'])
                                OR (!$this->newline AND is_numeric($fontsize) AND is_numeric($curfontsize) AND
                                   ($fontsize >= 0) AND ($curfontsize >= 0) AND ($fontsize != $curfontsize))
                            )) {
                            if ($this->page > $startlinepage) {
                                // Fix lines splitted over two pages.
                                if (isset($this->footerlen[$startlinepage])) {
                                    $curpos = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
                                }
                                // Line to be moved one page forward.
                                $pagebuff = $this->getpagebuffer($startlinepage);
                                $linebeg = substr($pagebuff, $startlinepos, ($curpos - $startlinepos));
                                $tstart = substr($pagebuff, 0, $startlinepos);
                                $tend = substr($this->getpagebuffer($startlinepage), $curpos);
                                // Remove line start from previous page.
                                $this->setpagebuffer($startlinepage, $tstart.''.$tend);
                                $pagebuff = $this->getpagebuffer($this->page);
                                $tstart = substr($pagebuff, 0, $this->cntmrk[$this->page]);
                                $tend = substr($pagebuff, $this->cntmrk[$this->page]);
                                // Add line start to current page.
                                $yshift = ($minstartliney - $this->y);
                                $try = sprintf('1 0 0 1 0 %F cm', ($yshift * $this->k));
                                $this->setpagebuffer($this->page, $tstart."\nq\n".$try."\n".$linebeg."\nQ\n".$tend);
                                // Shift the annotations and links.
                                if (isset($this->pageannots[$this->page])) {
                                    $nextpask = count($this->pageannots[$this->page]);
                                } else {
                                    $nextpask = 0;
                                }
                                if (isset($this->pageannots[$startlinepage])) {
                                    foreach ($this->pageannots[$startlinepage] as $pak => $pac) {
                                        if ($pak >= $pask) {
                                            $this->pageannots[$this->page][] = $pac;
                                            unset($this->pageannots[$startlinepage][$pak]);
                                            $npak = count($this->pageannots[$this->page]) - 1;
                                            $this->pageannots[$this->page][$npak]['y'] -= $yshift;
                                        }
                                    }
                                }
                                $pask = $nextpask;
                                $startlinepos = $this->cntmrk[$this->page];
                                $startlinepage = $this->page;
                                $startliney = $this->y;
                            }
                            if (!isset($dom[$key]['line-height'])) {
                                $dom[$key]['line-height'] = $this->cellheightratio;
                            }
                            if (!$dom[$key]['block']) {
                                if (!(isset($dom[($key + 1)]) AND $dom[($key + 1)]['tag'] AND (!$dom[($key + 1)]['opening'])
                                    AND ($dom[($key + 1)]['value'] != 'li') AND $dom[$key]['tag'] AND
                                        (!$dom[$key]['opening']))) {
                                    $this->y += (((($curfontsize * $this->cellheightratio) -
                                                ($fontsize * $dom[$key]['line-height'])) / $this->k) + $curfontascent -
                                                 $fontascent - $curfontdescent + $fontdescent) / 2;
                                }
                                if (($dom[$key]['value'] != 'sup') AND ($dom[$key]['value'] != 'sub')) {
                                    $currentlinealigndata = array($key, $minstartliney, $maxbottomliney);
                                    if (isset($linealigndata) AND (($linealigndata[0] == ($key - 1)) OR
                                             (($linealigndata[0] == ($key - 2)) AND (isset($dom[($key - 1)])) AND
                                             (preg_match('/^([\s]+)$/', $dom[($key - 1)]['value']) > 0)))) {
                                        $minstartliney = min($this->y, $linealigndata[1]);
                                        $maxbottomliney = max(($this->y + (($fontsize * $this->cellheightratio) / $this->k)),
                                                          $linealigndata[2]);
                                    } else {
                                        $minstartliney = min($this->y, $minstartliney);
                                        $maxbottomliney = max(($this->y + (($fontsize * $this->cellheightratio) / $this->k)),
                                                          $maxbottomliney);
                                    }
                                    $linealigndata = $currentlinealigndata;
                                }
                            }
                            $this->cellheightratio = $dom[$key]['line-height'];
                            $fontaligned = true;
                        }
                        $this->setfont($fontname, $fontstyle, $fontsize);
                        // Reset row height.
                        $this->resetlasth();
                        $curfontname = $fontname;
                        $curfontstyle = $fontstyle;
                        $curfontsize = $fontsize;
                        $curfontascent = $fontascent;
                        $curfontdescent = $fontdescent;
                    }
                }
                // Set text rendering mode.
                $textstroke = isset($dom[$key]['stroke']) ? $dom[$key]['stroke'] : $this->textstrokewidth;
                $textfill = isset($dom[$key]['fill']) ? $dom[$key]['fill'] : (($this->textrendermode % 2) == 0);
                $textclip = isset($dom[$key]['clip']) ? $dom[$key]['clip'] : ($this->textrendermode > 3);
                $this->settextrenderingmode($textstroke, $textfill, $textclip);
                if (isset($dom[$key]['font-stretch']) AND ($dom[$key]['font-stretch'] !== false)) {
                    $this->setfontstretching($dom[$key]['font-stretch']);
                }
                if (isset($dom[$key]['letter-spacing']) AND ($dom[$key]['letter-spacing'] !== false)) {
                    $this->setfontspacing($dom[$key]['letter-spacing']);
                }
                if (($plalign == 'J') AND $dom[$key]['block']) {
                    $plalign = '';
                }
                // Get current position on page buffer.
                $curpos = $this->pagelen[$startlinepage];
                if (isset($dom[$key]['bgcolor']) AND ($dom[$key]['bgcolor'] !== false)) {
                    $this->setfillcolorarray($dom[$key]['bgcolor']);
                    $wfill = true;
                } else {
                    $wfill = $fill | false;
                }
                if (isset($dom[$key]['fgcolor']) AND ($dom[$key]['fgcolor'] !== false)) {
                    $this->settextcolorarray($dom[$key]['fgcolor']);
                }
                if (isset($dom[$key]['strokecolor']) AND ($dom[$key]['strokecolor'] !== false)) {
                    $this->setdrawcolorarray($dom[$key]['strokecolor']);
                }
                if (isset($dom[$key]['align'])) {
                    $lalign = $dom[$key]['align'];
                }
                if ($this->empty_string($lalign)) {
                    $lalign = $align;
                }
            }
            // Align lines.
            if ($this->newline AND (strlen($dom[$key]['value']) > 0) AND ($dom[$key]['value'] != 'td') AND
                ($dom[$key]['value'] != 'th')) {
                $newline = true;
                $fontaligned = false;
                // We are at the beginning of a new line.
                if (isset($startlinex)) {
                    $yshift = ($minstartliney - $startliney);
                    if (($yshift > 0) OR ($this->page > $startlinepage)) {
                        $yshift = 0;
                    }
                    $tx = 0;
                    // The last line must be shifted to be aligned as requested.
                    $linew = abs($this->endlinex - $startlinex);
                    if ($this->inxobj) {
                        // We are inside an XObject template.
                        $pstart = substr($this->xobjects[$this->xobjid]['outdata'], 0, $startlinepos);
                        if (isset($opentagpos)) {
                            $midpos = $opentagpos;
                        } else {
                            $midpos = 0;
                        }
                        if ($midpos > 0) {
                            $pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos,
                                          ($midpos - $startlinepos));
                            $pend = substr($this->xobjects[$this->xobjid]['outdata'], $midpos);
                        } else {
                            $pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos);
                            $pend = '';
                        }
                    } else {
                        $pstart = substr($this->getpagebuffer($startlinepage), 0, $startlinepos);
                        if (isset($opentagpos) AND isset($this->footerlen[$startlinepage]) AND
                            (!$this->infooter)) {
                            $this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] -
                            $this->footerlen[$startlinepage];
                            $midpos = min($opentagpos, $this->footerpos[$startlinepage]);
                        } else if (isset($opentagpos)) {
                            $midpos = $opentagpos;
                        } else if (isset($this->footerlen[$startlinepage]) AND (!$this->infooter)) {
                            $this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] -
                            $this->footerlen[$startlinepage];
                            $midpos = $this->footerpos[$startlinepage];
                        } else {
                            $midpos = 0;
                        }
                        if ($midpos > 0) {
                            $pmid = substr($this->getpagebuffer($startlinepage), $startlinepos,
                                    ($midpos - $startlinepos));
                            $pend = substr($this->getpagebuffer($startlinepage), $midpos);
                        } else {
                            $pmid = substr($this->getpagebuffer($startlinepage), $startlinepos);
                            $pend = '';
                        }
                    }
                    if ((isset($plalign) AND ((($plalign == 'C') OR ($plalign == 'J') OR (($plalign == 'R') AND
                       (!$this->rtl)) OR (($plalign == 'L') AND ($this->rtl)))))) {
                        // Calculate shifting amount.
                        $tw = $w;
                        if (($plalign == 'J') AND $this->isrtltextdir() AND ($this->numcolumns > 1)) {
                            $tw += $this->cellpadding['R'];
                        }
                        if ($this->lmargin != $prevlmargin) {
                            $tw += ($prevlmargin - $this->lmargin);
                        }
                        if ($this->rmargin != $prevrmargin) {
                            $tw += ($prevrmargin - $this->rmargin);
                        }
                        $onespacewidth = $this->getstringwidth(chr(32));
                        $no = 0; // Number of spaces on a line contained on a single block.
                        if ($this->isrtltextdir()) { // RTL.
                            // Remove left space if exist.
                            $pos1 = $this->revstrpos($pmid, '[(');
                            if ($pos1 > 0) {
                                $pos1 = intval($pos1);
                                if ($this->isunicodefont()) {
                                    $pos2 = intval($this->revstrpos($pmid, '[('.chr(0).chr(32)));
                                    $spacelen = 2;
                                } else {
                                    $pos2 = intval($this->revstrpos($pmid, '[('.chr(32)));
                                    $spacelen = 1;
                                }
                                if ($pos1 == $pos2) {
                                    $pmid = substr($pmid, 0, ($pos1 + 2)).substr($pmid, ($pos1 + 2 + $spacelen));
                                    if (substr($pmid, $pos1, 4) == '[()]') {
                                        $linew -= $onespacewidth;
                                    } else if ($pos1 == strpos($pmid, '[(')) {
                                        $no = 1;
                                    }
                                }
                            }
                        } else { // LTR.
                            // Remove right space if exist.
                            $pos1 = $this->revstrpos($pmid, ')]');
                            if ($pos1 > 0) {
                                $pos1 = intval($pos1);
                                if ($this->isunicodefont()) {
                                    $pos2 = intval($this->revstrpos($pmid, chr(0).chr(32).')]')) + 2;
                                    $spacelen = 2;
                                } else {
                                    $pos2 = intval($this->revstrpos($pmid, chr(32).')]')) + 1;
                                    $spacelen = 1;
                                }
                                if ($pos1 == $pos2) {
                                    $pmid = substr($pmid, 0, ($pos1 - $spacelen)).substr($pmid, $pos1);
                                    $linew -= $onespacewidth;
                                }
                            }
                        }
                        $mdiff = ($tw - $linew);
                        if ($plalign == 'C') {
                            if ($this->rtl) {
                                $tx = -($mdiff / 2);
                            } else {
                                $tx = ($mdiff / 2);
                            }
                        } else if ($plalign == 'R') {
                            // Right alignment on LTR document.
                            $tx = $mdiff;
                        } else if ($plalign == 'L') {
                            // Left alignment on RTL document.
                            $tx = -$mdiff;
                        } else if (($plalign == 'J') AND ($plalign == $lalign)) {
                            // Justification.
                            if ($this->isrtltextdir()) {
                                // Align text on the left.
                                $tx = -$mdiff;
                            }
                            $ns = 0; // Number of spaces.
                            $pmidtemp = $pmid;
                            // Escape special characters.
                            $pmidtemp = preg_replace('/[\\\][\(]/x', '\\#!#OP#!#', $pmidtemp);
                            $pmidtemp = preg_replace('/[\\\][\)]/x', '\\#!#CP#!#', $pmidtemp);
                            // Search spaces.
                            if (preg_match_all('/\[\(([^\)]*)\)\]/x', $pmidtemp, $lnstring, PREG_PATTERN_ORDER)) {
                                $spacestr = $this->getspacestring();
                                $maxkk = count($lnstring[1]) - 1;
                                for ($kk = 0; $kk <= $maxkk; ++$kk) {
                                    // Restore special characters.
                                    $lnstring[1][$kk] = str_replace('#!#OP#!#', '(', $lnstring[1][$kk]);
                                    $lnstring[1][$kk] = str_replace('#!#CP#!#', ')', $lnstring[1][$kk]);
                                    // Store number of spaces on the strings.
                                    $lnstring[2][$kk] = substr_count($lnstring[1][$kk], $spacestr);
                                    // Count total spaces on line.
                                    $ns += $lnstring[2][$kk];
                                    $lnstring[3][$kk] = $ns;
                                }
                                if ($ns == 0) {
                                    $ns = 1;
                                }
                                // Calculate additional space to add to each existing space.
                                $spacewidth = ($mdiff / ($ns - $no)) * $this->k;
                                $spacewidthu = -1000 * ($mdiff + (($ns + $no) * $onespacewidth)) / $ns / $this->fontsize;
                                if ($this->fontspacing != 0) {
                                    // Fixed spacing mode.
                                    $osw = -1000 * $this->fontspacing / $this->fontsize;
                                    $spacewidthu += $osw;
                                }
                                $nsmax = $ns;
                                $ns = 0;
                                reset($lnstring);
                                $offset = 0;
                                $strcount = 0;
                                $prevepsposbeg = 0;
                                $textpos = 0;
                                if ($this->isrtltextdir()) {
                                    $textpos = $this->wpt;
                                }
                                global $spacew;
                                while (preg_match('/([0-9\.\+\-]*)[\s](Td|cm|m|l|c|re)[\s]/x', $pmid, $strpiece,
                                       PREG_OFFSET_CAPTURE, $offset) == 1) {
                                    // Check if we are inside a string section.
                                    $stroffset = strpos($pmid, '[(', $offset);
                                    if (($stroffset !== false) AND ($stroffset <= $strpiece[2][1])) {
                                        // Set offset to the end of string section.
                                        $offset = strpos($pmid, ')]', $stroffset);
                                        while (($offset !== false) AND ($pmid[($offset - 1)] == '\\')) {
                                            $offset = strpos($pmid, ')]', ($offset + 1));
                                        }
                                        if ($offset === false) {
                                            $this->errord('HTML Justification: malformed PDF code.');
                                        }
                                        continue;
                                    }
                                    if ($this->isrtltextdir()) {
                                        $spacew = ($spacewidth * ($nsmax - $ns));
                                    } else {
                                        $spacew = ($spacewidth * $ns);
                                    }
                                    $offset = $strpiece[2][1] + strlen($strpiece[2][0]);
                                    $epsposbeg = strpos($pmid, 'q'.$this->epsmarker, $offset);
                                    $epsposend = strpos($pmid, $this->epsmarker.'Q', $offset) +
                                                 strlen($this->epsmarker.'Q');
                                    if ((($epsposbeg > 0) AND ($epsposend > 0) AND ($offset > $epsposbeg) AND
                                        ($offset < $epsposend))
                                        OR (($epsposbeg === false) AND ($epsposend > 0) AND ($offset < $epsposend))) {
                                        // Shift EPS images.
                                        $trx = sprintf('1 0 0 1 %F 0 cm', $spacew);
                                        $epsposbeg = strpos($pmid, 'q'.$this->epsmarker, ($prevepsposbeg - 6));
                                        $pmidb = substr($pmid, 0, $epsposbeg);
                                        $pmidm = substr($pmid, $epsposbeg, ($epsposend - $epsposbeg));
                                        $pmide = substr($pmid, $epsposend);
                                        $pmid = $pmidb."\nq\n".$trx."\n".$pmidm."\nQ\n".$pmide;
                                        $offset = $epsposend;
                                        continue;

                                    }
                                    $prevepsposbeg = $epsposbeg;
                                    $currentxpos = 0;
                                    // Shift blocks of code.
                                    switch ($strpiece[2][0]) {
                                        case 'Td':
                                        case 'cm':
                                        case 'm':
                                        case 'l': {
                                            // Get current X position.
                                            preg_match('/([0-9\.\+\-]*)[\s]('.$strpiece[1][0].')[\s]
                                                      ('.$strpiece[2][0].')([\s]*)/x', $pmid, $xmatches);
                                            $currentxpos = $xmatches[1];
                                            $textpos = $currentxpos;
                                            if (($strcount <= $maxkk) AND ($strpiece[2][0] == 'Td')) {
                                                $ns = $lnstring[3][$strcount];
                                                if ($this->isrtltextdir()) {
                                                    $spacew = ($spacewidth * ($nsmax - $ns));
                                                }
                                                ++$strcount;
                                            }
                                            // Justify block.
                                            $pmid = preg_replace_callback('/([0-9\.\+\-]*)[\s]('.$strpiece[1][0].')[\s]
                                                    ('.$strpiece[2][0].')([\s]*)/x',
                                                create_function('$matches', 'global $spacew;
                                                $newx = sprintf("%F",(floatval($matches[1]) + $spacew));
                                                return "".$newx." ".$matches[2]." x*#!#*x".$matches[3].$matches[4];'), $pmid, 1);
                                            break;
                                        }
                                        case 're': {
                                            // Justify block.
                                            if (!$this->empty_string($this->lispacer)) {
                                                $this->lispacer = '';
                                            }
                                            preg_match('/([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]
                                                      ('.$strpiece[1][0].')[\s](re)([\s]*)/x', $pmid, $xmatches);
                                            $currentxpos = $xmatches[1];
                                            global $xdiff, $wdiff;
                                            $xdiff = 0;
                                            $wdiff = 0;
                                            if ($this->isrtltextdir()) { // RTL.
                                                if ($currentxpos < $textpos) {
                                                    $xdiff = ($spacewidth * ($nsmax - $lnstring[3][$strcount]));
                                                    $wdiff = ($spacewidth * $lnstring[2][$strcount]);
                                                } else {
                                                    if ($strcount > 0) {
                                                        $xdiff = ($spacewidth * ($nsmax - $lnstring[3][($strcount - 1)]));
                                                        $wdiff = ($spacewidth * $lnstring[2][($strcount - 1)]);
                                                    }
                                                }
                                            } else { // LTR.
                                                if ($currentxpos > $textpos) {
                                                    if ($strcount > 0) {
                                                        $xdiff = ($spacewidth * $lnstring[3][($strcount - 1)]);
                                                    }
                                                    $wdiff = ($spacewidth * $lnstring[2][$strcount]);
                                                } else {
                                                    if ($strcount > 1) {
                                                        $xdiff = ($spacewidth * $lnstring[3][($strcount - 2)]);
                                                    }
                                                    if ($strcount > 0) {
                                                        $wdiff = ($spacewidth * $lnstring[2][($strcount - 1)]);
                                                    }
                                                }
                                            }
                                            $pmid = preg_replace_callback('/('.$xmatches[1].')[\s]('.$xmatches[2].')
                                                    [\s]('.$xmatches[3].')[\s]('.$strpiece[1][0].')[\s](re)([\s]*)/x',
                                                create_function('$matches', 'global $xdiff, $wdiff;
                                                $newx = sprintf("%F",(floatval($matches[1]) + $xdiff));
                                                $neww = sprintf("%F",(floatval($matches[3]) + $wdiff));
                                                return "".$newx." ".$matches[2]." ".$neww." ".$matches[4]."
                                                        x*#!#*x".$matches[5].$matches[6];'), $pmid, 1);
                                            break;
                                        }
                                        case 'c': {
                                            // Get current X position.
                                            preg_match('/([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]
                                                      ([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s](
                                                      '.$strpiece[1][0].')[\s](c)([\s]*)/x', $pmid, $xmatches);
                                            $currentxpos = $xmatches[1];
                                            // Justify block.
                                            $pmid = preg_replace_callback('/('.$xmatches[1].')[\s]('.$xmatches[2].')[\s]
                                                    ('.$xmatches[3].')[\s]('.$xmatches[4].')[\s]('.$xmatches[5].')[\s]
                                                    ('.$strpiece[1][0].')[\s](c)([\s]*)/x',
                                                create_function('$matches', 'global $spacew;
                                                $newx1 = sprintf("%F",(floatval($matches[1]) + $spacew));
                                                $newx2 = sprintf("%F",(floatval($matches[3]) + $spacew));
                                                $newx3 = sprintf("%F",(floatval($matches[5]) + $spacew));
                                                return "".$newx1." ".$matches[2]." ".$newx2." ".$matches[4]." ".$newx3."
                                                ".$matches[6]." x*#!#*x".$matches[7].$matches[8];'), $pmid, 1);
                                            break;
                                        }
                                    }
                                    // Shift the annotations and links.
                                    $cxpos = ($currentxpos / $this->k);
                                    $lmpos = ($this->lmargin + $this->cellpadding['L'] + $this->feps);
                                    if ($this->inxobj) {
                                        // We are inside an XObject template.
                                        foreach ($this->xobjects[$this->xobjid]['annotations'] as $pak => $pac) {
                                            if (($pac['y'] >= $minstartliney) AND (($pac['x'] * $this->k) >=
                                               ($currentxpos - $this->feps)) AND (($pac['x'] * $this->k) <=
                                               ($currentxpos + $this->feps))) {
                                                if ($cxpos > $lmpos) {
                                                    $this->xobjects[$this->xobjid]['annotations'][$pak]['x'] +=
                                                    ($spacew / $this->k);
                                                    $this->xobjects[$this->xobjid]['annotations'][$pak]['w'] +=
                                                    (($spacewidth * $pac['numspaces']) / $this->k);
                                                } else {
                                                    $this->xobjects[$this->xobjid]['annotations'][$pak]['w'] +=
                                                    (($spacewidth * $pac['numspaces']) / $this->k);
                                                }
                                                break;
                                            }
                                        }
                                    } else if (isset($this->pageannots[$this->page])) {
                                        foreach ($this->pageannots[$this->page] as $pak => $pac) {
                                            if (($pac['y'] >= $minstartliney) AND (($pac['x'] * $this->k) >=
                                            ($currentxpos - $this->feps)) AND (($pac['x'] * $this->k) <=
                                            ($currentxpos + $this->feps))) {
                                                if ($cxpos > $lmpos) {
                                                    $this->pageannots[$this->page][$pak]['x'] +=
                                                    ($spacew / $this->k);
                                                    $this->pageannots[$this->page][$pak]['w'] +=
                                                    (($spacewidth * $pac['numspaces']) / $this->k);
                                                } else {
                                                    $this->pageannots[$this->page][$pak]['w'] +=
                                                    (($spacewidth * $pac['numspaces']) / $this->k);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                } // End of while.
                                // Remove markers.
                                $pmid = str_replace('x*#!#*x', '', $pmid);
                                if ($this->isunicodefont()) {
                                    // Multibyte characters.
                                    $spacew = $spacewidthu;
                                    if ($this->fontstretching != 100) {
                                        // Word spacing is affected by stretching.
                                        $spacew /= ($this->fontstretching / 100);
                                    }
                                    $pmidtemp = $pmid;
                                    // Escape special characters.
                                    $pmidtemp = preg_replace('/[\\\][\(]/x', '\\#!#OP#!#', $pmidtemp);
                                    $pmidtemp = preg_replace('/[\\\][\)]/x', '\\#!#CP#!#', $pmidtemp);
                                    $pmid = preg_replace_callback("/\[\(([^\)]*)\)\]/x",
                                                create_function('$matches', 'global $spacew;
                                                $matches[1] = str_replace("#!#OP#!#", "(", $matches[1]);
                                                $matches[1] = str_replace("#!#CP#!#", ")", $matches[1]);
                                                return "[(".str_replace(chr(0).chr(32), ") ".sprintf("%F", $spacew)."
                                                (", $matches[1]).")]";'), $pmidtemp);
                                    if ($this->inxobj) {
                                        // We are inside an XObject template.
                                        $this->xobjects[$this->xobjid]['outdata'] = $pstart."\n".$pmid."\n".$pend;
                                    } else {
                                        $this->setpagebuffer($startlinepage, $pstart."\n".$pmid."\n".$pend);
                                    }
                                    $endlinepos = strlen($pstart."\n".$pmid."\n");
                                } else {
                                    // Non-unicode (single-byte characters).
                                    if ($this->fontstretching != 100) {
                                        // Word spacing (Tw) is affected by stretching.
                                        $spacewidth /= ($this->fontstretching / 100);
                                    }
                                    $rs = sprintf('%F Tw', $spacewidth);
                                    $pmid = preg_replace("/\[\(/x", $rs.' [(', $pmid);
                                    if ($this->inxobj) {
                                        // We are inside an XObject template.
                                        $this->xobjects[$this->xobjid]['outdata'] = $pstart."\n".$pmid."\nBT 0 Tw ET\n".
                                                        $pend;
                                    } else {
                                        $this->setpagebuffer($startlinepage, $pstart."\n".$pmid."\nBT 0 Tw ET\n".$pend);
                                    }
                                    $endlinepos = strlen($pstart."\n".$pmid."\nBT 0 Tw ET\n");
                                }
                            }
                        } // End of J.
                    } // End if $startlinex.
                    if (($tx != 0) OR ($yshift < 0)) {
                        // Shift the line.
                        $trx = sprintf('1 0 0 1 %F %F cm', ($tx * $this->k), ($yshift * $this->k));
                        $pstart .= "\nq\n".$trx."\n".$pmid."\nQ\n";
                        $endlinepos = strlen($pstart);
                        if ($this->inxobj) {
                            // We are inside an XObject template.
                            $this->xobjects[$this->xobjid]['outdata'] = $pstart.$pend;
                            foreach ($this->xobjects[$this->xobjid]['annotations'] as $pak => $pac) {
                                if ($pak >= $pask) {
                                    $this->xobjects[$this->xobjid]['annotations'][$pak]['x'] += $tx;
                                    $this->xobjects[$this->xobjid]['annotations'][$pak]['y'] -= $yshift;
                                }
                            }
                        } else {
                            $this->setpagebuffer($startlinepage, $pstart.$pend);
                            // Shift the annotations and links.
                            if (isset($this->pageannots[$this->page])) {
                                foreach ($this->pageannots[$this->page] as $pak => $pac) {
                                    if ($pak >= $pask) {
                                        $this->pageannots[$this->page][$pak]['x'] += $tx;
                                        $this->pageannots[$this->page][$pak]['y'] -= $yshift;
                                    }
                                }
                            }
                        }
                        $this->y -= $yshift;
                    }
                }
                $pbrk = $this->checkpagebreak($this->lasth);
                $this->newline = false;
                $startlinex = $this->x;
                $startliney = $this->y;
                if ($dom[$dom[$key]['parent']]['value'] == 'sup') {
                    $startliney -= ((0.3 * $this->fontsizept) / $this->k);
                } else if ($dom[$dom[$key]['parent']]['value'] == 'sub') {
                    $startliney -= (($this->fontsizept / 0.7) / $this->k);
                } else {
                    $minstartliney = $startliney;
                    $maxbottomliney = ($this->y + (($fontsize * $this->cellheightratio) / $this->k));
                }
                $startlinepage = $this->page;
                if (isset($endlinepos) AND (!$pbrk)) {
                    $startlinepos = $endlinepos;
                } else {
                    if ($this->inxobj) {
                        // We are inside an XObject template.
                        $startlinepos = strlen($this->xobjects[$this->xobjid]['outdata']);
                    } else if (!$this->infooter) {
                        if (isset($this->footerlen[$this->page])) {
                            $this->footerpos[$this->page] = $this->pagelen[$this->page] - $this->footerlen[$this->page];
                        } else {
                            $this->footerpos[$this->page] = $this->pagelen[$this->page];
                        }
                        $startlinepos = $this->footerpos[$this->page];
                    } else {
                        $startlinepos = $this->pagelen[$this->page];
                    }
                }
                unset($endlinepos);
                $plalign = $lalign;
                if (isset($this->pageannots[$this->page])) {
                    $pask = count($this->pageannots[$this->page]);
                } else {
                    $pask = 0;
                }
                if (!($dom[$key]['tag'] AND !$dom[$key]['opening'] AND ($dom[$key]['value'] == 'table')
                    AND (isset($this->emptypagemrk[$this->page]))
                    AND ($this->emptypagemrk[$this->page] == $this->pagelen[$this->page]))) {
                    $this->setfont($fontname, $fontstyle, $fontsize);
                    if ($wfill) {
                        $this->setfillcolorarray($this->bgcolor);
                    }
                }
            } // End newline.
            if (isset($opentagpos)) {
                unset($opentagpos);
            }
            if ($dom[$key]['tag']) {
                if ($dom[$key]['opening']) {
                    // Get text indentation (if any).
                    if (isset($dom[$key]['text-indent']) AND $dom[$key]['block']) {
                        $this->textindent = $dom[$key]['text-indent'];
                        $this->newline = true;
                    }
                    // Table.
                    if ($dom[$key]['value'] == 'table') {
                        // Available page width.
                        if ($this->rtl) {
                            $wtmp = $this->x - $this->lmargin;
                        } else {
                            $wtmp = $this->w - $this->rmargin - $this->x;
                        }
                        // Get cell spacing.
                        if (isset($dom[$key]['attribute']['cellspacing'])) {
                            $clsp = $this->gethtmlunittounits($dom[$key]['attribute']['cellspacing'], 1, 'px');
                            $cellspacing = array('H' => $clsp, 'V' => $clsp);
                        } else if (isset($dom[$key]['border-spacing'])) {
                            $cellspacing = $dom[$key]['border-spacing'];
                        } else {
                            $cellspacing = array('H' => 0, 'V' => 0);
                        }
                        // Table width.
                        if (isset($dom[$key]['width'])) {
                            $tablewidth = $this->gethtmlunittounits($dom[$key]['width'], $wtmp, 'px');
                        } else {
                            $tablewidth = $wtmp;
                        }
                        $tablewidth -= (2 * $cellspacing['H']);
                        if (!$this->inthead) {
                            $this->y += $cellspacing['V'];
                        }
                        if ($this->rtl) {
                            $cellspacingx = -$cellspacing['H'];
                        } else {
                            $cellspacingx = $cellspacing['H'];
                        }
                        // Total table width without cellspaces.
                        $tablecolumnswidth = ($tablewidth - ($cellspacing['H'] * ($dom[$key]['cols'] - 1)));
                        // Minimum column width.
                        $tablemincolumnwidth = ($tablecolumnswidth / $dom[$key]['cols']);
                        // Array of custom column widths.
                        $tablecolwidths = array_fill(0, $dom[$key]['cols'], $tablemincolumnwidth);
                    }
                    // Table row.
                    if ($dom[$key]['value'] == 'tr') {
                        // Reset column counter.
                        $colid = 0;
                    }
                    // Table cell.
                    if (($dom[$key]['value'] == 'td') OR ($dom[$key]['value'] == 'th')) {
                        $trid = $dom[$key]['parent'];
                        $tableel = $dom[$trid]['parent'];
                        if (!isset($dom[$tableel]['cols'])) {
                            $dom[$tableel]['cols'] = $dom[$trid]['cols'];
                        }
                        // Store border info.
                        $tdborder = 0;
                        if (isset($dom[$key]['border']) AND !empty($dom[$key]['border'])) {
                            $tdborder = $dom[$key]['border'];
                        }
                        $colspan = $dom[$key]['attribute']['colspan'];
                        $oldcellpadding = $this->cellpadding;
                        if (isset($dom[($dom[$trid]['parent'])]['attribute']['cellpadding'])) {
                            $crclpd = $this->gethtmlunittounits($dom[($dom[$trid]['parent'])]['attribute']['cellpadding'],
                                        1, 'px');
                            $currentcellpadding = array('L' => $crclpd, 'T' => $crclpd, 'R' => $crclpd, 'B' => $crclpd);
                        } else if (isset($dom[($dom[$trid]['parent'])]['padding'])) {
                            $currentcellpadding = $dom[($dom[$trid]['parent'])]['padding'];
                        } else {
                            $currentcellpadding = array('L' => 0, 'T' => 0, 'R' => 0, 'B' => 0);
                        }
                        $this->cellpadding = $currentcellpadding;
                        if (isset($dom[$key]['height'])) {
                            // Minimum cell height.
                            $cellh = $this->gethtmlunittounits($dom[$key]['height'], 0, 'px');
                        } else {
                            $cellh = 0;
                        }
                        if (isset($dom[$key]['content'])) {
                            $cellcontent = stripslashes($dom[$key]['content']);
                        } else {
                            $cellcontent = '&nbsp;';
                        }
                        $tagtype = $dom[$key]['value'];
                        $parentid = $key;
                        while (($key < $maxel) AND (!(($dom[$key]['tag']) AND (!$dom[$key]['opening']) AND
                              ($dom[$key]['value'] == $tagtype) AND ($dom[$key]['parent'] == $parentid)))) {
                            // Move $key index forward.
                            ++$key;
                        }
                        if (!isset($dom[$trid]['startpage'])) {
                            $dom[$trid]['startpage'] = $this->page;
                        } else {
                            $this->setpage($dom[$trid]['startpage']);
                        }
                        if (!isset($dom[$trid]['startcolumn'])) {
                            $dom[$trid]['startcolumn'] = $this->currentcolumn;
                        } else if ($this->currentcolumn != $dom[$trid]['startcolumn']) {
                            $tmpx = $this->x;
                            $this->selectcolumn($dom[$trid]['startcolumn']);
                            $this->x = $tmpx;
                        }
                        if (!isset($dom[$trid]['starty'])) {
                            $dom[$trid]['starty'] = $this->y;
                        } else {
                            $this->y = $dom[$trid]['starty'];
                        }
                        if (!isset($dom[$trid]['startx'])) {
                            $dom[$trid]['startx'] = $this->x;
                            $this->x += $cellspacingx;
                        } else {
                            $this->x += ($cellspacingx / 2);
                        }
                        if (isset($dom[$parentid]['attribute']['rowspan'])) {
                            $rowspan = intval($dom[$parentid]['attribute']['rowspan']);
                        } else {
                            $rowspan = 1;
                        }
                        // Skip row-spanned cells started on the previous rows.
                        if (isset($dom[$tableel]['rowspans'])) {
                            $rsk = 0;
                            $rskmax = count($dom[$tableel]['rowspans']);
                            while ($rsk < $rskmax) {
                                $trwsp = $dom[$tableel]['rowspans'][$rsk];
                                $rsstartx = $trwsp['startx'];
                                $rsendx = $trwsp['endx'];
                                // Account for margin changes.
                                if ($trwsp['startpage'] < $this->page) {
                                    if (($this->rtl) AND ($this->pagedim[$this->page]['orm'] !=
                                         $this->pagedim[$trwsp['startpage']]['orm'])) {
                                        $dl = ($this->pagedim[$this->page]['orm'] - $this->pagedim[$trwsp['startpage']]['orm']);
                                        $rsstartx -= $dl;
                                        $rsendx -= $dl;
                                    } else if ((!$this->rtl) AND ($this->pagedim[$this->page]['olm'] !=
                                               $this->pagedim[$trwsp['startpage']]['olm'])) {
                                        $dl = ($this->pagedim[$this->page]['olm'] - $this->pagedim[$trwsp['startpage']]['olm']);
                                        $rsstartx += $dl;
                                        $rsendx += $dl;
                                    }
                                }
                                if (($trwsp['rowspan'] > 0)
                                    AND ($rsstartx > ($this->x - $cellspacing['H'] - $currentcellpadding['L'] - $this->feps))
                                    AND ($rsstartx < ($this->x + $cellspacing['H'] + $currentcellpadding['R'] + $this->feps))
                                    AND (($trwsp['starty'] < ($this->y - $this->feps)) OR ($trwsp['startpage'] < $this->page) OR
                                         ($trwsp['startcolumn'] < $this->currentcolumn))) {
                                    // Set the starting X position of the current cell.
                                    $this->x = $rsendx + $cellspacingx;
                                    // Increment column indicator.
                                    $colid += $trwsp['colspan'];
                                    if (($trwsp['rowspan'] == 1)
                                        AND (isset($dom[$trid]['endy']))
                                        AND (isset($dom[$trid]['endpage']))
                                        AND (isset($dom[$trid]['endcolumn']))
                                        AND ($trwsp['endpage'] == $dom[$trid]['endpage'])
                                        AND ($trwsp['endcolumn'] == $dom[$trid]['endcolumn'])) {
                                        // Set ending Y position for row.
                                        $dom[$tableel]['rowspans'][$rsk]['endy'] = max($dom[$trid]['endy'], $trwsp['endy']);
                                        $dom[$trid]['endy'] = $dom[$tableel]['rowspans'][$rsk]['endy'];
                                    }
                                    $rsk = 0;
                                } else {
                                    ++$rsk;
                                }
                            }
                        }
                        if (isset($dom[$parentid]['width'])) {
                            // User specified width.
                            $cellw = $this->gethtmlunittounits($dom[$parentid]['width'], $tablecolumnswidth, 'px');
                            $tmpcw = ($cellw / $colspan);
                            for ($i = 0; $i < $colspan; ++$i) {
                                $tablecolwidths[($colid + $i)] = $tmpcw;
                            }
                        } else {
                            // Inherit column width.
                            $cellw = 0;
                            for ($i = 0; $i < $colspan; ++$i) {
                                $cellw += $tablecolwidths[($colid + $i)];
                            }
                        }
                        $cellw += (($colspan - 1) * $cellspacing['H']);
                        // Increment column indicator.
                        $colid += $colspan;
                        // Add rowspan information to table element.
                        if ($rowspan > 1) {
                            $trsid = array_push($dom[$tableel]['rowspans'], array('trid' => $trid,
                                                'rowspan' => $rowspan, 'mrowspan' => $rowspan, 'colspan' => $colspan,
                                                'startpage' => $this->page, 'startcolumn' => $this->currentcolumn,
                                                'startx' => $this->x, 'starty' => $this->y));
                        }
                        $cellid = array_push($dom[$trid]['cellpos'], array('startx' => $this->x));
                        if ($rowspan > 1) {
                            $dom[$trid]['cellpos'][($cellid - 1)]['rowspanid'] = ($trsid - 1);
                        }
                        // Push background colors.
                        if (isset($dom[$parentid]['bgcolor']) AND ($dom[$parentid]['bgcolor'] !== false)) {
                            $dom[$trid]['cellpos'][($cellid - 1)]['bgcolor'] = $dom[$parentid]['bgcolor'];
                        }
                        // Store border info.
                        if (isset($tdborder) AND !empty($tdborder)) {
                            $dom[$trid]['cellpos'][($cellid - 1)]['border'] = $tdborder;
                        }
                        $prevlasth = $this->lasth;
                        // Store some info for multicolumn mode.
                        if ($this->rtl) {
                            $this->colxshift['x'] = $this->w - $this->x - $this->rmargin;
                        } else {
                            $this->colxshift['x'] = $this->x - $this->lmargin;
                        }
                        $this->colxshift['s'] = $cellspacing;
                        $this->colxshift['p'] = $currentcellpadding;
                        // Write the cell content.
                        $this->multicell($cellw, $cellh, $cellcontent, false, $lalign, false, 2, '', '', true, 0,
                                         true, true, 0, 'T', false);
                        // Restore some values.
                        $this->colxshift = array('x' => 0, 's' => array('H' => 0, 'V' => 0), 'p' => array('L' => 0,
                                                 'T' => 0, 'R' => 0, 'B' => 0));
                        $this->lasth = $prevlasth;
                        $this->cellpadding = $oldcellpadding;
                        $dom[$trid]['cellpos'][($cellid - 1)]['endx'] = $this->x;
                        // Update the end of row position.
                        if ($rowspan <= 1) {
                            if (isset($dom[$trid]['endy'])) {
                                if (($this->page == $dom[$trid]['endpage']) AND
                                    ($this->currentcolumn == $dom[$trid]['endcolumn'])) {
                                    $dom[$trid]['endy'] = max($this->y, $dom[$trid]['endy']);
                                } else if (($this->page > $dom[$trid]['endpage']) OR
                                           ($this->currentcolumn > $dom[$trid]['endcolumn'])) {
                                    $dom[$trid]['endy'] = $this->y;
                                }
                            } else {
                                $dom[$trid]['endy'] = $this->y;
                            }
                            if (isset($dom[$trid]['endpage'])) {
                                $dom[$trid]['endpage'] = max($this->page, $dom[$trid]['endpage']);
                            } else {
                                $dom[$trid]['endpage'] = $this->page;
                            }
                            if (isset($dom[$trid]['endcolumn'])) {
                                $dom[$trid]['endcolumn'] = max($this->currentcolumn, $dom[$trid]['endcolumn']);
                            } else {
                                $dom[$trid]['endcolumn'] = $this->currentcolumn;
                            }
                        } else {
                            // Account for row-spanned cells.
                            $dom[$tableel]['rowspans'][($trsid - 1)]['endx'] = $this->x;
                            $dom[$tableel]['rowspans'][($trsid - 1)]['endy'] = $this->y;
                            $dom[$tableel]['rowspans'][($trsid - 1)]['endpage'] = $this->page;
                            $dom[$tableel]['rowspans'][($trsid - 1)]['endcolumn'] = $this->currentcolumn;
                        }
                        if (isset($dom[$tableel]['rowspans'])) {
                            // Update endy and endpage on rowspanned cells.
                            foreach ($dom[$tableel]['rowspans'] as $k => $trwsp) {
                                if ($trwsp['rowspan'] > 0) {
                                    if (isset($dom[$trid]['endpage'])) {
                                        if (($trwsp['endpage'] == $dom[$trid]['endpage']) AND
                                            ($trwsp['endcolumn'] == $dom[$trid]['endcolumn'])) {
                                             $dom[$tableel]['rowspans'][$k]['endy'] =
                                            max($dom[$trid]['endy'], $trwsp['endy']);
                                        } else if (($trwsp['endpage'] < $dom[$trid]['endpage']) OR
                                                   ($trwsp['endcolumn'] < $dom[$trid]['endcolumn'])) {
                                            $dom[$tableel]['rowspans'][$k]['endy'] = $dom[$trid]['endy'];
                                            $dom[$tableel]['rowspans'][$k]['endpage'] = $dom[$trid]['endpage'];
                                            $dom[$tableel]['rowspans'][$k]['endcolumn'] = $dom[$trid]['endcolumn'];
                                        } else {
                                            $dom[$trid]['endy'] = $this->pagedim[$dom[$trid]['endpage']]['hk'] -
                                                                  $this->pagedim[$dom[$trid]['endpage']]['bm'];
                                        }
                                    }
                                }
                            }
                        }
                        $this->x += ($cellspacingx / 2);
                    } else {
                        // Opening tag (or self-closing tag).
                        if (!isset($opentagpos)) {
                            if ($this->inxobj) {
                                // We are inside an XObject template.
                                $opentagpos = strlen($this->xobjects[$this->xobjid]['outdata']);
                            } else if (!$this->infooter) {
                                if (isset($this->footerlen[$this->page])) {
                                    $this->footerpos[$this->page] = $this->pagelen[$this->page] -
                                    $this->footerlen[$this->page];
                                } else {
                                    $this->footerpos[$this->page] = $this->pagelen[$this->page];
                                }
                                $opentagpos = $this->footerpos[$this->page];
                            }
                        }
                        $dom = $this->openhtmltaghandler($dom, $key, $cell);
                    }
                } else { // Closing tag.
                    $prevnumpages = $this->numpages;
                    $oldbordermrk = $this->bordermrk[$this->page];
                    $dom = $this->closehtmltaghandler($dom, $key, $cell, $maxbottomliney);
                    if ($this->bordermrk[$this->page] > $oldbordermrk) {
                        $startlinepos += ($this->bordermrk[$this->page] - $oldbordermrk);
                    }
                    if ($prevnumpages > $this->numpages) {
                        $startlinepage = $this->page;
                    }
                }
            } else if (strlen($dom[$key]['value']) > 0) {
                // Print list-item.
                if (!$this->empty_string($this->lispacer) AND ($this->lispacer != '^')) {
                    $this->setfont($pfontname, $pfontstyle, $pfontsize);
                    $this->resetlasth();
                    $minstartliney = $this->y;
                    $maxbottomliney = ($startliney + ($this->fontsize * $this->cellheightratio));
                    $this->puthtmllistbullet($this->listnum, $this->lispacer, $pfontsize);
                    $this->setfont($curfontname, $curfontstyle, $curfontsize);
                    $this->resetlasth();
                    if (is_numeric($pfontsize) AND ($pfontsize > 0) AND is_numeric($curfontsize) AND
                       ($curfontsize > 0) AND ($pfontsize != $curfontsize)) {
                        $pfontascent = $this->getfontascent($pfontname, $pfontstyle, $pfontsize);
                        $pfontdescent = $this->getfontdescent($pfontname, $pfontstyle, $pfontsize);
                        $this->y += ((($pfontsize - $curfontsize) * $this->cellheightratio / $this->k) +
                        $pfontascent - $curfontascent - $pfontdescent + $curfontdescent) / 2;
                        $minstartliney = min($this->y, $minstartliney);
                        $maxbottomliney = max(($this->y + (($pfontsize * $this->cellheightratio) / $this->k)),
                                               $maxbottomliney);
                    }
                }
                // Text.
                $this->htmlvspace = 0;
                if ((!$this->premode) AND $this->isrtltextdir()) {
                    // Reverse spaces order.
                    $lsp = ''; // Left spaces.
                    $rsp = ''; // Right spaces.
                    if (preg_match('/^('.$this->respace['p'].'+)/'.$this->respace['m'], $dom[$key]['value'],
                        $matches)) {
                        $lsp = $matches[1];
                    }
                    if (preg_match('/('.$this->respace['p'].'+)$/'.$this->respace['m'], $dom[$key]['value'],
                        $matches)) {
                        $rsp = $matches[1];
                    }
                    $dom[$key]['value'] = $rsp.$this->stringtrim($dom[$key]['value']).$lsp;
                }
                if ($newline) {
                    if (!$this->premode) {
                        $prelen = strlen($dom[$key]['value']);
                        if ($this->isrtltextdir()) {
                            // Right trim except non-breaking space.
                            $dom[$key]['value'] = $this->stringrighttrim($dom[$key]['value']);
                        } else {
                            // Left trim except non-breaking space.
                            $dom[$key]['value'] = $this->stringlefttrim($dom[$key]['value']);
                        }
                        $postlen = strlen($dom[$key]['value']);
                        if (($postlen == 0) AND ($prelen > 0)) {
                            $dom[$key]['trimmed_space'] = true;
                        }
                    }
                    $newline = false;
                    $firstblock = true;
                } else {
                    $firstblock = false;
                    // Replace empty multiple spaces string with a single space.
                    $dom[$key]['value'] = preg_replace('/^'.$this->respace['p'].'+$/'.$this->respace['m'], chr(32),
                                          $dom[$key]['value']);
                }
                $strrest = '';
                if ($this->rtl) {
                    $this->x -= $this->textindent;
                } else {
                    $this->x += $this->textindent;
                }
                if (!isset($dom[$key]['trimmed_space']) OR !$dom[$key]['trimmed_space']) {
                    $strlinelen = $this->getstringwidth($dom[$key]['value']);
                    if (!empty($this->href) AND (isset($this->href['url']))) {
                        // HTML <a> link.
                        $hrefcolor = '';
                        if (isset($dom[($dom[$key]['parent'])]['fgcolor']) AND
                                 ($dom[($dom[$key]['parent'])]['fgcolor'] !== false)) {
                            $hrefcolor = $dom[($dom[$key]['parent'])]['fgcolor'];
                        }
                        $hrefstyle = -1;
                        if (isset($dom[($dom[$key]['parent'])]['fontstyle']) AND
                           ($dom[($dom[$key]['parent'])]['fontstyle'] !== false)) {
                            $hrefstyle = $dom[($dom[$key]['parent'])]['fontstyle'];
                        }
                        $strrest = $this->addhtmllink($this->href['url'], $dom[$key]['value'], $wfill, true, $hrefcolor,
                                   $hrefstyle, true);
                    } else {
                        $wadj = 0; // Space to leave for block continuity.
                        if ($this->rtl) {
                            $cwa = $this->x - $this->lmargin;
                        } else {
                            $cwa = $this->w - $this->rmargin - $this->x;
                        }
                        if (($strlinelen < $cwa) AND (isset($dom[($key + 1)])) AND ($dom[($key + 1)]['tag']) AND
                           (!$dom[($key + 1)]['block'])) {
                            // Check the next text blocks for continuity.
                            $nkey = ($key + 1);
                            $writeblock = true;
                            $sametextdir = true;
                            $tmpfontname = $this->fontfamily;
                            $tmpfontstyle = $this->fontstyle;
                            $tmpfontsize = $this->fontsizept;
                            while ($writeblock AND isset($dom[$nkey])) {
                                if ($dom[$nkey]['tag']) {
                                    if ($dom[$nkey]['block']) {
                                        // End of block.
                                        $writeblock = false;
                                    }
                                    $tmpfontname = isset($dom[$nkey]['fontname']) ? $dom[$nkey]['fontname'] : $this->fontfamily;
                                    $tmpfontstyle = isset($dom[$nkey]['fontstyle']) ? $dom[$nkey]['fontstyle'] : $this->fontstyle;
                                    $tmpfontsize = isset($dom[$nkey]['fontsize']) ? $dom[$nkey]['fontsize'] : $this->fontsizept;
                                    $sametextdir = ($dom[$nkey]['dir'] == $dom[$key]['dir']);
                                } else {
                                    $nextstr = preg_split('/'.$this->respace['p'].'+/'.$this->respace['m'], $dom[$nkey]['value']);
                                    if (isset($nextstr[0]) AND $sametextdir) {
                                        $wadj += $this->getstringwidth($nextstr[0], $tmpfontname, $tmpfontstyle, $tmpfontsize);
                                        if (isset($nextstr[1])) {
                                            $writeblock = false;
                                        }
                                    }
                                }
                                ++$nkey;
                            }
                        }
                        if (($wadj > 0) AND (($strlinelen + $wadj) >= $cwa)) {
                            $wadj = 0;
                            $nextstr = preg_split('/'.$this->respace['p'].'/'.$this->respace['m'], $dom[$key]['value']);
                            $numblks = count($nextstr);
                            if ($numblks > 1) {
                                // Try to split on blank spaces.
                                $wadj = ($cwa - $strlinelen + $this->getstringwidth($nextstr[($numblks - 1)]));
                            } else {
                                // Set the entire block on new line.
                                $wadj = $this->getstringwidth($nextstr[0]);
                            }
                        }
                        // Check for reversed text direction.
                        if (($wadj > 0) AND (($this->rtl AND ($this->tmprtl === 'L')) OR
                           (!$this->rtl AND ($this->tmprtl === 'R')))) {
                            // LTR text on RTL direction or RTL text on LTR direction.
                            $reversedir = true;
                            $this->rtl = !$this->rtl;
                            $revshift = ($strlinelen + $wadj + 0.000001); // Add little quantity for rounding problems.
                            if ($this->rtl) {
                                $this->x += $revshift;
                            } else {
                                $this->x -= $revshift;
                            }
                            $xws = $this->x;
                        }
                        // Write only until the end of the line and get the rest.
                        $strrest = $this->write($this->lasth, $dom[$key]['value'], '', $wfill, '', false, 0, true,
                                                $firstblock, 0, $wadj);
                        // Restore default direction.
                        if ($reversedir AND ($wadj == 0)) {
                            $this->x = $xws;
                            $this->rtl = !$this->rtl;
                            $reversedir = false;
                        }
                    }
                }
                $this->textindent = 0;
                if (strlen($strrest) > 0) {
                    // Store the remaining string on the previous $key position.
                    $this->newline = true;
                    if ($strrest == $dom[$key]['value']) {
                        // Used to avoid infinite loop.
                        ++$loop;
                    } else {
                        $loop = 0;
                    }
                    $dom[$key]['value'] = $strrest;
                    if ($cell) {
                        if ($this->rtl) {
                            $this->x -= $this->cellpadding['R'];
                        } else {
                            $this->x += $this->cellpadding['L'];
                        }
                    }
                    if ($loop < 3) {
                        --$key;
                    }
                } else {
                    $loop = 0;
                }
            }
            ++$key;
            if (isset($dom[$key]['tag']) AND $dom[$key]['tag'] AND (!isset($dom[$key]['opening']) OR
                     !$dom[$key]['opening']) AND isset($dom[($dom[$key]['parent'])]['attribute']['nobr']) AND
                      ($dom[($dom[$key]['parent'])]['attribute']['nobr'] == 'true')) {
                // Check if we are on a new page or on a new column.
                if ((!$undo) AND (($this->y < $this->starttransactiony) OR (($dom[$key]['value'] == 'tr') AND
                ($dom[($dom[$key]['parent'])]['endy'] < $this->starttransactiony)))) {
                    // We are on a new page or on a new column and the total object height is less than the
                    // available vertical space.
                    // Restore previous object.
                    $this->rollbacktransaction(true);
                    // Restore previous values.
                    foreach ($thismethodvars as $vkey => $vval) {
                        $$vkey = $vval;
                    }
                    // Add a page (or trig acceptpagebreak() for multicolumn mode).
                    $prey = $this->y;
                    if ((!$this->checkpagebreak($this->pagebreaktrigger + 1)) AND ($this->y < $prey)) {
                        $startliney = $this->y;
                    }
                    $undo = true; // Avoid infinite loop.
                } else {
                    $undo = false;
                }
            }
        } // End for each $key.
        // Align the last line.
        if (isset($startlinex)) {
            $yshift = ($minstartliney - $startliney);
            if (($yshift > 0) OR ($this->page > $startlinepage)) {
                $yshift = 0;
            }
            $tx = 0;
            // The last line must be shifted to be aligned as requested.
            $linew = abs($this->endlinex - $startlinex);
            if ($this->inxobj) {
                // We are inside an XObject template.
                $pstart = substr($this->xobjects[$this->xobjid]['outdata'], 0, $startlinepos);
                if (isset($opentagpos)) {
                    $midpos = $opentagpos;
                } else {
                    $midpos = 0;
                }
                if ($midpos > 0) {
                    $pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos, ($midpos - $startlinepos));
                    $pend = substr($this->xobjects[$this->xobjid]['outdata'], $midpos);
                } else {
                    $pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos);
                    $pend = '';
                }
            } else {
                $pstart = substr($this->getpagebuffer($startlinepage), 0, $startlinepos);
                if (isset($opentagpos) AND isset($this->footerlen[$startlinepage]) AND (!$this->infooter)) {
                    $this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
                    $midpos = min($opentagpos, $this->footerpos[$startlinepage]);
                } else if (isset($opentagpos)) {
                    $midpos = $opentagpos;
                } else if (isset($this->footerlen[$startlinepage]) AND (!$this->infooter)) {
                    $this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
                    $midpos = $this->footerpos[$startlinepage];
                } else {
                    $midpos = 0;
                }
                if ($midpos > 0) {
                    $pmid = substr($this->getpagebuffer($startlinepage), $startlinepos, ($midpos - $startlinepos));
                    $pend = substr($this->getpagebuffer($startlinepage), $midpos);
                } else {
                    $pmid = substr($this->getpagebuffer($startlinepage), $startlinepos);
                    $pend = '';
                }
            }
            if ((isset($plalign) AND ((($plalign == 'C') OR (($plalign == 'R') AND (!$this->rtl)) OR (($plalign == 'L')
                 AND ($this->rtl)))))) {
                // Calculate shifting amount.
                $tw = $w;
                if ($this->lmargin != $prevlmargin) {
                    $tw += ($prevlmargin - $this->lmargin);
                }
                if ($this->rmargin != $prevrmargin) {
                    $tw += ($prevrmargin - $this->rmargin);
                }
                $onespacewidth = $this->getstringwidth(chr(32));
                $no = 0; // Number of spaces on a line contained on a single block.
                if ($this->isrtltextdir()) { // RTL.
                    // Remove left space if exist.
                    $pos1 = $this->revstrpos($pmid, '[(');
                    if ($pos1 > 0) {
                        $pos1 = intval($pos1);
                        if ($this->isunicodefont()) {
                            $pos2 = intval($this->revstrpos($pmid, '[('.chr(0).chr(32)));
                            $spacelen = 2;
                        } else {
                            $pos2 = intval($this->revstrpos($pmid, '[('.chr(32)));
                            $spacelen = 1;
                        }
                        if ($pos1 == $pos2) {
                            $pmid = substr($pmid, 0, ($pos1 + 2)).substr($pmid, ($pos1 + 2 + $spacelen));
                            if (substr($pmid, $pos1, 4) == '[()]') {
                                $linew -= $onespacewidth;
                            } else if ($pos1 == strpos($pmid, '[(')) {
                                $no = 1;
                            }
                        }
                    }
                } else { // LTR.
                    // Remove right space if exist.
                    $pos1 = $this->revstrpos($pmid, ')]');
                    if ($pos1 > 0) {
                        $pos1 = intval($pos1);
                        if ($this->isunicodefont()) {
                            $pos2 = intval($this->revstrpos($pmid, chr(0).chr(32).')]')) + 2;
                            $spacelen = 2;
                        } else {
                            $pos2 = intval($this->revstrpos($pmid, chr(32).')]')) + 1;
                            $spacelen = 1;
                        }
                        if ($pos1 == $pos2) {
                            $pmid = substr($pmid, 0, ($pos1 - $spacelen)).substr($pmid, $pos1);
                            $linew -= $onespacewidth;
                        }
                    }
                }
                $mdiff = ($tw - $linew);
                if ($plalign == 'C') {
                    if ($this->rtl) {
                        $tx = -($mdiff / 2);
                    } else {
                        $tx = ($mdiff / 2);
                    }
                } else if ($plalign == 'R') {
                    // Right alignment on LTR document.
                    $tx = $mdiff;
                } else if ($plalign == 'L') {
                    // Left alignment on RTL document.
                    $tx = -$mdiff;
                }
            } // End if startlinex.
            if (($tx != 0) OR ($yshift < 0)) {
                // Shift the line.
                $trx = sprintf('1 0 0 1 %F %F cm', ($tx * $this->k), ($yshift * $this->k));
                $pstart .= "\nq\n".$trx."\n".$pmid."\nQ\n";
                $endlinepos = strlen($pstart);
                if ($this->inxobj) {
                    // We are inside an XObject template.
                    $this->xobjects[$this->xobjid]['outdata'] = $pstart.$pend;
                    foreach ($this->xobjects[$this->xobjid]['annotations'] as $pak => $pac) {
                        if ($pak >= $pask) {
                            $this->xobjects[$this->xobjid]['annotations'][$pak]['x'] += $tx;
                            $this->xobjects[$this->xobjid]['annotations'][$pak]['y'] -= $yshift;
                        }
                    }
                } else {
                    $this->setpagebuffer($startlinepage, $pstart.$pend);
                    // Shift the annotations and links.
                    if (isset($this->pageannots[$this->page])) {
                        foreach ($this->pageannots[$this->page] as $pak => $pac) {
                            if ($pak >= $pask) {
                                $this->pageannots[$this->page][$pak]['x'] += $tx;
                                $this->pageannots[$this->page][$pak]['y'] -= $yshift;
                            }
                        }
                    }
                }
                $this->y -= $yshift;
                $yshift = 0;
            }
        }
        // Restore previous values.
        $this->setgraphicvars($gvars);
        if ($this->numcolumns > 1) {
            $this->selectcolumn();
        } else if ($this->page > $prevpage) {
            $this->lmargin = $this->pagedim[$this->page]['olm'];
            $this->rmargin = $this->pagedim[$this->page]['orm'];
        }
        // Restore previous list state.
        $this->cellheightratio = $prevcellheightratio;
        $this->listnum = $prevlistnum;
        $this->listordered = $prevlistordered;
        $this->listcount = $prevlistcount;
        $this->lispacer = $prevlispacer;
        if ($ln AND (!($cell AND ($dom[$key - 1]['value'] == 'table')))) {
            $this->ln($this->lasth);
            if ($this->y < $maxbottomliney) {
                $this->y = $maxbottomliney;
            }
        }
        unset($dom);
    }

    /**
     * Process opening tags.
     */
    protected function openhtmltaghandler($dom, $key, $cell) {
        $tag = $dom[$key];
        $parent = $dom[($dom[$key]['parent'])];
        $firsttag = ($key == 1);
        // Check for text direction attribute.
        if (isset($tag['dir'])) {
            $this->settemprtl($tag['dir']);
        } else {
            $this->tmprtl = false;
        }
        if ($tag['block']) {
            $hbz = 0; // Distance from y to line bottom.
            $hb = 0; // Vertical space between block tags.
            // Calculate vertical space for block tags.
            if (isset($this->tagvspaces[$tag['value']][0]['h']) AND ($this->tagvspaces[$tag['value']][0]['h'] >= 0)) {
                $curh = $this->tagvspaces[$tag['value']][0]['h'];
            } else if (isset($tag['fontsize'])) {
                $curh = ($tag['fontsize'] / $this->k) * $this->cellheightratio;
            } else {
                $curh = $this->fontsize * $this->cellheightratio;
            }
            if (isset($this->tagvspaces[$tag['value']][0]['n'])) {
                $n = $this->tagvspaces[$tag['value']][0]['n'];
            } else if (preg_match('/[h][0-9]/', $tag['value']) > 0) {
                $n = 0.6;
            } else {
                $n = 1;
            }
            if ((!isset($this->tagvspaces[$tag['value']])) AND (in_array($tag['value'],
                array('div', 'dt', 'dd', 'li', 'br')))) {
                $hb = 0;
            } else {
                $hb = ($n * $curh);
            }
            if (($this->htmlvspace <= 0) AND ($n > 0)) {
                if (isset($parent['fontsize'])) {
                    $hbz = (($parent['fontsize'] / $this->k) * $this->cellheightratio);
                } else {
                    $hbz = $this->fontsize * $this->cellheightratio;
                }
            }
        }
        // Opening tag.
        switch($tag['value']) {
            case 'table': {
                $cp = 0;
                $cs = 0;
                $dom[$key]['rowspans'] = array();
                if (!isset($dom[$key]['attribute']['nested']) OR ($dom[$key]['attribute']['nested'] != 'true')) {
                    // Set table header.
                    if (!$this->empty_string($dom[$key]['thead'])) {
                        // Set table header.
                        $this->thead = $dom[$key]['thead'];
                        if (!isset($this->theadmargins) OR (empty($this->theadmargins))) {
                            $this->theadmargins = array();
                            $this->theadmargins['cellpadding'] = $this->cellpadding;
                            $this->theadmargins['lmargin'] = $this->lmargin;
                            $this->theadmargins['rmargin'] = $this->rmargin;
                            $this->theadmargins['page'] = $this->page;
                            $this->theadmargins['cell'] = $cell;
                        }
                    }
                }
                // Store current margins and page.
                $dom[$key]['oldcellpadding'] = $this->cellpadding;
                if (isset($tag['attribute']['cellpadding'])) {
                    $pad = $this->gethtmlunittounits($tag['attribute']['cellpadding'], 1, 'px');
                    $this->setcellpadding($pad);
                } else if (isset($tag['padding'])) {
                    $this->cellpadding = $tag['padding'];
                }
                if (isset($tag['attribute']['cellspacing'])) {
                    $cs = $this->gethtmlunittounits($tag['attribute']['cellspacing'], 1, 'px');
                } else if (isset($tag['border-spacing'])) {
                    $cs = $tag['border-spacing']['V'];
                }
                $prevy = $this->y;
                if ($this->checkpagebreak(((2 * $cp) + (2 * $cs) + $this->lasth), '', false) OR ($this->y < $prevy)) {
                    $this->inthead = true;
                    // Add a page (or trig acceptpagebreak() for multicolumn mode).
                    $this->checkpagebreak($this->pagebreaktrigger + 1);
                }
                break;
            }
            case 'tr': {
                // Array of columns positions.
                $dom[$key]['cellpos'] = array();
                break;
            }
            case 'hr': {
                if ((isset($tag['height'])) AND ($tag['height'] != '')) {
                    $hrheight = $this->gethtmlunittounits($tag['height'], 1, 'px');
                } else {
                    $hrheight = $this->getlinewidth();
                }
                $this->addhtmlvertspace($hbz, ($hrheight / 2), $cell, $firsttag);
                $x = $this->getx();
                $y = $this->gety();
                $wtmp = $this->w - $this->lmargin - $this->rmargin;
                if ($cell) {
                    $wtmp -= ($this->cellpadding['L'] + $this->cellpadding['R']);
                }
                if ((isset($tag['width'])) AND ($tag['width'] != '')) {
                    $hrwidth = $this->gethtmlunittounits($tag['width'], $wtmp, 'px');
                } else {
                    $hrwidth = $wtmp;
                }
                $prevlinewidth = $this->getlinewidth();
                $this->setlinewidth($hrheight);
                $this->line($x, $y, $x + $hrwidth, $y);
                $this->setlinewidth($prevlinewidth);
                $this->addhtmlvertspace(($hrheight / 2), 0, $cell, !isset($dom[($key + 1)]));
                break;
            }
            case 'a': {
                if (array_key_exists('href', $tag['attribute'])) {
                    $this->href['url'] = $tag['attribute']['href'];
                }
                break;
            }
            case 'img': {
                if (isset($tag['attribute']['src'])) {
                    if ($tag['attribute']['src']{0} === '@') {
                        // Data stream.
                        $tag['attribute']['src'] = '@'.base64_decode(substr($tag['attribute']['src'], 1));
                        $type = '';
                    } else {
                        // Check for images without protocol.
                        if (preg_match('%^/{2}%', $tag['attribute']['src'])) {
                            $tag['attribute']['src'] = 'http:'.$tag['attribute']['src'];
                        }
                        // Replace relative path with real server path.
                        if (($tag['attribute']['src'][0] == '/') AND !empty($_SERVER['DOCUMENT_ROOT']) AND
                            ($_SERVER['DOCUMENT_ROOT'] != '/')) {
                            $findroot = strpos($tag['attribute']['src'], $_SERVER['DOCUMENT_ROOT']);
                            if (($findroot === false) OR ($findroot > 1)) {
                                if (substr($_SERVER['DOCUMENT_ROOT'], -1) == '/') {
                                    $tag['attribute']['src'] = substr($_SERVER['DOCUMENT_ROOT'], 0, -1).
                                    $tag['attribute']['src'];
                                } else {
                                    $tag['attribute']['src'] = $_SERVER['DOCUMENT_ROOT'].$tag['attribute']['src'];
                                }
                            }
                        }
                        $tag['attribute']['src'] = htmlspecialchars_decode(urldecode($tag['attribute']['src']));
                        $type = $this->getimagefiletype($tag['attribute']['src']);
                        $testscrtype = @parse_url($tag['attribute']['src']);
                        if (!isset($testscrtype['query']) OR empty($testscrtype['query'])) {
                            // Convert URL to server path.
                            $tag['attribute']['src'] = str_replace(K_PATH_URL, K_PATH_MAIN, $tag['attribute']['src']);
                        }
                    }
                    if (!isset($tag['width'])) {
                        $tag['width'] = 0;
                    }
                    if (!isset($tag['height'])) {
                        $tag['height'] = 0;
                    }
                    $tag['attribute']['align'] = 'bottom';
                    switch($tag['attribute']['align']) {
                        case 'top': {
                            $align = 'T';
                            break;
                        }
                        case 'middle': {
                            $align = 'M';
                            break;
                        }
                        case 'bottom': {
                            $align = 'B';
                            break;
                        }
                        default: {
                            $align = 'B';
                            break;
                        }
                    }
                    $prevy = $this->y;
                    $xpos = $this->x;
                    $imglink = '';
                    if (isset($this->href['url']) AND !$this->empty_string($this->href['url'])) {
                        $imglink = $this->href['url'];
                        if ($imglink{0} == '#') {
                            // Convert url to internal link.
                            $lnkdata = explode(',', $imglink);
                            if (isset($lnkdata[0])) {
                                $page = intval(substr($lnkdata[0], 1));
                                if (empty($page) OR ($page <= 0)) {
                                    $page = $this->page;
                                }
                                if (isset($lnkdata[1]) AND (strlen($lnkdata[1]) > 0)) {
                                    $lnky = floatval($lnkdata[1]);
                                } else {
                                    $lnky = 0;
                                }
                                $imglink = $this->addlink();
                                $this->setlink($imglink, $lnky, $page);
                            }
                        }
                    }
                    $border = 0;
                    if (isset($tag['border']) AND !empty($tag['border'])) {
                        // Currently only support 1 (frame) or a combination of 'LTRB'.
                        $border = $tag['border'];
                    }
                    $iw = '';
                    if (isset($tag['width'])) {
                        $iw = $this->gethtmlunittounits($tag['width'], 1, 'px', false);
                    }
                    $ih = '';
                    if (isset($tag['height'])) {
                        $ih = $this->gethtmlunittounits($tag['height'], 1, 'px', false);
                    }
                    if (($type == 'eps') OR ($type == 'ai')) {
                        $this->imageeps($tag['attribute']['src'], $xpos, $this->y, $iw, $ih, $imglink, true, $align,
                                        '', $border, true);
                    } else if ($type == 'svg') {
                        $this->imagesvg($tag['attribute']['src'], $xpos, $this->y, $iw, $ih, $imglink, $align, '',
                                        $border, true);
                    } else {
                        $this->imageq($tag['attribute']['src'], $xpos, $this->y, $iw, $ih, '', $imglink, $align, false,
                               300, '', false, false, $border, false, false, true);
                    }
                    switch($align) {
                        case 'T': {
                            $this->y = $prevy;
                            break;
                        }
                        case 'M': {
                            $this->y = (($this->imgrby + $prevy - ($tag['fontsize'] / $this->k)) / 2);
                            break;
                        }
                        case 'B': {
                            $this->y = $this->imgrby - ($tag['fontsize'] / $this->k);
                            break;
                        }
                    }
                }
                break;
            }
            case 'dl': {
                ++$this->listnum;
                if ($this->listnum == 1) {
                    $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                } else {
                    $this->addhtmlvertspace(0, 0, $cell, $firsttag);
                }
                break;
            }
            case 'dt': {
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                break;
            }
            case 'dd': {
                if ($this->rtl) {
                    $this->rmargin += $this->listindent;
                } else {
                    $this->lmargin += $this->listindent;
                }
                ++$this->listindentlevel;
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                break;
            }
            case 'ul':
            case 'ol': {
                ++$this->listnum;
                if ($tag['value'] == 'ol') {
                    $this->listordered[$this->listnum] = true;
                } else {
                    $this->listordered[$this->listnum] = false;
                }
                if (isset($tag['attribute']['start'])) {
                    $this->listcount[$this->listnum] = intval($tag['attribute']['start']) - 1;
                } else {
                    $this->listcount[$this->listnum] = 0;
                }
                if ($this->rtl) {
                    $this->rmargin += $this->listindent;
                    $this->x -= $this->listindent;
                } else {
                    $this->lmargin += $this->listindent;
                    $this->x += $this->listindent;
                }
                ++$this->listindentlevel;
                if ($this->listnum == 1) {
                    if ($key > 1) {
                        $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                    }
                } else {
                    $this->addhtmlvertspace(0, 0, $cell, $firsttag);
                }
                break;
            }
            case 'li': {
                if ($key > 2) {
                    $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                }
                if ($this->listordered[$this->listnum]) {
                    // Ordered item.
                    if (isset($parent['attribute']['type']) AND !$this->empty_string($parent['attribute']['type'])) {
                        $this->lispacer = $parent['attribute']['type'];
                    } else if (isset($parent['listtype']) AND !$this->empty_string($parent['listtype'])) {
                        $this->lispacer = $parent['listtype'];
                    } else if (isset($this->lisymbol) AND !$this->empty_string($this->lisymbol)) {
                        $this->lispacer = $this->lisymbol;
                    } else {
                        $this->lispacer = '#';
                    }
                    ++$this->listcount[$this->listnum];
                    if (isset($tag['attribute']['value'])) {
                        $this->listcount[$this->listnum] = intval($tag['attribute']['value']);
                    }
                } else {
                    // Unordered item.
                    if (isset($parent['attribute']['type']) AND !$this->empty_string($parent['attribute']['type'])) {
                        $this->lispacer = $parent['attribute']['type'];
                    } else if (isset($parent['listtype']) AND !$this->empty_string($parent['listtype'])) {
                        $this->lispacer = $parent['listtype'];
                    } else if (isset($this->lisymbol) AND !$this->empty_string($this->lisymbol)) {
                        $this->lispacer = $this->lisymbol;
                    } else {
                        $this->lispacer = '!';
                    }
                }
                break;
            }
            case 'blockquote': {
                if ($this->rtl) {
                    $this->rmargin += $this->listindent;
                } else {
                    $this->lmargin += $this->listindent;
                }
                ++$this->listindentlevel;
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                break;
            }
            case 'br': {
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                break;
            }
            case 'div': {
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                break;
            }
            case 'p': {
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                break;
            }
            case 'pre': {
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                $this->premode = true;
                break;
            }
            case 'sup': {
                $this->setxy($this->getx(), $this->gety() - ((0.7 * $this->fontsizept) / $this->k));
                break;
            }
            case 'sub': {
                $this->setxy($this->getx(), $this->gety() + ((0.3 * $this->fontsizept) / $this->k));
                break;
            }
            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6': {
                $this->addhtmlvertspace($hbz, $hb, $cell, $firsttag);
                break;
            }
            case 'form': {
                if (isset($tag['attribute']['action'])) {
                    $this->formaction = $tag['attribute']['action'];
                } else {
                    $this->formaction = K_PATH_URL.$_SERVER['SCRIPT_NAME'];
                }
                if (isset($tag['attribute']['enctype'])) {
                    $this->formenctype = $tag['attribute']['enctype'];
                } else {
                    $this->formenctype = 'application/x-www-form-urlencoded';
                }
                if (isset($tag['attribute']['method'])) {
                    $this->formmode = $tag['attribute']['method'];
                } else {
                    $this->formmode = 'post';
                }
                break;
            }
            case 'input': {
                if (isset($tag['attribute']['name']) AND !$this->empty_string($tag['attribute']['name'])) {
                    $name = $tag['attribute']['name'];
                } else {
                    break;
                }
                $prop = array();
                $opt = array();
                if (isset($tag['attribute']['readonly']) AND !$this->empty_string($tag['attribute']['readonly'])) {
                    $prop['readonly'] = true;
                }
                if (isset($tag['attribute']['value']) AND !$this->empty_string($tag['attribute']['value'])) {
                    $value = $tag['attribute']['value'];
                }
                if (isset($tag['attribute']['maxlength']) AND !$this->empty_string($tag['attribute']['maxlength'])) {
                    $opt['maxlen'] = intval($tag['attribute']['maxlength']);
                }
                $h = $this->fontsize * $this->cellheightratio;
                if (isset($tag['attribute']['size']) AND !$this->empty_string($tag['attribute']['size'])) {
                    $w = intval($tag['attribute']['size']) * $this->getstringwidth(chr(32)) * 2;
                } else {
                    $w = $h;
                }
                if (isset($tag['attribute']['checked']) AND (($tag['attribute']['checked'] == 'checked') OR
                         ($tag['attribute']['checked'] == 'true'))) {
                    $checked = true;
                } else {
                    $checked = false;
                }
                if (isset($tag['align'])) {
                    switch ($tag['align']) {
                        case 'C': {
                            $opt['q'] = 1;
                            break;
                        }
                        case 'R': {
                            $opt['q'] = 2;
                            break;
                        }
                        case 'L':
                        default: {
                            break;
                        }
                    }
                }
                switch ($tag['attribute']['type']) {
                    case 'text': {
                        if (isset($value)) {
                            $opt['v'] = $value;
                        }
                        $this->textfield($name, $w, $h, $prop, $opt, '', '', false);
                        break;
                    }
                    case 'password': {
                        if (isset($value)) {
                            $opt['v'] = $value;
                        }
                        $prop['password'] = 'true';
                        $this->textfield($name, $w, $h, $prop, $opt, '', '', false);
                        break;
                    }
                    case 'checkbox': {
                        if (!isset($value)) {
                            break;
                        }
                        $this->checkbox($name, $w, $checked, $prop, $opt, $value, '', '', false);
                        break;
                    }
                    case 'radio': {
                        if (!isset($value)) {
                            break;
                        }
                        $this->radiobutton($name, $w, $prop, $opt, $value, $checked, '', '', false);
                        break;
                    }
                    case 'submit': {
                        if (!isset($value)) {
                            $value = 'submit';
                        }
                        $w = $this->getstringwidth($value) * 1.5;
                        $h *= 1.6;
                        $prop = array('lineWidth' => 1, 'borderStyle' => 'beveled', 'fillColor' => array(196, 196, 196),
                                      'strokeColor' => array(255, 255, 255));
                        $action = array();
                        $action['S'] = 'SubmitForm';
                        $action['F'] = $this->formaction;
                        if ($this->formenctype != 'FDF') {
                            $action['Flags'] = array('ExportFormat');
                        }
                        if ($this->formmode == 'get') {
                            $action['Flags'] = array('GetMethod');
                        }
                        $this->button($name, $w, $h, $value, $action, $prop, $opt, '', '', false);
                        break;
                    }
                    case 'reset': {
                        if (!isset($value)) {
                            $value = 'reset';
                        }
                        $w = $this->getstringwidth($value) * 1.5;
                        $h *= 1.6;
                        $prop = array('lineWidth' => 1, 'borderStyle' => 'beveled', 'fillColor' => array(196, 196, 196),
                                      'strokeColor' => array(255, 255, 255));
                        $this->button($name, $w, $h, $value, array('S' => 'ResetForm'), $prop, $opt, '', '', false);
                        break;
                    }
                    case 'file': {
                        $prop['fileSelect'] = 'true';
                        $this->textfield($name, $w, $h, $prop, $opt, '', '', false);
                        if (!isset($value)) {
                            $value = '*';
                        }
                        $w = $this->getstringwidth($value) * 2;
                        $h *= 1.2;
                        $prop = array('lineWidth' => 1, 'borderStyle' => 'beveled', 'fillColor' => array(196, 196, 196),
                                      'strokeColor' => array(255, 255, 255));
                        $jsaction = 'var f=this.getField(\''.$name.'\'); f.browseForFileToSubmit();';
                        $this->button('FB_'.$name, $w, $h, $value, $jsaction, $prop, $opt, '', '', false);
                        break;
                    }
                    case 'hidden': {
                        if (isset($value)) {
                            $opt['v'] = $value;
                        }
                        $opt['f'] = array('invisible', 'hidden');
                        $this->textfield($name, 0, 0, $prop, $opt, '', '', false);
                        break;
                    }
                    case 'image': {
                        // THIS TYPE MUST BE FIXED.
                        if (isset($tag['attribute']['src']) AND !$this->empty_string($tag['attribute']['src'])) {
                            $img = $tag['attribute']['src'];
                        } else {
                            break;
                        }
                        $value = 'img';
                        if (isset($tag['attribute']['onclick']) AND !empty($tag['attribute']['onclick'])) {
                            $jsaction = $tag['attribute']['onclick'];
                        } else {
                            $jsaction = '';
                        }
                        $this->button($name, $w, $h, $value, $jsaction, $prop, $opt, '', '', false);
                        break;
                    }
                    case 'button': {
                        if (!isset($value)) {
                            $value = ' ';
                        }
                        $w = $this->getstringwidth($value) * 1.5;
                        $h *= 1.6;
                        $prop = array('lineWidth' => 1, 'borderStyle' => 'beveled', 'fillColor' => array(196, 196, 196),
                                      'strokeColor' => array(255, 255, 255));
                        if (isset($tag['attribute']['onclick']) AND !empty($tag['attribute']['onclick'])) {
                            $jsaction = $tag['attribute']['onclick'];
                        } else {
                            $jsaction = '';
                        }
                        $this->button($name, $w, $h, $value, $jsaction, $prop, $opt, '', '', false);
                        break;
                    }
                }
                break;
            }
            case 'textarea': {
                $prop = array();
                $opt = array();
                if (isset($tag['attribute']['readonly']) AND !$this->empty_string($tag['attribute']['readonly'])) {
                    $prop['readonly'] = true;
                }
                if (isset($tag['attribute']['name']) AND !$this->empty_string($tag['attribute']['name'])) {
                    $name = $tag['attribute']['name'];
                } else {
                    break;
                }
                if (isset($tag['attribute']['value']) AND !$this->empty_string($tag['attribute']['value'])) {
                    $opt['v'] = $tag['attribute']['value'];
                }
                if (isset($tag['attribute']['cols']) AND !$this->empty_string($tag['attribute']['cols'])) {
                    $w = intval($tag['attribute']['cols']) * $this->getstringwidth(chr(32)) * 2;
                } else {
                    $w = 40;
                }
                if (isset($tag['attribute']['rows']) AND !$this->empty_string($tag['attribute']['rows'])) {
                    $h = intval($tag['attribute']['rows']) * $this->fontsize * $this->cellheightratio;
                } else {
                    $h = 10;
                }
                $prop['multiline'] = 'true';
                $this->textfield($name, $w, $h, $prop, $opt, '', '', false);
                break;
            }
            case 'select': {
                $h = $this->fontsize * $this->cellheightratio;
                if (isset($tag['attribute']['size']) AND !$this->empty_string($tag['attribute']['size'])) {
                    $h *= ($tag['attribute']['size'] + 1);
                }
                $prop = array();
                $opt = array();
                if (isset($tag['attribute']['name']) AND !$this->empty_string($tag['attribute']['name'])) {
                    $name = $tag['attribute']['name'];
                } else {
                    break;
                }
                $w = 0;
                if (isset($tag['attribute']['opt']) AND !$this->empty_string($tag['attribute']['opt'])) {
                    $options = explode('#!NwL!#', $tag['attribute']['opt']);
                    $values = array();
                    foreach ($options as $val) {
                        if (strpos($val, '#!TaB!#') !== false) {
                            $opts = explode('#!TaB!#', $val);
                            $values[] = $opts;
                            $w = max($w, $this->getstringwidth($opts[1]));
                        } else {
                            $values[] = $val;
                            $w = max($w, $this->getstringwidth($val));
                        }
                    }
                } else {
                    break;
                }
                $w *= 2;
                if (isset($tag['attribute']['multiple']) AND ($tag['attribute']['multiple'] = 'multiple')) {
                    $prop['multipleSelection'] = 'true';
                    $this->listbox($name, $w, $h, $values, $prop, $opt, '', '', false);
                } else {
                    $this->combobox($name, $w, $h, $values, $prop, $opt, '', '', false);
                }
                break;
            }
            case 'tcpdf': {
                if (defined('K_TCPDF_CALLS_IN_HTML') AND (K_TCPDF_CALLS_IN_HTML === true)) {
                    // Special tag used to call TCPDF methods.
                    if (isset($tag['attribute']['method'])) {
                        $tcpdfmethod = $tag['attribute']['method'];
                        if (method_exists($this, $tcpdfmethod)) {
                            if (isset($tag['attribute']['params']) AND (!empty($tag['attribute']['params']))) {
                                $params = unserialize(urldecode($tag['attribute']['params']));
                                call_user_func_array(array($this, $tcpdfmethod), $params);
                            } else {
                                $this->$tcpdfmethod();
                            }
                            $this->newline = true;
                        }
                    }
                }
                break;
            }
            default: {
                break;
            }
        }
        // Define tags that support borders and background colors.
        $bordertags = array('blockquote', 'br', 'dd', 'dl', 'div', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr',
                            'li', 'ol', 'p', 'pre', 'ul', 'tcpdf', 'table');
        if (in_array($tag['value'], $bordertags)) {
            // Set border.
            $dom[$key]['borderposition'] = $this->getborderstartposition();
        }
        if ($dom[$key]['self'] AND isset($dom[$key]['attribute']['pagebreakafter'])) {
            $pba = $dom[$key]['attribute']['pagebreakafter'];
            // Check for pagebreak.
            if (($pba == 'true') OR ($pba == 'left') OR ($pba == 'right')) {
                // Add a page (or trig acceptpagebreak() for multicolumn mode).
                $this->checkpagebreak($this->pagebreaktrigger + 1);
            }
            if ((($pba == 'left') AND (((!$this->rtl) AND (($this->page % 2) == 0)) OR
               (($this->rtl) AND (($this->page % 2) != 0))))
                OR (($pba == 'right') AND (((!$this->rtl) AND (($this->page % 2) != 0)) OR
                   (($this->rtl) AND (($this->page % 2) == 0))))) {
                // Add a page (or trig acceptpagebreak() for multicolumn mode).
                $this->checkpagebreak($this->pagebreaktrigger + 1);
            }
        }
        return $dom;
    }

    /**
     * Process closing tags.
     */
    protected function closehtmltaghandler($dom, $key, $cell, $maxbottomliney=0) {
        $tag = $dom[$key];
        $parent = $dom[($dom[$key]['parent'])];
        $lasttag = ((!isset($dom[($key + 1)])) OR ((!isset($dom[($key + 2)])) AND
                   ($dom[($key + 1)]['value'] == 'marker')));
        $intablehead = false;
        // Maximum x position (used to draw borders).
        if ($this->rtl) {
            $xmax = $this->w;
        } else {
            $xmax = 0;
        }
        if ($tag['block']) {
            $hbz = 0; // Distance from y to line bottom.
            $hb = 0; // Vertical space between block tags.
            // Calculate vertical space for block tags.
            if (isset($this->tagvspaces[$tag['value']][1]['h']) AND ($this->tagvspaces[$tag['value']][1]['h'] >= 0)) {
                $preh = $this->tagvspaces[$tag['value']][1]['h'];
            } else if (isset($parent['fontsize'])) {
                $preh = (($parent['fontsize'] / $this->k) * $this->cellheightratio);
            } else {
                $preh = $this->fontsize * $this->cellheightratio;
            }
            if (isset($this->tagvspaces[$tag['value']][1]['n'])) {
                $n = $this->tagvspaces[$tag['value']][1]['n'];
            } else if (preg_match('/[h][0-9]/', $tag['value']) > 0) {
                $n = 0.6;
            } else {
                $n = 1;
            }
            if ((!isset($this->tagvspaces[$tag['value']])) AND ($tag['value'] == 'div')) {
                $hb = 0;
            } else {
                $hb = ($n * $preh);
            }
            if ($maxbottomliney > $this->pagebreaktrigger) {
                $hbz = ($this->fontsize * $this->cellheightratio);
            } else if ($this->y < $maxbottomliney) {
                $hbz = ($maxbottomliney - $this->y);
            }
        }
        // Closing tag.
        switch($tag['value']) {
            case 'tr': {
                $tableel = $dom[($dom[$key]['parent'])]['parent'];
                if (!isset($parent['endy'])) {
                    $dom[($dom[$key]['parent'])]['endy'] = $this->y;
                    $parent['endy'] = $this->y;
                }
                if (!isset($parent['endpage'])) {
                    $dom[($dom[$key]['parent'])]['endpage'] = $this->page;
                    $parent['endpage'] = $this->page;
                }
                if (!isset($parent['endcolumn'])) {
                    $dom[($dom[$key]['parent'])]['endcolumn'] = $this->currentcolumn;
                    $parent['endcolumn'] = $this->currentcolumn;
                }
                // Update row-spanned cells.
                if (isset($dom[$tableel]['rowspans'])) {
                    foreach ($dom[$tableel]['rowspans'] as $k => $trwsp) {
                        $dom[$tableel]['rowspans'][$k]['rowspan'] -= 1;
                        if ($dom[$tableel]['rowspans'][$k]['rowspan'] == 0) {
                            if (($dom[$tableel]['rowspans'][$k]['endpage'] == $parent['endpage']) AND
                                ($dom[$tableel]['rowspans'][$k]['endcolumn'] == $parent['endcolumn'])) {
                                $dom[($dom[$key]['parent'])]['endy'] = max($dom[$tableel]['rowspans'][$k]['endy'],
                                      $parent['endy']);
                            } else if (($dom[$tableel]['rowspans'][$k]['endpage'] > $parent['endpage']) OR
                                       ($dom[$tableel]['rowspans'][$k]['endcolumn'] > $parent['endcolumn'])) {
                                $dom[($dom[$key]['parent'])]['endy'] = $dom[$tableel]['rowspans'][$k]['endy'];
                                $dom[($dom[$key]['parent'])]['endpage'] = $dom[$tableel]['rowspans'][$k]['endpage'];
                                $dom[($dom[$key]['parent'])]['endcolumn'] = $dom[$tableel]['rowspans'][$k]['endcolumn'];
                            }
                        }
                    }
                    // Report new endy and endpage to the rowspanned cells.
                    foreach ($dom[$tableel]['rowspans'] as $k => $trwsp) {
                        if ($dom[$tableel]['rowspans'][$k]['rowspan'] == 0) {
                            $dom[$tableel]['rowspans'][$k]['endpage'] = max($dom[$tableel]['rowspans'][$k]['endpage'],
                            $dom[($dom[$key]['parent'])]['endpage']);
                            $dom[($dom[$key]['parent'])]['endpage'] = $dom[$tableel]['rowspans'][$k]['endpage'];
                            $dom[$tableel]['rowspans'][$k]['endcolumn'] = max($dom[$tableel]['rowspans'][$k]['endcolumn'],
                            $dom[($dom[$key]['parent'])]['endcolumn']);
                            $dom[($dom[$key]['parent'])]['endcolumn'] = $dom[$tableel]['rowspans'][$k]['endcolumn'];
                            $dom[$tableel]['rowspans'][$k]['endy'] = max($dom[$tableel]['rowspans'][$k]['endy'],
                            $dom[($dom[$key]['parent'])]['endy']);
                            $dom[($dom[$key]['parent'])]['endy'] = $dom[$tableel]['rowspans'][$k]['endy'];
                        }
                    }
                    // Update remaining rowspanned cells.
                    foreach ($dom[$tableel]['rowspans'] as $k => $trwsp) {
                        if ($dom[$tableel]['rowspans'][$k]['rowspan'] == 0) {
                            $dom[$tableel]['rowspans'][$k]['endpage'] = $dom[($dom[$key]['parent'])]['endpage'];
                            $dom[$tableel]['rowspans'][$k]['endcolumn'] = $dom[($dom[$key]['parent'])]['endcolumn'];
                            $dom[$tableel]['rowspans'][$k]['endy'] = $dom[($dom[$key]['parent'])]['endy'];
                        }
                    }
                }
                $this->setpage($dom[($dom[$key]['parent'])]['endpage']);
                if ($this->numcolumns > 1) {
                    $this->selectcolumn($dom[($dom[$key]['parent'])]['endcolumn']);
                }
                $this->y = $dom[($dom[$key]['parent'])]['endy'];
                if (isset($dom[$tableel]['attribute']['cellspacing'])) {
                    $this->y += $this->gethtmlunittounits($dom[$tableel]['attribute']['cellspacing'], 1, 'px');
                } else if (isset($dom[$tableel]['border-spacing'])) {
                    $this->y += $dom[$tableel]['border-spacing']['V'];
                }
                $this->ln(0, $cell);
                if ($this->currentcolumn == $parent['startcolumn']) {
                    $this->x = $parent['startx'];
                }
                // Account for booklet mode.
                if ($this->page > $parent['startpage']) {
                    if (($this->rtl) AND ($this->pagedim[$this->page]['orm'] !=
                         $this->pagedim[$parent['startpage']]['orm'])) {
                         $this->x -= ($this->pagedim[$this->page]['orm'] -
                         $this->pagedim[$parent['startpage']]['orm']);
                    } else if ((!$this->rtl) AND ($this->pagedim[$this->page]['olm'] !=
                                 $this->pagedim[$parent['startpage']]['olm'])) {
                        $this->x += ($this->pagedim[$this->page]['olm'] - $this->pagedim[$parent['startpage']]['olm']);
                    }
                }
                break;
            }
            case 'tablehead':
                // Closing tag used for the thead part.
                $intablehead = true;
                $this->inthead = false;
                case 'table': {
                    $tableel = $parent;
                    // Set default border.
                    if (isset($tableel['attribute']['border']) AND ($tableel['attribute']['border'] > 0)) {
                        // Set default border.
                        $border = array('LTRB' => array('width' => $this->getcssborderwidth($tableel['attribute']['border']),
                                                        'cap' => 'square', 'join' => 'miter', 'dash' => 0,
                                                        'color' => array(0, 0, 0)));
                    } else {
                        $border = 0;
                    }
                    $defaultborder = $border;
                    // Fix bottom line alignment of last line before page break.
                    foreach ($dom[($dom[$key]['parent'])]['trids'] as $j => $trkey) {
                        // Update row-spanned cells.
                        if (isset($dom[($dom[$key]['parent'])]['rowspans'])) {
                            foreach ($dom[($dom[$key]['parent'])]['rowspans'] as $k => $trwsp) {
                                if ($trwsp['trid'] == $trkey) {
                                    $dom[($dom[$key]['parent'])]['rowspans'][$k]['mrowspan'] -= 1;
                                }
                                if (isset($prevtrkey) AND ($trwsp['trid'] == $prevtrkey) AND ($trwsp['mrowspan'] >= 0)) {
                                    $dom[($dom[$key]['parent'])]['rowspans'][$k]['trid'] = $trkey;
                                }
                            }
                        }
                        if (isset($prevtrkey) AND ($dom[$trkey]['startpage'] > $dom[$prevtrkey]['endpage'])) {
                            $pgendy = $this->pagedim[$dom[$prevtrkey]['endpage']]['hk'] -
                                      $this->pagedim[$dom[$prevtrkey]['endpage']]['bm'];
                            $dom[$prevtrkey]['endy'] = $pgendy;
                            // Update row-spanned cells.
                            if (isset($dom[($dom[$key]['parent'])]['rowspans'])) {
                                foreach ($dom[($dom[$key]['parent'])]['rowspans'] as $k => $trwsp) {
                                    if (($trwsp['trid'] == $trkey) AND ($trwsp['mrowspan'] > 1) AND ($trwsp['endpage'] ==
                                         $dom[$prevtrkey]['endpage'])) {
                                         $dom[($dom[$key]['parent'])]['rowspans'][$k]['endy'] = $pgendy;
                                         $dom[($dom[$key]['parent'])]['rowspans'][$k]['mrowspan'] = -1;
                                    }
                                }
                            }
                        }
                        $prevtrkey = $trkey;
                        $tableel = $dom[($dom[$key]['parent'])];
                    }
                    // For each row.
                    if (count($tableel['trids']) > 0) {
                        unset($xmax);
                    }
                    foreach ($tableel['trids'] as $j => $trkey) {
                        $parent = $dom[$trkey];
                        if (!isset($xmax)) {
                            $xmax = $parent['cellpos'][(count($parent['cellpos']) - 1)]['endx'];
                        }
                        // For each cell on the row.
                        foreach ($parent['cellpos'] as $k => $cellpos) {
                            if (isset($cellpos['rowspanid']) AND ($cellpos['rowspanid'] >= 0)) {
                                $cellpos['startx'] = $tableel['rowspans'][($cellpos['rowspanid'])]['startx'];
                                $cellpos['endx'] = $tableel['rowspans'][($cellpos['rowspanid'])]['endx'];
                                $endy = $tableel['rowspans'][($cellpos['rowspanid'])]['endy'];
                                $startpage = $tableel['rowspans'][($cellpos['rowspanid'])]['startpage'];
                                $endpage = $tableel['rowspans'][($cellpos['rowspanid'])]['endpage'];
                                $startcolumn = $tableel['rowspans'][($cellpos['rowspanid'])]['startcolumn'];
                                $endcolumn = $tableel['rowspans'][($cellpos['rowspanid'])]['endcolumn'];
                            } else {
                                $endy = $parent['endy'];
                                $startpage = $parent['startpage'];
                                $endpage = $parent['endpage'];
                                $startcolumn = $parent['startcolumn'];
                                $endcolumn = $parent['endcolumn'];
                            }
                            if ($this->numcolumns == 0) {
                                $this->numcolumns = 1;
                            }
                            if (isset($cellpos['border'])) {
                                $border = $cellpos['border'];
                            }
                            if (isset($cellpos['bgcolor']) AND ($cellpos['bgcolor']) !== false) {
                                $this->setfillcolorarray($cellpos['bgcolor']);
                                $fill = true;
                            } else {
                                $fill = false;
                            }
                            $x = $cellpos['startx'];
                            $y = $parent['starty'];
                            $starty = $y;
                            $w = abs($cellpos['endx'] - $cellpos['startx']);
                            // Get border modes.
                            $borderstart = $this->getbordermode($border, $position = 'start');
                            $borderend = $this->getbordermode($border, $position = 'end');
                            $bordermiddle = $this->getbordermode($border, $position = 'middle');
                            // Design borders around HTML cells.
                            for ($page = $startpage; $page <= $endpage; ++$page) { // For each page.
                                $ccode = '';
                                $this->setpage($page);
                                if ($this->numcolumns < 2) {
                                    // Single-column mode.
                                    $this->x = $x;
                                    $this->y = $this->tmargin;
                                }
                                // Account for margin changes.
                                if ($page > $startpage) {
                                    if (($this->rtl) AND ($this->pagedim[$page]['orm'] !=
                                         $this->pagedim[$startpage]['orm'])) {
                                         $this->x -= ($this->pagedim[$page]['orm'] -
                                                      $this->pagedim[$startpage]['orm']);
                                    } else if ((!$this->rtl) AND ($this->pagedim[$page]['olm'] !=
                                                 $this->pagedim[$startpage]['olm'])) {
                                        $this->x += ($this->pagedim[$page]['olm'] - $this->pagedim[$startpage]['olm']);
                                    }
                                }
                                if ($startpage == $endpage) { // Single page.
                                    $deltacol = 0;
                                    $deltath = 0;
                                    for ($column = $startcolumn; $column <= $endcolumn; ++$column) { // For each column.
                                         $this->selectcolumn($column);
                                        if ($startcolumn == $endcolumn) { // Single column.
                                            $cborder = $border;
                                            $h = $endy - $parent['starty'];
                                            $this->y = $y;
                                            $this->x = $x;
                                        } else if ($column == $startcolumn) { // First column.
                                            $cborder = $borderstart;
                                            $this->y = $starty;
                                            $this->x = $x;
                                            $h = $this->h - $this->y - $this->bmargin;
                                            if ($this->rtl) {
                                                $deltacol = $this->x + $this->rmargin - $this->w;
                                            } else {
                                                $deltacol = $this->x - $this->lmargin;
                                            }
                                        } else if ($column == $endcolumn) { // End column.
                                            $cborder = $borderend;
                                            if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
                                                      $this->y = $this->columns[$column]['th']['\''.$page.'\''];
                                            }
                                            $this->x += $deltacol;
                                            $h = $endy - $this->y;
                                        } else { // Middle column.
                                            $cborder = $bordermiddle;
                                            if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
                                                      $this->y = $this->columns[$column]['th']['\''.$page.'\''];
                                            }
                                            $this->x += $deltacol;
                                            $h = $this->h - $this->y - $this->bmargin;
                                        }
                                            $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                                    } // End for each column.
                                } else if ($page == $startpage) { // First page.
                                    $deltacol = 0;
                                    $deltath = 0;
                                    for ($column = $startcolumn; $column < $this->numcolumns; ++$column) { // For each column.
                                        $this->selectcolumn($column);
                                        if ($column == $startcolumn) { // First column.
                                            $cborder = $borderstart;
                                            $this->y = $starty;
                                            $this->x = $x;
                                            $h = $this->h - $this->y - $this->bmargin;
                                            if ($this->rtl) {
                                                $deltacol = $this->x + $this->rmargin - $this->w;
                                            } else {
                                                $deltacol = $this->x - $this->lmargin;
                                            }
                                        } else { // Middle column.
                                            $cborder = $bordermiddle;
                                            if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
                                                $this->y = $this->columns[$column]['th']['\''.$page.'\''];
                                            }
                                            $this->x += $deltacol;
                                            $h = $this->h - $this->y - $this->bmargin;
                                        }
                                        $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                                    } // End for each column.
                                } else if ($page == $endpage) { // Last page.
                                    $deltacol = 0;
                                    $deltath = 0;
                                    for ($column = 0; $column <= $endcolumn; ++$column) { // For each column.
                                        $this->selectcolumn($column);
                                        if ($column == $endcolumn) { // End column.
                                            $cborder = $borderend;
                                            if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
                                                $this->y = $this->columns[$column]['th']['\''.$page.'\''];
                                            }
                                            $this->x += $deltacol;
                                            $h = $endy - $this->y;
                                        } else { // Middle column.
                                            $cborder = $bordermiddle;
                                            if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
                                                $this->y = $this->columns[$column]['th']['\''.$page.'\''];
                                            }
                                            $this->x += $deltacol;
                                            $h = $this->h - $this->y - $this->bmargin;
                                        }
                                        $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                                    } // End for each column.
                                } else { // Middle page.
                                    $deltacol = 0;
                                    $deltath = 0;
                                    for ($column = 0; $column < $this->numcolumns; ++$column) { // For each column.
                                        $this->selectcolumn($column);
                                        $cborder = $bordermiddle;
                                        if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
                                            $this->y = $this->columns[$column]['th']['\''.$page.'\''];
                                        }
                                        $this->x += $deltacol;
                                        $h = $this->h - $this->y - $this->bmargin;
                                        $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                                    } // End for each column.
                                }
                                if ($cborder OR $fill) {
                                    $offsetlen = strlen($ccode);
                                    // Draw border and fill.
                                    if ($this->inxobj) {
                                        // We are inside an XObject template.
                                        if (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {
                                            $pagemarkkey = key($this->xobjects[$this->xobjid]['transfmrk']);
                                            $pagemark = $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey];
                                            $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey] += $offsetlen;
                                        } else {
                                            $pagemark = $this->xobjects[$this->xobjid]['intmrk'];
                                            $this->xobjects[$this->xobjid]['intmrk'] += $offsetlen;
                                        }
                                        $pagebuff = $this->xobjects[$this->xobjid]['outdata'];
                                        $pstart = substr($pagebuff, 0, $pagemark);
                                        $pend = substr($pagebuff, $pagemark);
                                        $this->xobjects[$this->xobjid]['outdata'] = $pstart.$ccode.$pend;
                                    } else {
                                        // Draw border and fill.
                                        if (end($this->transfmrk[$this->page]) !== false) {
                                            $pagemarkkey = key($this->transfmrk[$this->page]);
                                            $pagemark = $this->transfmrk[$this->page][$pagemarkkey];
                                            $this->transfmrk[$this->page][$pagemarkkey] += $offsetlen;
                                        } else if ($this->infooter) {
                                            $pagemark = $this->footerpos[$this->page];
                                            $this->footerpos[$this->page] += $offsetlen;
                                        } else {
                                            $pagemark = $this->intmrk[$this->page];
                                            $this->intmrk[$this->page] += $offsetlen;
                                        }
                                        $pagebuff = $this->getpagebuffer($this->page);
                                        $pstart = substr($pagebuff, 0, $pagemark);
                                        $pend = substr($pagebuff, $pagemark);
                                        $this->setpagebuffer($this->page, $pstart.$ccode.$pend);
                                    }
                                }
                            } // End for each page.
                            // Restore default border.
                            $border = $defaultborder;
                        } // End for each cell on the row.
                        if (isset($tableel['attribute']['cellspacing'])) {
                            $this->y += $this->gethtmlunittounits($tableel['attribute']['cellspacing'], 1, 'px');
                        } else if (isset($tableel['border-spacing'])) {
                            $this->y += $tableel['border-spacing']['V'];
                        }
                        $this->ln(0, $cell);
                        $this->x = $parent['startx'];
                        if ($endpage > $startpage) {
                            if (($this->rtl) AND ($this->pagedim[$endpage]['orm'] != $this->pagedim[$startpage]['orm'])) {
                                $this->x += ($this->pagedim[$endpage]['orm'] - $this->pagedim[$startpage]['orm']);
                            } else if ((!$this->rtl) AND ($this->pagedim[$endpage]['olm'] !=
                                         $this->pagedim[$startpage]['olm'])) {
                                $this->x += ($this->pagedim[$endpage]['olm'] - $this->pagedim[$startpage]['olm']);
                            }
                        }
                    }
                    if (!$intablehead) { // We are not inside a thead section.
                        $this->cellpadding = $tableel['oldcellpadding'];
                        // Reset row height.
                        $this->resetlasth();
                        if (($this->page == ($this->numpages - 1)) AND ($this->pageopen[$this->numpages])) {
                            $plendiff = ($this->pagelen[$this->numpages] - $this->emptypagemrk[$this->numpages]);
                            if (($plendiff > 0) AND ($plendiff < 60)) {
                                $pagediff = substr($this->getpagebuffer($this->numpages), $this->emptypagemrk[$this->numpages],
                                                   $plendiff);
                                if (substr($pagediff, 0, 5) == 'BT /F') {
                                    // The difference is only a font setting.
                                    $plendiff = 0;
                                }
                            }
                            if ($plendiff == 0) {
                                // Remove last blank page.
                                $this->deletepage($this->numpages);
                            }
                        }
                        if (isset($this->theadmargins['top'])) {
                            // Restore top margin.
                            $this->tmargin = $this->theadmargins['top'];
                        }
                        if (!isset($tableel['attribute']['nested']) OR ($tableel['attribute']['nested'] != 'true')) {
                            // Reset main table header.
                            $this->thead = '';
                            $this->theadmargins = array();
                            $this->pagedim[$this->page]['tm'] = $this->tmargin;
                        }
                    }
                    $parent = $tableel;
                    break;
                }
                case 'a': {
                    $this->href = '';
                    break;
                }
                case 'sup': {
                    $this->setxy($this->getx(), $this->gety() + ((0.7 * $parent['fontsize']) / $this->k));
                    break;
                }
                case 'sub': {
                    $this->setxy($this->getx(), $this->gety() - ((0.3 * $parent['fontsize']) / $this->k));
                    break;
                }
                case 'div': {
                    $this->addhtmlvertspace($hbz, $hb, $cell, false, $lasttag);
                    break;
                }
                case 'blockquote': {
                    if ($this->rtl) {
                        $this->rmargin -= $this->listindent;
                    } else {
                        $this->lmargin -= $this->listindent;
                    }
                    --$this->listindentlevel;
                    $this->addhtmlvertspace($hbz, $hb, $cell, false, $lasttag);
                    break;
                }
                case 'p': {
                    $this->addhtmlvertspace($hbz, $hb, $cell, false, $lasttag);
                    break;
                }
                case 'pre': {
                    $this->addhtmlvertspace($hbz, $hb, $cell, false, $lasttag);
                    $this->premode = false;
                    break;
                }
                case 'dl': {
                    --$this->listnum;
                    if ($this->listnum <= 0) {
                        $this->listnum = 0;
                        $this->addhtmlvertspace($hbz, $hb, $cell, false, $lasttag);
                    } else {
                        $this->addhtmlvertspace(0, 0, $cell, false, $lasttag);
                    }
                    $this->resetlasth();
                    break;
                }
                case 'dt': {
                    $this->lispacer = '';
                    $this->addhtmlvertspace(0, 0, $cell, false, $lasttag);
                    break;
                }
                case 'dd': {
                    $this->lispacer = '';
                    if ($this->rtl) {
                        $this->rmargin -= $this->listindent;
                    } else {
                        $this->lmargin -= $this->listindent;
                    }
                    --$this->listindentlevel;
                    $this->addhtmlvertspace(0, 0, $cell, false, $lasttag);
                    break;
                }
                case 'ul':
                case 'ol': {
                    --$this->listnum;
                    $this->lispacer = '';
                    if ($this->rtl) {
                        $this->rmargin -= $this->listindent;
                    } else {
                        $this->lmargin -= $this->listindent;
                    }
                    --$this->listindentlevel;
                    if ($this->listnum <= 0) {
                        $this->listnum = 0;
                        $this->addhtmlvertspace($hbz, $hb, $cell, false, $lasttag);
                    } else {
                        $this->addhtmlvertspace(0, 0, $cell, false, $lasttag);
                    }
                    $this->resetlasth();
                    break;
                }
                case 'li': {
                    $this->lispacer = '';
                    $this->addhtmlvertspace(0, 0, $cell, false, $lasttag);
                    break;
                }
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6': {
                    $this->addhtmlvertspace($hbz, $hb, $cell, false, $lasttag);
                    break;
                }
                case 'form': {
                    $this->formaction = '';
                    $this->formenctype = 'application/x-www-form-urlencoded';
                    break;
                }
                default : {
                    break;
                }
        }
        // Draw border and background (if any).
        $this->drawhtmltagborder($parent, $xmax);
        if (isset($dom[($dom[$key]['parent'])]['attribute']['pagebreakafter'])) {
            $pba = $dom[($dom[$key]['parent'])]['attribute']['pagebreakafter'];
            // Check for pagebreak.
            if (($pba == 'true') OR ($pba == 'left') OR ($pba == 'right')) {
                // Add a page (or trig acceptpagebreak() for multicolumn mode).
                $this->checkpagebreak($this->pagebreaktrigger + 1);
            }
            if ((($pba == 'left') AND (((!$this->rtl) AND (($this->page % 2) == 0)) OR
               (($this->rtl) AND (($this->page % 2) != 0))))
                OR (($pba == 'right') AND (((!$this->rtl) AND (($this->page % 2) != 0)) OR
                   (($this->rtl) AND (($this->page % 2) == 0))))) {
                // Add a page (or trig acceptpagebreak() for multicolumn mode).
                $this->checkpagebreak($this->pagebreaktrigger + 1);
            }
        }
        $this->tmprtl = false;
        return $dom;
    }

    /**
     * Add vertical spaces if needed.
     */
    protected function addhtmlvertspace($hbz = 0, $hb = 0, $cell = false, $firsttag = false, $lasttag = false) {
        if ($firsttag) {
            $this->ln(0, $cell);
            $this->htmlvspace = 0;
            return;
        }
        if ($lasttag) {
            $this->ln($hbz, $cell);
            $this->htmlvspace = 0;
            return;
        }
        if ($hb < $this->htmlvspace) {
            $hd = 0;
        } else {
            $hd = $hb - $this->htmlvspace;
            $this->htmlvspace = $hb;
        }
        $this->ln(($hbz + $hd), $cell);
    }

    /**
     * Return the starting coordinates to draw an html border
     */
    protected function getborderstartposition() {
        if ($this->rtl) {
            $xmax = $this->lmargin;
        } else {
            $xmax = $this->w - $this->rmargin;
        }
        return array('page' => $this->page, 'column' => $this->currentcolumn, 'x' => $this->x, 'y' => $this->y,
                     'xmax' => $xmax);
    }

    /**
     * Draw an HTML block border and fill
     */
    protected function drawhtmltagborder($tag, $xmax) {
        if (!isset($tag['borderposition'])) {
            // Nothing to draw.
            return;
        }
        $prevx = $this->x;
        $prevy = $this->y;
        $prevlasth = $this->lasth;
        $border = 0;
        $fill = false;
        $this->lasth = 0;
        if (isset($tag['border']) AND !empty($tag['border'])) {
            // Get border style.
            $border = $tag['border'];
            if (!$this->empty_string($this->thead) AND (!$this->inthead)) {
                // Border for table header.
                $border = $this->getbordermode($border, $position = 'middle');
            }
        }
        if (isset($tag['bgcolor']) AND ($tag['bgcolor'] !== false)) {
            // Get background color.
            $oldbgcolor = $this->bgcolor;
            $this->setfillcolorarray($tag['bgcolor']);
            $fill = true;
        }
        if (!$border AND !$fill) {
            // Nothing to draw.
            return;
        }
        if (isset($tag['attribute']['cellspacing'])) {
            $clsp = $this->gethtmlunittounits($tag['attribute']['cellspacing'], 1, 'px');
            $cellspacing = array('H' => $clsp, 'V' => $clsp);
        } else if (isset($tag['border-spacing'])) {
            $cellspacing = $tag['border-spacing'];
        } else {
            $cellspacing = array('H' => 0, 'V' => 0);
        }
        if (($tag['value'] != 'table') AND (is_array($border)) AND (!empty($border))) {
            // Draw the border externally respect the sqare edge.
            $border['mode'] = 'ext';
        }
        if ($this->rtl) {
            if ($xmax >= $tag['borderposition']['x']) {
                $xmax = $tag['borderposition']['xmax'];
            }
            $w = ($tag['borderposition']['x'] - $xmax);
        } else {
            if ($xmax <= $tag['borderposition']['x']) {
                $xmax = $tag['borderposition']['xmax'];
            }
            $w = ($xmax - $tag['borderposition']['x']);
        }
        if ($w <= 0) {
            return;
        }
        $w += $cellspacing['H'];
        $startpage = $tag['borderposition']['page'];
        $startcolumn = $tag['borderposition']['column'];
        $x = $tag['borderposition']['x'];
        $y = $tag['borderposition']['y'];
        $endpage = $this->page;
        $starty = $tag['borderposition']['y'] - $cellspacing['V'];
        $currenty = $this->y;
        $this->x = $x;
        // Get latest column.
        $endcolumn = $this->currentcolumn;
        if ($this->numcolumns == 0) {
            $this->numcolumns = 1;
        }
        // Get border modes.
        $borderstart = $this->getbordermode($border, $position = 'start');
        $borderend = $this->getbordermode($border, $position = 'end');
        $bordermiddle = $this->getbordermode($border, $position = 'middle');
        // Temporary disable page regions.
        $temppageregions = $this->pageregions;
        $this->pageregions = array();
        // Design borders around HTML cells.
        for ($page = $startpage; $page <= $endpage; ++$page) { // For each page.
            $ccode = '';
            $this->setpage($page);
            if ($this->numcolumns < 2) {
                // Single-column mode.
                $this->x = $x;
                $this->y = $this->tmargin;
            }
            // Account for margin changes.
            if ($page > $startpage) {
                if (($this->rtl) AND ($this->pagedim[$page]['orm'] != $this->pagedim[$startpage]['orm'])) {
                    $this->x -= ($this->pagedim[$page]['orm'] - $this->pagedim[$startpage]['orm']);
                } else if ((!$this->rtl) AND ($this->pagedim[$page]['olm'] != $this->pagedim[$startpage]['olm'])) {
                    $this->x += ($this->pagedim[$page]['olm'] - $this->pagedim[$startpage]['olm']);
                }
            }
            if ($startpage == $endpage) {
                // Single page.
                for ($column = $startcolumn; $column <= $endcolumn; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    if ($startcolumn == $endcolumn) { // Single column.
                        $cborder = $border;
                        $h = ($currenty - $y) + $cellspacing['V'];
                        $this->y = $starty;
                    } else if ($column == $startcolumn) { // First column.
                        $cborder = $borderstart;
                        $this->y = $starty;
                        $h = $this->h - $this->y - $this->bmargin;
                    } else if ($column == $endcolumn) { // End column.
                        $cborder = $borderend;
                        $h = $currenty - $this->y;
                    } else { // Middle column.
                        $cborder = $bordermiddle;
                        $h = $this->h - $this->y - $this->bmargin;
                    }
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            } else if ($page == $startpage) { // First page.
                for ($column = $startcolumn; $column < $this->numcolumns; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    if ($column == $startcolumn) { // First column.
                        $cborder = $borderstart;
                        $this->y = $starty;
                        $h = $this->h - $this->y - $this->bmargin;
                    } else { // Middle column.
                        $cborder = $bordermiddle;
                        $h = $this->h - $this->y - $this->bmargin;
                    }
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            } else if ($page == $endpage) { // Last page.
                for ($column = 0; $column <= $endcolumn; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    if ($column == $endcolumn) {
                        // End column.
                        $cborder = $borderend;
                        $h = $currenty - $this->y;
                    } else {
                        // Middle column.
                        $cborder = $bordermiddle;
                        $h = $this->h - $this->y - $this->bmargin;
                    }
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            } else { // Middle page.
                for ($column = 0; $column < $this->numcolumns; ++$column) { // For each column.
                    $this->selectcolumn($column);
                    $cborder = $bordermiddle;
                    $h = $this->h - $this->y - $this->bmargin;
                    $ccode .= $this->getcellcode($w, $h, '', $cborder, 1, '', $fill, '', 0, true)."\n";
                } // End for each column.
            }
            if ($cborder OR $fill) {
                $offsetlen = strlen($ccode);
                // Draw border and fill.
                if ($this->inxobj) {
                    // We are inside an XObject template.
                    if (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {
                        $pagemarkkey = key($this->xobjects[$this->xobjid]['transfmrk']);
                        $pagemark = $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey];
                        $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey] += $offsetlen;
                    } else {
                        $pagemark = $this->xobjects[$this->xobjid]['intmrk'];
                        $this->xobjects[$this->xobjid]['intmrk'] += $offsetlen;
                    }
                    $pagebuff = $this->xobjects[$this->xobjid]['outdata'];
                    $pstart = substr($pagebuff, 0, $pagemark);
                    $pend = substr($pagebuff, $pagemark);
                    $this->xobjects[$this->xobjid]['outdata'] = $pstart.$ccode.$pend;
                } else {
                    if (end($this->transfmrk[$this->page]) !== false) {
                        $pagemarkkey = key($this->transfmrk[$this->page]);
                        $pagemark = $this->transfmrk[$this->page][$pagemarkkey];
                        $this->transfmrk[$this->page][$pagemarkkey] += $offsetlen;
                    } else if ($this->infooter) {
                        $pagemark = $this->footerpos[$this->page];
                        $this->footerpos[$this->page] += $offsetlen;
                    } else {
                        $pagemark = $this->intmrk[$this->page];
                        $this->intmrk[$this->page] += $offsetlen;
                    }
                    $pagebuff = $this->getpagebuffer($this->page);
                    $pstart = substr($pagebuff, 0, $this->bordermrk[$this->page]);
                    $pend = substr($pagebuff, $this->bordermrk[$this->page]);
                    $this->setpagebuffer($this->page, $pstart.$ccode.$pend);
                    $this->bordermrk[$this->page] += $offsetlen;
                    $this->cntmrk[$this->page] += $offsetlen;
                }
            }
        } // End for each page.
        // Restore page regions.
        $this->pageregions = $temppageregions;
        if (isset($oldbgcolor)) {
            // Restore background color.
            $this->setfillcolorarray($oldbgcolor);
        }
        // Restore pointer position.
        $this->x = $prevx;
        $this->y = $prevy;
        $this->lasth = $prevlasth;
    }

    /**
     * Set the default bullet to be used as LI bullet symbol
     */
    public function setlisymbol($symbol = '!') {
        // Check for custom image symbol.
        if (substr($symbol, 0, 4) == 'img|') {
            $this->lisymbol = $symbol;
            return;
        }
        $symbol = strtolower($symbol);
        switch ($symbol) {
            case '!' :
            case '#' :
            case 'disc' :
            case 'circle' :
            case 'square' :
            case '1':
            case 'decimal':
            case 'decimal-leading-zero':
            case 'i':
            case 'lower-roman':
            case 'I':
            case 'upper-roman':
            case 'a':
            case 'lower-alpha':
            case 'lower-latin':
            case 'A':
            case 'upper-alpha':
            case 'upper-latin':
            case 'lower-greek': {
                $this->lisymbol = $symbol;
                break;
            }
            default : {
                $this->lisymbol = '';
            }
        }
    }

    /**
     * Set the booklet mode for double-sided pages.
     */
    public function setbooklet($booklet = true, $inner = -1, $outer = -1) {
        $this->booklet = $booklet;
        if ($inner >= 0) {
            $this->lmargin = $inner;
        }
        if ($outer >= 0) {
            $this->rmargin = $outer;
        }
    }

    /**
     * Swap the left and right margins.
     */
    protected function swapmargins($reverse = true) {
        if ($reverse) {
            // Swap left and right margins.
            $mtemp = $this->originallmargin;
            $this->originallmargin = $this->originalrmargin;
            $this->originalrmargin = $mtemp;
            $deltam = $this->originallmargin - $this->originalrmargin;
            $this->lmargin += $deltam;
            $this->rmargin -= $deltam;
        }
    }

    /**
     * Set the vertical spaces for HTML tags.
     */
    public function sethtmlvspace($tagvs) {
        $this->tagvspaces = $tagvs;
    }

    /**
     * Set custom width for list indentation.
     */
    public function setlistindentwidth($width) {
        return $this->customlistindent = floatval($width);
    }

    /**
     * Set the top/bottom cell sides to be open or closed when the cell cross the page.
     */
    public function setopencell($isopen) {
        $this->opencell = $isopen;
    }

    /**
     * Set the color and font style for HTML links.
     */
    public function sethtmllinksstyle($color = array(0, 0, 255), $fontstyle = 'U') {
        $this->htmllinkcolorarray = $color;
        $this->htmllinkfontstyle = $fontstyle;
    }

    /**
     * Convert HTML string containing value and unit of measure to user's units or points.
     */
    public function gethtmlunittounits($htmlval, $refsize = 1, $defaultunit = 'px', $points = false) {
        $supportedunits = array('%', 'em', 'ex', 'px', 'in', 'cm', 'mm', 'pc', 'pt');
        $retval = 0;
        $value = 0;
        $unit = 'px';
        $k = $this->k;
        if ($points) {
            $k = 1;
        }
        if (in_array($defaultunit, $supportedunits)) {
            $unit = $defaultunit;
        }
        if (is_numeric($htmlval)) {
            $value = floatval($htmlval);
        } else if (preg_match('/([0-9\.\-\+]+)/', $htmlval, $mnum)) {
            $value = floatval($mnum[1]);
            if (preg_match('/([a-z%]+)/', $htmlval, $munit)) {
                if (in_array($munit[1], $supportedunits)) {
                    $unit = $munit[1];
                }
            }
        }
        switch ($unit) {
            // Percentage.
            case '%': {
                $retval = (($value * $refsize) / 100);
                break;
            }
            // Relative-size.
            case 'em': {
                $retval = ($value * $refsize);
                break;
            }
            // Height of lower case 'x' (about half the font-size).
            case 'ex': {
                $retval = $value * ($refsize / 2);
                break;
            }
            // Absolute-size.
            case 'in': {
                $retval = ($value * $this->dpi) / $k;
                break;
            }
            // Centimeters.
            case 'cm': {
                $retval = ($value / 2.54 * $this->dpi) / $k;
                break;
            }
            // Millimeters.
            case 'mm': {
                $retval = ($value / 25.4 * $this->dpi) / $k;
                break;
            }
            // One pica is 12 points.
            case 'pc': {
                $retval = ($value * 12) / $k;
                break;
            }
            // Points.
            case 'pt': {
                $retval = $value / $k;
                break;
            }
            // Pixels.
            case 'px': {
                $retval = $this->pixelstounits($value);
                break;
            }
        }
        return $retval;
    }

    /**
     * Returns the Roman representation of an integer number
     */
    public function inttoroman($number) {
        $roman = '';
        while ($number >= 1000) {
            $roman .= 'M';
            $number -= 1000;
        }
        while ($number >= 900) {
            $roman .= 'CM';
            $number -= 900;
        }
        while ($number >= 500) {
            $roman .= 'D';
            $number -= 500;
        }
        while ($number >= 400) {
            $roman .= 'CD';
            $number -= 400;
        }
        while ($number >= 100) {
            $roman .= 'C';
            $number -= 100;
        }
        while ($number >= 90) {
            $roman .= 'XC';
            $number -= 90;
        }
        while ($number >= 50) {
            $roman .= 'L';
            $number -= 50;
        }
        while ($number >= 40) {
            $roman .= 'XL';
            $number -= 40;
        }
        while ($number >= 10) {
            $roman .= 'X';
            $number -= 10;
        }
        while ($number >= 9) {
            $roman .= 'IX';
            $number -= 9;
        }
        while ($number >= 5) {
            $roman .= 'V';
            $number -= 5;
        }
        while ($number >= 4) {
            $roman .= 'IV';
            $number -= 4;
        }
        while ($number >= 1) {
            $roman .= 'I';
            --$number;
        }
        return $roman;
    }

    /**
     * output an HTML list bullet or ordered item symbol
     */
    protected function puthtmllistbullet($listdepth, $listtype = '', $size = 10) {
        $size /= $this->k;
        $fill = '';
        $bgcolor = $this->bgcolor;
        $color = $this->fgcolor;
        $strokecolor = $this->strokecolor;
        $width = 0;
        $textitem = '';
        $tmpx = $this->x;
        $lspace = $this->getstringwidth('  ');
        if ($listtype == '^') {
            // Special symbol used for avoid justification of rect bullet.
            $this->lispacer = '';
            return;
        } else if ($listtype == '!') {
            // Set default list type for unordered list.
            $deftypes = array('disc', 'circle', 'square');
            $listtype = $deftypes[($listdepth - 1) % 3];
        } else if ($listtype == '#') {
            // Set default list type for ordered list.
            $listtype = 'decimal';
        } else if (substr($listtype, 0, 4) == 'img|') {
            // Custom image type ('img|type|width|height|image.ext').
            $img = explode('|', $listtype);
            $listtype = 'img';
        }
        switch ($listtype) {
            // Unordered types.
            case 'none': {
                break;
            }
            case 'disc': {
                $r = $size / 6;
                $lspace += (2 * $r);
                if ($this->rtl) {
                    $this->x += $lspace;
                } else {
                    $this->x -= $lspace;
                }
                $this->circle(($this->x + $r), ($this->y + ($this->lasth / 2)), $r, 0, 360, 'F', array(), $color, 8);
                break;
            }
            case 'circle': {
                $r = $size / 6;
                $lspace += (2 * $r);
                if ($this->rtl) {
                    $this->x += $lspace;
                } else {
                    $this->x -= $lspace;
                }
                $prevlinestyle = $this->linestylewidth.' '.$this->linestylecap.' '.$this->linestylejoin.'
                                 '.$this->linestyledash.' '.$this->drawcolor;
                $newlinestyle = array('width' => ($r / 3), 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'phase' => 0,
                                      'color' => $color);
                $this->circle(($this->x + $r), ($this->y + ($this->lasth / 2)), ($r * (1 - (1 / 6))), 0, 360, 'D', $newlinestyle,
                               array(), 8);
                $this->_out($prevlinestyle); // Restore line settings.
                break;
            }
            case 'square': {
                $l = $size / 3;
                $lspace += $l;
                if ($this->rtl) {
                    $this->x += $lspace;
                } else {
                    $this->x -= $lspace;
                }
                $this->rect($this->x, ($this->y + (($this->lasth - $l) / 2)), $l, $l, 'F', array(), $color);
                break;
            }
            case 'img': {
                $lspace += $img[2];
                if ($this->rtl) {
                    $this->x += $lspace;
                } else {
                    $this->x -= $lspace;
                }
                $imgtype = strtolower($img[1]);
                $prevy = $this->y;
                switch ($imgtype) {
                    case 'svg': {
                        $this->imagesvg($img[4], $this->x, ($this->y + (($this->lasth - $img[3]) / 2)), $img[2], $img[3], '',
                                        'T', '', 0, false);
                        break;
                    }
                    case 'ai':
                    case 'eps': {
                        $this->imageeps($img[4], $this->x, ($this->y + (($this->lasth - $img[3]) / 2)), $img[2], $img[3], '',
                                        true, 'T', '', 0, false);
                        break;
                    }
                    default: {
                        $this->imageq($img[4], $this->x, ($this->y + (($this->lasth - $img[3]) / 2)), $img[2], $img[3], $img[1],
                                     '', 'T', false, 300, '', false, false, 0, false, false, false);
                        break;
                    }
                }
                $this->y = $prevy;
                break;
            }
            // Ordered types.
            case '1':
            case 'decimal': {
                $textitem = $this->listcount[$this->listnum];
                break;
            }
            case 'decimal-leading-zero': {
                $textitem = sprintf('%02d', $this->listcount[$this->listnum]);
                break;
            }
            case 'i':
            case 'lower-roman': {
                $textitem = strtolower($this->inttoroman($this->listcount[$this->listnum]));
                break;
            }
            case 'I':
            case 'upper-roman': {
                $textitem = $this->inttoroman($this->listcount[$this->listnum]);
                break;
            }
            case 'a':
            case 'lower-alpha':
            case 'lower-latin': {
                $textitem = chr(97 + $this->listcount[$this->listnum] - 1);
                break;
            }
            case 'A':
            case 'upper-alpha':
            case 'upper-latin': {
                $textitem = chr(65 + $this->listcount[$this->listnum] - 1);
                break;
            }
            case 'lower-greek': {
                $textitem = $this->unichr(945 + $this->listcount[$this->listnum] - 1);
                break;
            }
            default: {
                $textitem = $this->listcount[$this->listnum];
            }
        }
            if (!$this->empty_string($textitem)) {
                // Check whether we need a new page or new column.
                $prevy = $this->y;
                $h = ($this->fontsize * $this->cellheightratio) + $this->cellpadding['T'] + $this->cellpadding['B'];
                if ($this->checkpagebreak($h) OR ($this->y < $prevy)) {
                    $tmpx = $this->x;
                }
                // Print ordered item.
                if ($this->rtl) {
                    $textitem = '.'.$textitem;
                } else {
                    $textitem = $textitem.'.';
                }
                $lspace += $this->getstringwidth($textitem);
                if ($this->rtl) {
                    $this->x += $lspace;
                } else {
                    $this->x -= $lspace;
                }
                $this->write($this->lasth, $textitem, '', false, '', false, 0, false);
            }
            $this->x = $tmpx;
            $this->lispacer = '^';
            // Restore colors.
            $this->setfillcolorarray($bgcolor);
            $this->setdrawcolorarray($strokecolor);
            $this->SettextColorArray($color);
    }

    /**
     * Returns current graphic variables as array.
     */
    protected function getgraphicvars() {
        $grapvars = array(
            'fontfamily' => $this->fontfamily,
            'fontstyle' => $this->fontstyle,
            'fontsizept' => $this->fontsizept,
            'rmargin' => $this->rmargin,
            'lmargin' => $this->lmargin,
            'cellpadding' => $this->cellpadding,
            'cellmargin' => $this->cellmargin,
            'linewidth' => $this->linewidth,
            'linestylewidth' => $this->linestylewidth,
            'linestylecap' => $this->linestylecap,
            'linestylejoin' => $this->linestylejoin,
            'linestyledash' => $this->linestyledash,
            'textrendermode' => $this->textrendermode,
            'textstrokewidth' => $this->textstrokewidth,
            'drawcolor' => $this->drawcolor,
            'fillcolor' => $this->fillcolor,
            'textcolor' => $this->textcolor,
            'colorflag' => $this->colorflag,
            'bgcolor' => $this->bgcolor,
            'fgcolor' => $this->fgcolor,
            'htmlvspace' => $this->htmlvspace,
            'listindent' => $this->listindent,
            'listindentlevel' => $this->listindentlevel,
            'listnum' => $this->listnum,
            'listordered' => $this->listordered,
            'listcount' => $this->listcount,
            'lispacer' => $this->lispacer,
            'cellheightratio' => $this->cellheightratio,
            'fontstretching' => $this->fontstretching,
            'fontspacing' => $this->fontspacing,
            // Extended.
            'lasth' => $this->lasth,
            'tmargin' => $this->tmargin,
            'bmargin' => $this->bmargin,
            'autopagebreak' => $this->autopagebreak,
            'pagebreaktrigger' => $this->pagebreaktrigger,
            'x' => $this->x,
            'y' => $this->y,
            'w' => $this->w,
            'h' => $this->h,
            'wpt' => $this->wpt,
            'hpt' => $this->hpt,
            'fwpt' => $this->fwpt,
            'fhpt' => $this->fhpt,
            'page' => $this->page,
            'currentcolumn' => $this->currentcolumn,
            'numcolumns' => $this->numcolumns
            );
        return $grapvars;
    }

    /**
     * Set graphic variables.
     */
    protected function setgraphicvars($gvars, $extended = false) {
        $this->fontfamily = $gvars['fontfamily'];
        $this->fontstyle = $gvars['fontstyle'];
        $this->fontsizept = $gvars['fontsizept'];
        $this->rmargin = $gvars['rmargin'];
        $this->lmargin = $gvars['lmargin'];
        $this->cellpadding = $gvars['cellpadding'];
        $this->cellmargin = $gvars['cellmargin'];
        $this->linewidth = $gvars['linewidth'];
        $this->linestylewidth = $gvars['linestylewidth'];
        $this->linestylecap = $gvars['linestylecap'];
        $this->linestylejoin = $gvars['linestylejoin'];
        $this->linestyledash = $gvars['linestyledash'];
        $this->textrendermode = $gvars['textrendermode'];
        $this->textstrokewidth = $gvars['textstrokewidth'];
        $this->drawcolor = $gvars['drawcolor'];
        $this->fillcolor = $gvars['fillcolor'];
        $this->textcolor = $gvars['textcolor'];
        $this->colorflag = $gvars['colorflag'];
        $this->bgcolor = $gvars['bgcolor'];
        $this->fgcolor = $gvars['fgcolor'];
        $this->htmlvspace = $gvars['htmlvspace'];
        $this->listindent = $gvars['listindent'];
        $this->listindentlevel = $gvars['listindentlevel'];
        $this->listnum = $gvars['listnum'];
        $this->listordered = $gvars['listordered'];
        $this->listcount = $gvars['listcount'];
        $this->lispacer = $gvars['lispacer'];
        $this->cellheightratio = $gvars['cellheightratio'];
        $this->fontstretching = $gvars['fontstretching'];
        $this->fontspacing = $gvars['fontspacing'];
        if ($extended) {
            // Restore extended values.
            $this->lasth = $gvars['lasth'];
            $this->tmargin = $gvars['tmargin'];
            $this->bmargin = $gvars['bmargin'];
            $this->autopagebreak = $gvars['autopagebreak'];
            $this->pagebreaktrigger = $gvars['pagebreaktrigger'];
            $this->x = $gvars['x'];
            $this->y = $gvars['y'];
            $this->w = $gvars['w'];
            $this->h = $gvars['h'];
            $this->wpt = $gvars['wpt'];
            $this->hpt = $gvars['hpt'];
            $this->fwpt = $gvars['fwpt'];
            $this->fhpt = $gvars['fhpt'];
            $this->page = $gvars['page'];
            $this->currentcolumn = $gvars['currentcolumn'];
            $this->numcolumns = $gvars['numcolumns'];
        }
        $this->_out(''.$this->linestylewidth.' '.$this->linestylecap.' '.$this->linestylejoin.' '.$this->linestyledash.'
                    '.$this->drawcolor.' '.$this->fillcolor.'');
        if (!$this->empty_string($this->fontfamily)) {
            $this->setfont($this->fontfamily, $this->fontstyle, $this->fontsizept);
        }
    }

    /**
     * Returns a temporary filename for caching object on filesystem.
     */
    protected function getobjfilename($name) {
        return tempnam(K_PATH_CACHE, $name.'_');
    }

    /**
     * Writes data to a temporary file on filesystem.
     */
    protected function writediskcache($filename, $data, $append = false) {
        if ($append) {
            $fmode = 'ab+';
        } else {
            $fmode = 'wb+';
        }
        $f = @fopen($filename, $fmode);
        if (!$f) {
            $this->errord('Unable to write cache file: '.$filename);
        } else {
            fwrite($f, $data);
            fclose($f);
        }
        // Update file length (needed for transactions).
        if (!isset($this->cachefilelength['_'.$filename])) {
            $this->cachefilelength['_'.$filename] = strlen($data);
        } else {
            $this->cachefilelength['_'.$filename] += strlen($data);
        }
    }

    /**
     * Read data from a temporary file on filesystem.
     */
    protected function readdiskcache($filename) {
        return file_get_contents($filename);
    }

    /**
     * Set buffer content (always append data).
     */
    protected function setbuffer($data) {
        $this->bufferlen += strlen($data);
        if ($this->diskcache) {
            if (!isset($this->buffer) OR $this->empty_string($this->buffer)) {
                $this->buffer = $this->getobjfilename('buffer');
            }
            $this->writediskcache($this->buffer, $data, true);
        } else {
            $this->buffer .= $data;
        }
    }

    /**
     * Replace the buffer content
     */
    protected function replacebuffer($data) {
        $this->bufferlen = strlen($data);
        if ($this->diskcache) {
            if (!isset($this->buffer) OR $this->empty_string($this->buffer)) {
                $this->buffer = $this->getobjfilename('buffer');
            }
            $this->writediskcache($this->buffer, $data, false);
        } else {
            $this->buffer = $data;
        }
    }

    /**
     * Get buffer content.
     */
    protected function getbuffer() {
        if ($this->diskcache) {
            return $this->readdiskcache($this->buffer);
        } else {
            return $this->buffer;
        }
    }

    /**
     * Set page buffer content.
     */
    protected function setpagebuffer($page, $data, $append = false) {
        if ($this->diskcache) {
            if (!isset($this->pages[$page])) {
                $this->pages[$page] = $this->getobjfilename('page'.$page);
            }
            $this->writediskcache($this->pages[$page], $data, $append);
        } else {
            if ($append) {
                $this->pages[$page] .= $data;
            } else {
                $this->pages[$page] = $data;
            }
        }
        if ($append AND isset($this->pagelen[$page])) {
            $this->pagelen[$page] += strlen($data);
        } else {
            $this->pagelen[$page] = strlen($data);
        }
    }

    /**
     * Get page buffer content.
     */
    protected function getpagebuffer($page) {
        if ($this->diskcache) {
            return $this->readdiskcache($this->pages[$page]);
        } else if (isset($this->pages[$page])) {
            return $this->pages[$page];
        }
        return false;
    }

    /**
     * Set image buffer content.
     */
    protected function setimagebuffer($image, $data) {
        if ($this->diskcache) {
            if (!isset($this->images[$image])) {
                $this->images[$image] = $this->getobjfilename('image'.$image);
            }
            $this->writediskcache($this->images[$image], serialize($data));
        } else {
            $this->images[$image] = $data;
        }
        if (!in_array($image, $this->imagekeys)) {
            $this->imagekeys[] = $image;
            ++$this->numimages;
        }
    }

    /**
     * Set image buffer content for a specified sub-key.
     */
    protected function setimagesubbuffer($image, $key, $data) {
        if (!isset($this->images[$image])) {
            $this->setimagebuffer($image, array());
        }
        if ($this->diskcache) {
            $tmpimg = $this->getimagebuffer($image);
            $tmpimg[$key] = $data;
            $this->writediskcache($this->images[$image], serialize($tmpimg));
        } else {
            $this->images[$image][$key] = $data;
        }
    }

    /**
     * Get image buffer content.
     */
    protected function getimagebuffer($image) {
        if ($this->diskcache AND isset($this->images[$image])) {
            return unserialize($this->readdiskcache($this->images[$image]));
        } else if (isset($this->images[$image])) {
            return $this->images[$image];
        }
        return false;
    }

    /**
     * Set font buffer content.
     */
    protected function setfontbuffer($font, $data) {
        if ($this->diskcache) {
            if (!isset($this->fonts[$font])) {
                $this->fonts[$font] = $this->getobjfilename('font');
            }
            $this->writediskcache($this->fonts[$font], serialize($data));
        } else {
            $this->fonts[$font] = $data;
        }
        if (!in_array($font, $this->fontkeys)) {
            $this->fontkeys[] = $font;
            // Store object ID for current font.
            ++$this->n;
            $this->fontobjids[$font] = $this->n;
            $this->setfontsubbuffer($font, 'n', $this->n);
        }
    }

    /**
     * Set font buffer content.
     */
    protected function setfontsubbuffer($font, $key, $data) {
        if (!isset($this->fonts[$font])) {
            $this->setfontbuffer($font, array());
        }
        if ($this->diskcache) {
            $tmpfont = $this->getfontbuffer($font);
            $tmpfont[$key] = $data;
            $this->writediskcache($this->fonts[$font], serialize($tmpfont));
        } else {
            $this->fonts[$font][$key] = $data;
        }
    }

    /**
     * Get font buffer content.
     */
    protected function getfontbuffer($font) {
        if ($this->diskcache AND isset($this->fonts[$font])) {
            return unserialize($this->readdiskcache($this->fonts[$font]));
        } else if (isset($this->fonts[$font])) {
            return $this->fonts[$font];
        }
        return false;
    }

    /**
     * Move a page to a previous position.
     */
    public function movepage($frompage, $topage) {
        if (($frompage > $this->numpages) OR ($frompage <= $topage)) {
            return false;
        }
        if ($frompage == $this->page) {
            // Close the page before moving it.
            $this->endpage();
        }
        // Move all page-related states.
        $tmppage = $this->getpagebuffer($frompage);
        $tmppagedim = $this->pagedim[$frompage];
        $tmppagelen = $this->pagelen[$frompage];
        $tmpintmrk = $this->intmrk[$frompage];
        $tmpbordermrk = $this->bordermrk[$frompage];
        $tmpcntmrk = $this->cntmrk[$frompage];
        $tmppageobjects = $this->pageobjects[$frompage];
        if (isset($this->footerpos[$frompage])) {
            $tmpfooterpos = $this->footerpos[$frompage];
        }
        if (isset($this->footerlen[$frompage])) {
            $tmpfooterlen = $this->footerlen[$frompage];
        }
        if (isset($this->transfmrk[$frompage])) {
            $tmptransfmrk = $this->transfmrk[$frompage];
        }
        if (isset($this->pageannots[$frompage])) {
            $tmpannots = $this->pageannots[$frompage];
        }
        if (isset($this->newpagegroup) AND !empty($this->newpagegroup)) {
            for ($i = $frompage; $i > $topage; --$i) {
                if (isset($this->newpagegroup[$i]) AND (($i + $this->pagegroups[$this->newpagegroup[$i]]) > $frompage)) {
                    --$this->pagegroups[$this->newpagegroup[$i]];
                    break;
                }
            }
            for ($i = $topage; $i > 0; --$i) {
                if (isset($this->newpagegroup[$i]) AND (($i + $this->pagegroups[$this->newpagegroup[$i]]) > $topage)) {
                    ++$this->pagegroups[$this->newpagegroup[$i]];
                    break;
                }
            }
        }
        for ($i = $frompage; $i > $topage; --$i) {
            $j = $i - 1;
            // Shift pages down.
            $this->setpagebuffer($i, $this->getpagebuffer($j));
            $this->pagedim[$i] = $this->pagedim[$j];
            $this->pagelen[$i] = $this->pagelen[$j];
            $this->intmrk[$i] = $this->intmrk[$j];
            $this->bordermrk[$i] = $this->bordermrk[$j];
            $this->cntmrk[$i] = $this->cntmrk[$j];
            $this->pageobjects[$i] = $this->pageobjects[$j];
            if (isset($this->footerpos[$j])) {
                $this->footerpos[$i] = $this->footerpos[$j];
            } else if (isset($this->footerpos[$i])) {
                unset($this->footerpos[$i]);
            }
            if (isset($this->footerlen[$j])) {
                $this->footerlen[$i] = $this->footerlen[$j];
            } else if (isset($this->footerlen[$i])) {
                unset($this->footerlen[$i]);
            }
            if (isset($this->transfmrk[$j])) {
                $this->transfmrk[$i] = $this->transfmrk[$j];
            } else if (isset($this->transfmrk[$i])) {
                unset($this->transfmrk[$i]);
            }
            if (isset($this->pageannots[$j])) {
                $this->pageannots[$i] = $this->pageannots[$j];
            } else if (isset($this->pageannots[$i])) {
                unset($this->pageannots[$i]);
            }
            if (isset($this->newpagegroup[$j])) {
                $this->newpagegroup[$i] = $this->newpagegroup[$j];
                unset($this->newpagegroup[$j]);
            }
            if ($this->currpagegroup == $j) {
                $this->currpagegroup = $i;
            }
        }
        $this->setpagebuffer($topage, $tmppage);
        $this->pagedim[$topage] = $tmppagedim;
        $this->pagelen[$topage] = $tmppagelen;
        $this->intmrk[$topage] = $tmpintmrk;
        $this->bordermrk[$topage] = $tmpbordermrk;
        $this->cntmrk[$topage] = $tmpcntmrk;
        $this->pageobjects[$topage] = $tmppageobjects;
        if (isset($tmpfooterpos)) {
            $this->footerpos[$topage] = $tmpfooterpos;
        } else if (isset($this->footerpos[$topage])) {
            unset($this->footerpos[$topage]);
        }
        if (isset($tmpfooterlen)) {
            $this->footerlen[$topage] = $tmpfooterlen;
        } else if (isset($this->footerlen[$topage])) {
            unset($this->footerlen[$topage]);
        }
        if (isset($tmptransfmrk)) {
            $this->transfmrk[$topage] = $tmptransfmrk;
        } else if (isset($this->transfmrk[$topage])) {
            unset($this->transfmrk[$topage]);
        }
        if (isset($tmpannots)) {
            $this->pageannots[$topage] = $tmpannots;
        } else if (isset($this->pageannots[$topage])) {
            unset($this->pageannots[$topage]);
        }
        // Adjust outlines.
        $tmpoutlines = $this->outlines;
        foreach ($tmpoutlines as $key => $outline) {
            if (($outline['p'] >= $topage) AND ($outline['p'] < $frompage)) {
                $this->outlines[$key]['p'] = ($outline['p'] + 1);
            } else if ($outline['p'] == $frompage) {
                $this->outlines[$key]['p'] = $topage;
            }
        }
        // Adjust dests.
        $tmpdests = $this->dests;
        foreach ($tmpdests as $key => $dest) {
            if (($dest['p'] >= $topage) AND ($dest['p'] < $frompage)) {
                $this->dests[$key]['p'] = ($dest['p'] + 1);
            } else if ($dest['p'] == $frompage) {
                $this->dests[$key]['p'] = $topage;
            }
        }
        // Adjust links.
        $tmplinks = $this->links;
        foreach ($tmplinks as $key => $link) {
            if (($link[0] >= $topage) AND ($link[0] < $frompage)) {
                $this->links[$key][0] = ($link[0] + 1);
            } else if ($link[0] == $frompage) {
                $this->links[$key][0] = $topage;
            }
        }
        // Adjust javascript.
        $tmpjavascript = $this->javascript;
        global $jfrompage, $jtopage;
        $jfrompage = $frompage;
        $jtopage = $topage;
        $this->javascript = preg_replace_callback('/this\.addField\(\'([^\']*)\',\'([^\']*)\',([0-9]+)/',
            create_function('$matches', 'global $jfrompage, $jtopage;
            $pagenum = intval($matches[3]) + 1;
            if (($pagenum >= $jtopage) AND ($pagenum < $jfrompage)) {
                $newpage = ($pagenum + 1);
            } else if ($pagenum == $jfrompage) {
                $newpage = $jtopage;
            } else {
                $newpage = $pagenum;
            }
            --$newpage;
            return "this.addField(\'".$matches[1]."\',\'".$matches[2]."\',".$newpage."";'), $tmpjavascript);
        // Return to last page.
        $this->lastpage(true);
        return true;
    }

    /**
     * Remove the specified page.
     */
    public function deletepage($page) {
        if (($page < 1) OR ($page > $this->numpages)) {
            return false;
        }
        // Delete current page.
        unset($this->pages[$page]);
        unset($this->pagedim[$page]);
        unset($this->pagelen[$page]);
        unset($this->intmrk[$page]);
        unset($this->bordermrk[$page]);
        unset($this->cntmrk[$page]);
        foreach ($this->pageobjects[$page] as $oid) {
            if (isset($this->offsets[$oid])) {
                unset($this->offsets[$oid]);
            }
        }
        unset($this->pageobjects[$page]);
        if (isset($this->footerpos[$page])) {
            unset($this->footerpos[$page]);
        }
        if (isset($this->footerlen[$page])) {
            unset($this->footerlen[$page]);
        }
        if (isset($this->transfmrk[$page])) {
            unset($this->transfmrk[$page]);
        }
        if (isset($this->pageannots[$page])) {
            unset($this->pageannots[$page]);
        }
        if (isset($this->newpagegroup) AND !empty($this->newpagegroup)) {
            for ($i = $page; $i > 0; --$i) {
                if (isset($this->newpagegroup[$i]) AND (($i + $this->pagegroups[$this->newpagegroup[$i]]) > $page)) {
                    --$this->pagegroups[$this->newpagegroup[$i]];
                    break;
                }
            }
        }
        if (isset($this->pageopen[$page])) {
            unset($this->pageopen[$page]);
        }
        if ($page < $this->numpages) {
            // Update remaining pages.
            for ($i = $page; $i < $this->numpages; ++$i) {
                $j = $i + 1;
                // Shift pages.
                $this->setpagebuffer($i, $this->getpagebuffer($j));
                $this->pagedim[$i] = $this->pagedim[$j];
                $this->pagelen[$i] = $this->pagelen[$j];
                $this->intmrk[$i] = $this->intmrk[$j];
                $this->bordermrk[$i] = $this->bordermrk[$j];
                $this->cntmrk[$i] = $this->cntmrk[$j];
                $this->pageobjects[$i] = $this->pageobjects[$j];
                if (isset($this->footerpos[$j])) {
                    $this->footerpos[$i] = $this->footerpos[$j];
                } else if (isset($this->footerpos[$i])) {
                    unset($this->footerpos[$i]);
                }
                if (isset($this->footerlen[$j])) {
                    $this->footerlen[$i] = $this->footerlen[$j];
                } else if (isset($this->footerlen[$i])) {
                    unset($this->footerlen[$i]);
                }
                if (isset($this->transfmrk[$j])) {
                    $this->transfmrk[$i] = $this->transfmrk[$j];
                } else if (isset($this->transfmrk[$i])) {
                    unset($this->transfmrk[$i]);
                }
                if (isset($this->pageannots[$j])) {
                    $this->pageannots[$i] = $this->pageannots[$j];
                } else if (isset($this->pageannots[$i])) {
                    unset($this->pageannots[$i]);
                }
                if (isset($this->newpagegroup[$j])) {
                    $this->newpagegroup[$i] = $this->newpagegroup[$j];
                    unset($this->newpagegroup[$j]);
                }
                if ($this->currpagegroup == $j) {
                    $this->currpagegroup = $i;
                }
                if (isset($this->pageopen[$j])) {
                    $this->pageopen[$i] = $this->pageopen[$j];
                } else if (isset($this->pageopen[$i])) {
                    unset($this->pageopen[$i]);
                }
            }
            // Remove last page.
            unset($this->pages[$this->numpages]);
            unset($this->pagedim[$this->numpages]);
            unset($this->pagelen[$this->numpages]);
            unset($this->intmrk[$this->numpages]);
            unset($this->bordermrk[$this->numpages]);
            unset($this->cntmrk[$this->numpages]);
            foreach ($this->pageobjects[$this->numpages] as $oid) {
                if (isset($this->offsets[$oid])) {
                    unset($this->offsets[$oid]);
                }
            }
            unset($this->pageobjects[$this->numpages]);
            if (isset($this->footerpos[$this->numpages])) {
                unset($this->footerpos[$this->numpages]);
            }
            if (isset($this->footerlen[$this->numpages])) {
                unset($this->footerlen[$this->numpages]);
            }
            if (isset($this->transfmrk[$this->numpages])) {
                unset($this->transfmrk[$this->numpages]);
            }
            if (isset($this->pageannots[$this->numpages])) {
                unset($this->pageannots[$this->numpages]);
            }
            if (isset($this->newpagegroup[$this->numpages])) {
                unset($this->newpagegroup[$this->numpages]);
            }
            if ($this->currpagegroup == $this->numpages) {
                $this->currpagegroup = ($this->numpages - 1);
            }
            if (isset($this->pagegroups[$this->numpages])) {
                unset($this->pagegroups[$this->numpages]);
            }
            if (isset($this->pageopen[$this->numpages])) {
                unset($this->pageopen[$this->numpages]);
            }
        }
        --$this->numpages;
        $this->page = $this->numpages;
        // Adjust outlines.
        $tmpoutlines = $this->outlines;
        foreach ($tmpoutlines as $key => $outline) {
            if ($outline['p'] > $page) {
                $this->outlines[$key]['p'] = $outline['p'] - 1;
            } else if ($outline['p'] == $page) {
                unset($this->outlines[$key]);
            }
        }
        // Adjust dests.
        $tmpdests = $this->dests;
        foreach ($tmpdests as $key => $dest) {
            if ($dest['p'] > $page) {
                $this->dests[$key]['p'] = $dest['p'] - 1;
            } else if ($dest['p'] == $page) {
                unset($this->dests[$key]);
            }
        }
        // Adjust links.
        $tmplinks = $this->links;
        foreach ($tmplinks as $key => $link) {
            if ($link[0] > $page) {
                $this->links[$key][0] = $link[0] - 1;
            } else if ($link[0] == $page) {
                unset($this->links[$key]);
            }
        }
        // Adjust javascript.
        $tmpjavascript = $this->javascript;
        global $jpage;
        $jpage = $page;
        $this->javascript = preg_replace_callback('/this\.addField\(\'([^\']*)\',\'([^\']*)\',([0-9]+)/',
            create_function('$matches', 'global $jpage;
            $pagenum = intval($matches[3]) + 1;
            if ($pagenum >= $jpage) {
                $newpage = ($pagenum - 1);
            } else if ($pagenum == $jpage) {
                $newpage = 1;
            } else {
                $newpage = $pagenum;
            }
            --$newpage;
            return "this.addField(\'".$matches[1]."\',\'".$matches[2]."\',".$newpage."";'), $tmpjavascript);
        // Return to last page.
        $this->lastpage(true);
        return true;
    }

    /**
     * Clone the specified page to a new page.
     */
    public function copypage($page = 0) {
        if ($page == 0) {
            // Default value.
            $page = $this->page;
        }
        if (($page < 1) OR ($page > $this->numpages)) {
            return false;
        }
        // Close the last page.
        $this->endpage();
        // Copy all page-related states.
        ++$this->numpages;
        $this->page = $this->numpages;
        $this->setpagebuffer($this->page, $this->getpagebuffer($page));
        $this->pagedim[$this->page] = $this->pagedim[$page];
        $this->pagelen[$this->page] = $this->pagelen[$page];
        $this->intmrk[$this->page] = $this->intmrk[$page];
        $this->bordermrk[$this->page] = $this->bordermrk[$page];
        $this->cntmrk[$this->page] = $this->cntmrk[$page];
        $this->pageobjects[$this->page] = $this->pageobjects[$page];
        $this->pageopen[$this->page] = false;
        if (isset($this->footerpos[$page])) {
            $this->footerpos[$this->page] = $this->footerpos[$page];
        }
        if (isset($this->footerlen[$page])) {
            $this->footerlen[$this->page] = $this->footerlen[$page];
        }
        if (isset($this->transfmrk[$page])) {
            $this->transfmrk[$this->page] = $this->transfmrk[$page];
        }
        if (isset($this->pageannots[$page])) {
            $this->pageannots[$this->page] = $this->pageannots[$page];
        }
        if (isset($this->newpagegroup[$page])) {
            // Start a new group.
            $this->newpagegroup[$this->page] = count($this->newpagegroup) + 1;
            $this->currpagegroup = $this->newpagegroup[$this->page];
            $this->pagegroups[$this->currpagegroup] = 1;
        } else if (isset($this->currpagegroup) AND ($this->currpagegroup > 0)) {
            ++$this->pagegroups[$this->currpagegroup];
        }
        // Copy outlines.
        $tmpoutlines = $this->outlines;
        foreach ($tmpoutlines as $key => $outline) {
            if ($outline['p'] == $page) {
                $this->outlines[] = array('t' => $outline['t'], 'l' => $outline['l'], 'y' => $outline['y'],
                                          'p' => $this->page, 's' => $outline['s'], 'c' => $outline['c']);
            }
        }
        // Copy links.
        $tmplinks = $this->links;
        foreach ($tmplinks as $key => $link) {
            if ($link[0] == $page) {
                $this->links[] = array($this->page, $link[1]);
            }
        }
        // Return to last page.
        $this->lastpage(true);
        return true;
    }

    /**
     * output a Table of Content Index (TOC).
     * This method must be called after all bookmarks were set.
     * Before calling this method you have to open the page using the addtocpage() method.
     * After calling this method you have to call endtocpage() to close the TOC page.
     * You can override this method to achieve different styles.
     * @see addtocpage(), endtocpage(), addhtmltoc()
     */
    public function addtoc($page = '', $numbersfont = '', $filler = '.', $tocname = 'TOC', $style = '',
                           $color = array(0, 0, 0)) {
        $fontsize = $this->fontsizept;
        $fontfamily = $this->fontfamily;
        $fontstyle = $this->fontstyle;
        $w = $this->w - $this->lmargin - $this->rmargin;
        $spacer = $this->getstringwidth(chr(32)) * 4;
        $lmargin = $this->lmargin;
        $rmargin = $this->rmargin;
        $xstart = $this->getx();
        $pagefirst = $this->page;
        $currentpage = $this->page;
        $pagefillstart = false;
        $pagefillend = false;
        $currentcolumn = $this->currentcolumn;
        if ($this->empty_string($numbersfont)) {
            $numbersfont = $this->defaultmonospacedfont;
        }
        if ($this->empty_string($filler)) {
            $filler = ' ';
        }
        if ($this->empty_string($page)) {
            $gap = ' ';
        } else {
            $gap = '';
            if ($page < 1) {
                $page = 1;
            }
        }
        $this->setfont($numbersfont, $fontstyle, $fontsize);
        $numwidth = $this->getstringwidth('00000');
        $maxpage = 0; // Used for pages on attached documents.
        foreach ($this->outlines as $key => $outline) {
            // Check for extra pages (used for attachments).
            if (($this->page > $pagefirst) AND ($outline['p'] >= $this->numpages)) {
                $outline['p'] += ($this->page - $pagefirst);
            }
            if ($this->rtl) {
                $aligntext = 'R';
                $alignnum = 'L';
            } else {
                $aligntext = 'L';
                $alignnum = 'R';
            }
            if ($outline['l'] == 0) {
                $this->setfont($fontfamily, $outline['s'].'B', $fontsize);
            } else {
                $this->setfont($fontfamily, $outline['s'], $fontsize - $outline['l']);
            }
            $this->settextcolorarray($outline['c']);
            // Check for page break.
            $this->checkpagebreak((2 * $this->fontsize * $this->cellheightratio));
            // Set margins and X position.
            if (($this->page == $currentpage) AND ($this->currentcolumn == $currentcolumn)) {
                $this->lmargin = $lmargin;
                $this->rmargin = $rmargin;
            } else {
                if ($this->currentcolumn != $currentcolumn) {
                    if ($this->rtl) {
                        $xstart = $this->w - $this->columns[$this->currentcolumn]['x'];
                    } else {
                        $xstart = $this->columns[$this->currentcolumn]['x'];
                    }
                }
                $lmargin = $this->lmargin;
                $rmargin = $this->rmargin;
                $currentpage = $this->page;
                $currentcolumn = $this->currentcolumn;
            }
            $this->setx($xstart);
            $indent = ($spacer * $outline['l']);
            if ($this->rtl) {
                $this->x -= $indent;
                $this->rmargin = $this->w - $this->x;
            } else {
                $this->x += $indent;
                $this->lmargin = $this->x;
            }
            $link = $this->addlink();
            $this->setlink($link, $outline['y'], $outline['p']);
            // Write the text.
            if ($this->rtl) {
                $txt = ' '.$outline['t'];
            } else {
                $txt = $outline['t'].' ';
            }
            $this->write(0, $txt, $link, false, $aligntext, false, 0, false, false, 0, $numwidth, '');
            if ($this->rtl) {
                $tw = $this->x - $this->lmargin;
            } else {
                $tw = $this->w - $this->rmargin - $this->x;
            }
            $this->setfont($numbersfont, $fontstyle, $fontsize);
            if ($this->empty_string($page)) {
                $pagenum = $outline['p'];
            } else {
                // Placemark to be replaced with the correct number.
                $pagenum = '{#'.($outline['p']).'}';
                if ($this->isunicodefont()) {
                    $pagenum = '{'.$pagenum.'}';
                }
                $maxpage = max($maxpage, $outline['p']);
            }
            $fw = ($tw - $this->getstringwidth($pagenum.$filler));
            $numfills = floor($fw / $this->getstringwidth($filler));
            if ($numfills > 0) {
                $rowfill = str_repeat($filler, $numfills);
            } else {
                $rowfill = '';
            }
            if ($this->rtl) {
                $pagenum = $pagenum.$gap.$rowfill;
            } else {
                $pagenum = $rowfill.$gap.$pagenum;
            }
            // Write the number.
            $this->cell($tw, 0, $pagenum, 0, 1, $alignnum, 0, $link, 0);
        }
        $pagelast = $this->getpage();
        $numpages = ($pagelast - $pagefirst + 1);
        // Account for booklet mode.
        if ($this->booklet) {
            // Check if a blank page is required before TOC.
            $pagefillstart = ((($pagefirst % 2) == 0) XOR (($page % 2) == 0));
            $pagefillend = (!((($numpages % 2) == 0) XOR ($pagefillstart)));
            if ($pagefillstart) {
                // Add a page at the end (to be moved before TOC).
                $this->addPage();
                ++$pagelast;
                ++$numpages;
            }
            if ($pagefillend) {
                // Add a page at the end.
                $this->addPage();
                ++$pagelast;
                ++$numpages;
            }
        }
        $maxpage = max($maxpage, $pagelast);
        if (!$this->empty_string($page)) {
            for ($p = $pagefirst; $p <= $pagelast; ++$p) {
                // Get page data.
                $temppage = $this->getpagebuffer($p);
                for ($n = 1; $n <= $maxpage; ++$n) {
                    // Update page numbers.
                    $a = '{#'.$n.'}';
                    // Get page number aliases.
                    $pnalias = $this->getinternalpagenumberaliases($a);
                    // Calculate replacement number.
                    if (($n >= $page) AND ($n <= $this->numpages)) {
                        $np = $n + $numpages;
                    } else {
                        $np = $n;
                    }
                    $na = $this->formattocpagenumber(($this->startingpagenumber + $np - 1));
                    $nu = $this->utf8toutf16be($na, false);
                    // Replace aliases with numbers.
                    foreach ($pnalias['u'] as $u) {
                        $sfill = str_repeat($filler, max(0, (strlen($u) - strlen($nu.' '))));
                        if ($this->rtl) {
                            $nr = $nu.$this->utf8toutf16be(' '.$sfill);
                        } else {
                            $nr = $this->utf8toutf16be($sfill.' ').$nu;
                        }
                        $temppage = str_replace($u, $nr, $temppage);
                    }
                    foreach ($pnalias['a'] as $a) {
                        $sfill = str_repeat($filler, max(0, (strlen($a) - strlen($na.' '))));
                        if ($this->rtl) {
                            $nr = $na.' '.$sfill;
                        } else {
                            $nr = $sfill.' '.$na;
                        }
                        $temppage = str_replace($a, $nr, $temppage);
                    }
                }
                // Save changes.
                $this->setpagebuffer($p, $temppage);
            }
            // Move pages.
            $this->bookmark($tocname, 0, 0, $pagefirst, $style, $color);
            if ($pagefillstart) {
                $this->movepage($pagelast, $pagefirst);
            }
            for ($i = 0; $i < $numpages; ++$i) {
                $this->movepage($pagelast, $page);
            }
        }
    }

    /**
     * output a Table Of Content Index (TOC) using HTML templates.
     * This method must be called after all bookmarks were set.
     * Before calling this method you have to open the page using the addtocpage() method.
     * After calling this method you have to call endtocpage() to close the TOC page.
     * @see addtocpage(), endtocpage(), addtoc()
     */
    public function addhtmltoc($page = '', $tocname = 'TOC', $templates = array(), $correctalign = true, $style = '',
                               $color = array(0, 0, 0)) {
        $filler = ' ';
        $prevhtmllinkcolorarray = $this->htmllinkcolorarray;
        $prevhtmllinkfontstyle = $this->htmllinkfontstyle;
        // Set new style for link.
        $this->htmllinkcolorarray = array();
        $this->htmllinkfontstyle = '';
        $pagefirst = $this->getpage();
        $pagefillstart = false;
        $pagefillend = false;
        // Get the font type used for numbers in each template.
        $currentfont = $this->fontfamily;
        foreach ($templates as $level => $html) {
            $dom = $this->gethtmldomarray($html);
            foreach ($dom as $key => $value) {
                if ($value['value'] == '#TOC_PAGE_NUMBER#') {
                    $this->setfont($dom[($key - 1)]['fontname']);
                    $templates['F'.$level] = $this->isunicodefont();
                }
            }
        }
        $this->setfont($currentfont);
        $maxpage = 0; // Used for pages on attached documents.
        foreach ($this->outlines as $key => $outline) {
            // Get HTML template.
            $row = $templates[$outline['l']];
            if ($this->empty_string($page)) {
                $pagenum = $outline['p'];
            } else {
                // Placemark to be replaced with the correct number.
                $pagenum = '{#'.($outline['p']).'}';
                if ($templates['F'.$outline['l']]) {
                    $pagenum = '{'.$pagenum.'}';
                }
                $maxpage = max($maxpage, $outline['p']);
            }
            // Replace templates with current values.
            $row = str_replace('#TOC_DESCRIPTION#', $outline['t'], $row);
            $row = str_replace('#TOC_PAGE_NUMBER#', $pagenum, $row);
            // Add link to page.
            $row = '<a href="#'.$outline['p'].','.$outline['y'].'">'.$row.'</a>';
            // Write bookmark entry.
            $this->writehtml($row, false, false, true, false, '');
        }
        // Restore link styles.
        $this->htmllinkcolorarray = $prevhtmllinkcolorarray;
        $this->htmllinkfontstyle = $prevhtmllinkfontstyle;
        // Move TOC page and replace numbers.
        $pagelast = $this->getpage();
        $numpages = ($pagelast - $pagefirst + 1);
        // Account for booklet mode.
        if ($this->booklet) {
            // Check if a blank page is required before TOC.
            $pagefillstart = ((($pagefirst % 2) == 0) XOR (($page % 2) == 0));
            $pagefillend = (!((($numpages % 2) == 0) XOR ($pagefillstart)));
            if ($pagefillstart) {
                // Add a page at the end (to be moved before TOC).
                $this->addPage();
                ++$pagelast;
                ++$numpages;
            }
            if ($pagefillend) {
                // Add a page at the end.
                $this->addPage();
                ++$pagelast;
                ++$numpages;
            }
        }
        $maxpage = max($maxpage, $pagelast);
        if (!$this->empty_string($page)) {
            for ($p = $pagefirst; $p <= $pagelast; ++$p) {
                // Get page data.
                $temppage = $this->getpagebuffer($p);
                for ($n = 1; $n <= $maxpage; ++$n) {
                    // Update page numbers.
                    $a = '{#'.$n.'}';
                    // Get page number aliases.
                    $pnalias = $this->getinternalpagenumberaliases($a);
                    // Calculate replacement number.
                    if ($n >= $page) {
                        $np = $n + $numpages;
                    } else {
                        $np = $n;
                    }
                    $na = $this->formattocpagenumber(($this->startingpagenumber + $np - 1));
                    $nu = $this->utf8toutf16be($na, false);
                    // Replace aliases with numbers.
                    foreach ($pnalias['u'] as $u) {
                        if ($correctalign) {
                            $sfill = str_repeat($filler, (strlen($u) - strlen($nu.' ')));
                            if ($this->rtl) {
                                $nr = $nu.$this->utf8toutf16be(' '.$sfill);
                            } else {
                                $nr = $this->utf8toutf16be($sfill.' ').$nu;
                            }
                        } else {
                            $nr = $nu;
                        }
                        $temppage = str_replace($u, $nr, $temppage);
                    }
                    foreach ($pnalias['a'] as $a) {
                        if ($correctalign) {
                            $sfill = str_repeat($filler, (strlen($a) - strlen($na.' ')));
                            if ($this->rtl) {
                                $nr = $na.' '.$sfill;
                            } else {
                                $nr = $sfill.' '.$na;
                            }
                        } else {
                            $nr = $na;
                        }
                        $temppage = str_replace($a, $nr, $temppage);
                    }
                }
                // Save changes.
                $this->setpagebuffer($p, $temppage);
            }
            // Move pages.
            $this->bookmark($tocname, 0, 0, $pagefirst, $style, $color);
            if ($pagefillstart) {
                $this->movepage($pagelast, $pagefirst);
            }
            for ($i = 0; $i < $numpages; ++$i) {
                $this->movepage($pagelast, $page);
            }
        }
    }

    /**
     * Stores a copy of the current TCPDF object used for undo operation.
     */
    public function starttransaction() {
        if (isset($this->objcopy)) {
            // Remove previous copy.
            $this->committransaction();
        }
        // Record current page number and Y position.
        $this->starttransactionpage = $this->page;
        $this->starttransactiony = $this->y;
        // Clone current object.
        $this->objcopy = $this->objclone($this);
    }

    /**
     * Delete the copy of the current TCPDF object used for undo operation.
     */
    public function committransaction() {
        if (isset($this->objcopy)) {
            $this->objcopy->_destroy(true, true);
            unset($this->objcopy);
        }
    }

    /**
     * This method allows to undo the latest transaction by returning the latest saved
       TCPDF object with starttransaction().
     */
    public function rollbacktransaction($self = false) {
        if (isset($this->objcopy)) {
            if (isset($this->objcopy->diskcache) AND $this->objcopy->diskcache) {
                // Truncate files to previous values.
                foreach ($this->objcopy->cachefilelength as $file => $length) {
                    $file = substr($file, 1);
                    $handle = fopen($file, 'r+');
                    ftruncate($handle, $length);
                }
            }
            $this->_destroy(true, true);
            if ($self) {
                $objvars = get_object_vars($this->objcopy);
                foreach ($objvars as $key => $value) {
                    $this->$key = $value;
                }
            }
            return $this->objcopy;
        }
        return $this;
    }

    /**
     * Creates a copy of a class object
     */
    public function objclone($object) {
        return @clone($object);
    }

    /**
     * Determine whether a string is empty.
     */
    public function empty_string($str) {
        return (is_null($str) OR (is_string($str) AND (strlen($str) == 0)));
    }

    /**
     * Find position of last occurrence of a substring in a string
     */
    public function revstrpos($haystack, $needle, $offset = 0) {
        $length = strlen($haystack);
        $offset = ($offset > 0) ? ($length - $offset) : abs($offset);
        $pos = strpos(strrev($haystack), strrev($needle), $offset);
        return ($pos === false) ? false : ($length - $pos - strlen($needle));
    }

    // MULTI COLUMNS METHODS.

    /**
     * Set multiple columns of the same size
     */
    public function setequalcolumns($numcols = 0, $width = 0, $y = '') {
        $this->columns = array();
        if ($numcols < 2) {
            $numcols = 0;
            $this->columns = array();
        } else {
            // Maximum column width.
            $maxwidth = ($this->w - $this->originallmargin - $this->originalrmargin) / $numcols;
            if (($width == 0) OR ($width > $maxwidth)) {
                $width = $maxwidth;
            }
            if ($this->empty_string($y)) {
                $y = $this->y;
            }
            // Space between columns.
            $space = (($this->w - $this->originallmargin - $this->originalrmargin - ($numcols * $width)) / ($numcols - 1));
            // Fill the columns array (with, space, starting Y position).
            for ($i = 0; $i < $numcols; ++$i) {
                $this->columns[$i] = array('w' => $width, 's' => $space, 'y' => $y);
            }
        }
        $this->numcolumns = $numcols;
        $this->currentcolumn = 0;
        $this->columnstartpage = $this->page;
        $this->selectcolumn(0);
    }

    /**
     * Remove columns and reset page margins.
     */
    public function resetcolumns() {
        $this->lmargin = $this->originallmargin;
        $this->rmargin = $this->originalrmargin;
        $this->setequalcolumns();
    }

    /**
     * Set columns array.
     * Each column is represented by an array of arrays with the following keys:
       (w = width, s = space between columns, y = column top position).
     */
    public function setcolumnsarray($columns) {
        $this->columns = $columns;
        $this->numcolumns = count($columns);
        $this->currentcolumn = 0;
        $this->columnstartpage = $this->page;
        $this->selectcolumn(0);
    }

    /**
     * Set position at a given column
     */
    public function selectcolumn($col = '') {
        if (is_string($col)) {
            $col = $this->currentcolumn;
        } else if ($col >= $this->numcolumns) {
            $col = 0;
        }
        $xshift = array('x' => 0, 's' => array('H' => 0, 'V' => 0), 'p' => array('L' => 0, 'T' => 0, 'R' => 0, 'B' => 0));
        $enablethead = false;
        if ($this->numcolumns > 1) {
            if ($col != $this->currentcolumn) {
                // Move Y pointer at the top of the column.
                if ($this->columnstartpage == $this->page) {
                    $this->y = $this->columns[$col]['y'];
                } else {
                    $this->y = $this->tmargin;
                }
                // Avoid to write table headers more than once.
                if (($this->page > $this->maxselcol['page']) OR (($this->page == $this->maxselcol['page']) AND
                    ($col > $this->maxselcol['column']))) {
                    $enablethead = true;
                    $this->maxselcol['page'] = $this->page;
                    $this->maxselcol['column'] = $col;
                }
            }
            $xshift = $this->colxshift;
            // Set X position of the current column by case.
            $listindent = ($this->listindentlevel * $this->listindent);
            // Calculate column X position.
            $colpos = 0;
            for ($i = 0; $i < $col; ++$i) {
                $colpos += ($this->columns[$i]['w'] + $this->columns[$i]['s']);
            }
            if ($this->rtl) {
                $x = $this->w - $this->originalrmargin - $colpos;
                $this->rmargin = ($this->w - $x + $listindent);
                $this->lmargin = ($x - $this->columns[$col]['w']);
                $this->x = $x - $listindent;
            } else {
                $x = $this->originallmargin + $colpos;
                $this->lmargin = ($x + $listindent);
                $this->rmargin = ($this->w - $x - $this->columns[$col]['w']);
                $this->x = $x + $listindent;
            }
            $this->columns[$col]['x'] = $x;
        }
        $this->currentcolumn = $col;
        // Fix for HTML mode.
        $this->newline = true;
        // Print HTML table header (if any).
        if ((!$this->empty_string($this->thead)) AND (!$this->inthead)) {
            if ($enablethead) {
                // Print table header.
                $this->writehtml($this->thead, false, false, false, false, '');
                $this->y += $xshift['s']['V'];
                // Store end of header position.
                if (!isset($this->columns[$col]['th'])) {
                    $this->columns[$col]['th'] = array();
                }
                $this->columns[$col]['th']['\''.$this->page.'\''] = $this->y;
                $this->lasth = 0;
            } else if (isset($this->columns[$col]['th']['\''.$this->page.'\''])) {
                $this->y = $this->columns[$col]['th']['\''.$this->page.'\''];
            }
        }
        // Account for an html table cell over multiple columns.
        if ($this->rtl) {
            $this->rmargin += $xshift['x'];
            $this->x -= ($xshift['x'] + $xshift['p']['R']);
        } else {
            $this->lmargin += $xshift['x'];
            $this->x += $xshift['x'] + $xshift['p']['L'];
        }
    }

    /**
     * Return the current column number
     * @return int current column number
     */
    public function getcolumn() {
        return $this->currentcolumn;
    }

    /**
     * Return the current number of columns.
     * @return int number of columns
     */
    public function getnumberofcolumns() {
        return $this->numcolumns;
    }

    /**
     * Serialize an array of parameters to be used with TCPDF tag in HTML code.
     */
    public function serializetcpdftagparameters($pararray) {
        return urlencode(serialize($pararray));
    }

    /**
     * Set text rendering mode.
     */
    public function settextrenderingmode($stroke = 0, $fill = true, $clip = false) {
        // Convert text rendering parameters.
        if ($stroke < 0) {
            $stroke = 0;
        }
        if ($fill === true) {
            if ($stroke > 0) {
                if ($clip === true) {
                    // Fill, then stroke text and add to path for clipping.
                    $textrendermode = 6;
                } else {
                    // Fill, then stroke text.
                    $textrendermode = 2;
                }
                $textstrokewidth = $stroke;
            } else {
                if ($clip === true) {
                    // Fill text and add to path for clipping.
                    $textrendermode = 4;
                } else {
                    // Fill text.
                    $textrendermode = 0;
                }
            }
        } else {
            if ($stroke > 0) {
                if ($clip === true) {
                    // Stroke text and add to path for clipping.
                    $textrendermode = 5;
                } else {
                    // Stroke text.
                    $textrendermode = 1;
                }
                $textstrokewidth = $stroke;
            } else {
                if ($clip === true) {
                    // Add text to path for clipping.
                    $textrendermode = 7;
                } else {
                    // Neither fill nor stroke text (invisible).
                    $textrendermode = 3;
                }
            }
        }
        $this->textrendermode = $textrendermode;
        $this->textstrokewidth = $stroke * $this->k;
    }

    /**
     * Returns an array of chars containing soft hyphens.
     */
    protected function hyphenateword($word, $patterns, $dictionary = array(), $leftmin = 1, $rightmin = 2, $charmin = 1,
                                     $charmax = 8) {
        $hyphenword = array(); // Hyphens positions.
        $numchars = count($word);
        if ($numchars <= $charmin) {
            return $word;
        }
        $wordstring = $this->utf8arrsubstring($word);
        // Some words will be returned as-is.
        $pattern = '/^([a-zA-Z0-9_\.\-]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))
                   ([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$/';
        if (preg_match($pattern, $wordstring) > 0) {
            // Email.
            return $word;
        }
        $pattern = '/(([a-zA-Z0-9\-]+\.)?)((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))
                    ([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$/';
        if (preg_match($pattern, $wordstring) > 0) {
            // URL.
            return $word;
        }
        if (isset($dictionary[$wordstring])) {
            return $this->utf8stringtoarray($dictionary[$wordstring]);
        }
        // Surround word with '_' characters.
        $tmpword = array_merge(array(95), $word, array(95));
        $tmpnumchars = $numchars + 2;
        $maxpos = $tmpnumchars - $charmin;
        for ($pos = 0; $pos < $maxpos; ++$pos) {
            $imax = min(($tmpnumchars - $pos), $charmax);
            for ($i = $charmin; $i <= $imax; ++$i) {
                $subword = strtolower($this->utf8arrsubstring($tmpword, $pos, $pos + $i));
                if (isset($patterns[$subword])) {
                    $pattern = $this->utf8stringtoarray($patterns[$subword]);
                    $patternlength = count($pattern);
                    $digits = 1;
                    for ($j = 0; $j < $patternlength; ++$j) {
                        // Check if $pattern[$j] is a number.
                        if (($pattern[$j] >= 48) AND ($pattern[$j] <= 57)) {
                            if ($j == 0) {
                                $zero = $pos - 1;
                            } else {
                                $zero = $pos + $j - $digits;
                            }
                            if (!isset($hyphenword[$zero]) OR ($hyphenword[$zero] != $pattern[$j])) {
                                $hyphenword[$zero] = $this->unichr($pattern[$j]);
                            }
                            ++$digits;
                        }
                    }
                }
            }
        }
        $inserted = 0;
        $maxpos = $numchars - $rightmin;
        for ($i = $leftmin; $i <= $maxpos; ++$i) {
            if (isset($hyphenword[$i]) AND (($hyphenword[$i] % 2) != 0)) {
                array_splice($word, $i + $inserted, 0, 173);
                ++$inserted;
            }
        }
        return $word;
    }

    /**
     * Returns an array of hyphenation patterns.
     */
    public function gethyphenpatternsfromtex($file) {
        $data = file_get_contents($file);
        $patterns = array();
        // Remove comments.
        $data = preg_replace('/\%[^\n]*/', '', $data);
        // Extract the patterns part.
        preg_match('/\\\\patterns\{([^\}]*)\}/i', $data, $matches);
        $data = trim(substr($matches[0], 10, -1));
        // Extract each pattern.
        $patternsarray = preg_split('/[\s]+/', $data);
        // Create new language array of patterns.
        $patterns = array();
        foreach ($patternsarray as $val) {
            if (!$this->empty_string($val)) {
                $val = trim($val);
                $val = str_replace('\'', '\\\'', $val);
                $key = preg_replace('/[0-9]+/', '', $val);
                $patterns[$key] = $val;
            }
        }
        return $patterns;
    }

    /**
     * Returns text with soft hyphens.
     */
    public function hyphenatetext($text, $patterns, $dictionary = array(), $leftmin = 1, $rightmin = 2, $charmin = 1,
                                  $charmax = 8) {
        $text = $this->unhtmlentities($text);
        $word = array(); // Last word.
        $txtarr = array(); // Text to be returned.
        $intag = false; // True if we are inside an HTML tag.
        if (!is_array($patterns)) {
            $patterns = $this->gethyphenpatternsfromtex($patterns);
        }
        // Get array of characters.
        $unichars = $this->utf8stringtoarray($text);
        // For each char.
        foreach ($unichars as $char) {
            if ((!$intag) AND $this->unicode->uni_type[$char] == 'L') {
                // Letter character.
                $word[] = $char;
            } else {
                // Other type of character.
                if (!$this->empty_string($word)) {
                    // Hypenate the word.
                    $txtarr = array_merge($txtarr, $this->hyphenateword($word, $patterns, $dictionary, $leftmin, $rightmin,
                                          $charmin, $charmax));
                    $word = array();
                }
                $txtarr[] = $char;
                if (chr($char) == '<') {
                    // We are inside an HTML tag.
                    $intag = true;
                } else if ($intag AND (chr($char) == '>')) {
                    // End of HTML tag.
                    $intag = false;
                }
            }
        }
        if (!$this->empty_string($word)) {
            // Hypenate the word.
            $txtarr = array_merge($txtarr, $this->hyphenateword($word, $patterns, $dictionary, $leftmin, $rightmin,
                                  $charmin, $charmax));
        }
        // Convert char array to string and return.
        return $this->utf8arrsubstring($txtarr);
    }

    /**
     * Enable/disable rasterization of vector images using ImageMagick library.
     */
    public function setrasterizevectorimages($mode) {
        $this->rasterizevectorimages = $mode;
    }

    /**
     * Get the Path-Painting Operators.
     * @protected
     */
    protected function getpathpaintoperator($style, $default = 'S') {
        $op = '';
        switch($style) {
            case 'S':
            case 'D': {
                $op = 'S';
                break;
            }
            case 's':
            case 'd': {
                $op = 's';
                break;
            }
            case 'f':
            case 'F': {
                $op = 'f';
                break;
            }
            case 'f*':
            case 'F*': {
                $op = 'f*';
                break;
            }
            case 'B':
            case 'FD':
            case 'DF': {
                $op = 'B';
                break;
            }
            case 'B*':
            case 'F*D':
            case 'DF*': {
                $op = 'B*';
                break;
            }
            case 'b':
            case 'fd':
            case 'df': {
                $op = 'b';
                break;
            }
            case 'b*':
            case 'f*d':
            case 'df*': {
                $op = 'b*';
                break;
            }
            case 'CNZ': {
                $op = 'W n';
                break;
            }
            case 'CEO': {
                $op = 'W* n';
                break;
            }
            case 'n': {
                $op = 'n';
                break;
            }
            default: {
                if (!empty($default)) {
                    $op = $this->getpathpaintoperator($default, '');
                } else {
                    $op = '';
                }
            }
        }
            return $op;
    }

    /**
     * Enable or disable default option for font subsetting.
     */
    public function setfontsubsetting($enable = true) {
        if ($this->pdfamode) {
            $this->fontsubsetting = false;
        } else {
            $this->fontsubsetting = $enable ? true : false;
        }
    }

    /**
     * Return the default option for font subsetting.
     */
    public function getfontsubsetting() {
        return $this->fontsubsetting;
    }

    /**
     * Left trim the input string
     */
    public function stringlefttrim($str, $replace = '') {
        return preg_replace('/^'.$this->respace['p'].'+/'.$this->respace['m'], $replace, $str);
    }

    /**
     * Right trim the input string
     */
    public function stringrighttrim($str, $replace = '') {
        return preg_replace('/'.$this->respace['p'].'+$/'.$this->respace['m'], $replace, $str);
    }

    /**
     * Trim the input string
     */
    public function stringtrim($str, $replace = '') {
        $str = $this->stringlefttrim($str, $replace);
        $str = $this->stringrighttrim($str, $replace);
        return $str;
    }

    /**
     * Return true if the current font is unicode type.
     */
    public function isunicodefont() {
        return (($this->currentfont['type'] == 'TrueTypeUnicode') OR ($this->currentfont['type'] == 'cidfont0'));
    }

    /**
     * Return normalized font name
     */
    public function getfontfamilyname($fontfamily) {
        // Remove spaces and symbols.
        $fontfamily = preg_replace('/[^a-z0-9\,]/', '', strtolower($fontfamily));
        // Extract all font names.
        $fontslist = preg_split('/[,]/', $fontfamily);
        // Find first valid font name.
        foreach ($fontslist as $font) {
            // Replace font variations.
            $font = preg_replace('/italic$/', 'I', $font);
            $font = preg_replace('/oblique$/', 'I', $font);
            $font = preg_replace('/bold([I]?)$/', 'B\\1', $font);
            // Replace common family names and core fonts.
            $pattern = array();
            $replacement = array();
            $pattern[] = '/^serif|^cursive|^fantasy|^timesnewroman/';
            $replacement[] = 'times';
            $pattern[] = '/^sansserif/';
            $replacement[] = 'helvetica';
            $pattern[] = '/^monospace/';
            $replacement[] = 'courier';
            $font = preg_replace($pattern, $replacement, $font);
            if (in_array(strtolower($font), $this->fontlist) OR in_array($font, $this->fontkeys)) {
                return $font;
            }
        }
        // Return current font as default.
        return $this->currentfont['fontkey'];
    }

    /**
     * Start a new XObject Template.
     * @see endtemplate(), printtemplate()
     */
    public function starttemplate($w = 0, $h = 0, $group = false) {
        if ($this->inxobj) {
            // We are already inside an XObject template.
            return false;
        }
        $this->inxobj = true;
        ++$this->n;
        // XObject ID.
        $this->xobjid = 'XT'.$this->n;
        // Object ID.
        $this->xobjects[$this->xobjid] = array('n' => $this->n);
        // Store current graphic state.
        $this->xobjects[$this->xobjid]['gvars'] = $this->getgraphicvars();
        // Initialize data.
        $this->xobjects[$this->xobjid]['intmrk'] = 0;
        $this->xobjects[$this->xobjid]['transfmrk'] = array();
        $this->xobjects[$this->xobjid]['outdata'] = '';
        $this->xobjects[$this->xobjid]['xobjects'] = array();
        $this->xobjects[$this->xobjid]['images'] = array();
        $this->xobjects[$this->xobjid]['fonts'] = array();
        $this->xobjects[$this->xobjid]['annotations'] = array();
        $this->xobjects[$this->xobjid]['extgstates'] = array();
        $this->xobjects[$this->xobjid]['gradients'] = array();
        $this->xobjects[$this->xobjid]['spotcolors'] = array();
        // Set new environment.
        $this->numcolumns = 1;
        $this->currentcolumn = 0;
        $this->setautopagebreak(false);
        if (($w === '') OR ($w <= 0)) {
            $w = $this->w - $this->lmargin - $this->rmargin;
        }
        if (($h === '') OR ($h <= 0)) {
            $h = $this->h - $this->tmargin - $this->bmargin;
        }
        $this->xobjects[$this->xobjid]['x'] = 0;
        $this->xobjects[$this->xobjid]['y'] = 0;
        $this->xobjects[$this->xobjid]['w'] = $w;
        $this->xobjects[$this->xobjid]['h'] = $h;
        $this->w = $w;
        $this->h = $h;
        $this->wpt = $this->w * $this->k;
        $this->hpt = $this->h * $this->k;
        $this->fwpt = $this->wpt;
        $this->fhpt = $this->hpt;
        $this->x = 0;
        $this->y = 0;
        $this->lmargin = 0;
        $this->rmargin = 0;
        $this->tmargin = 0;
        $this->bmargin = 0;
        // Set group mode.
        $this->xobjects[$this->xobjid]['group'] = $group;
        return $this->xobjid;
    }

    /**
     * End the current XObject Template started with starttemplate() and restore the previous graphic state.
     * @see starttemplate(), printtemplate()
     */
    public function endtemplate() {
        if (!$this->inxobj) {
            // We are not inside a template.
            return false;
        }
        $this->inxobj = false;
        // Restore previous graphic state.
        $this->setgraphicvars($this->xobjects[$this->xobjid]['gvars'], true);
        return $this->xobjid;
    }

    /**
     * Print an XObject Template.
     * @see starttemplate(), endtemplate()
     */
    public function printtemplate($id, $x='', $y='', $w=0, $h=0, $align='', $palign='', $fitonpage=false) {
        if (!isset($this->xobjects[$id])) {
            $this->errord('The XObject Template \''.$id.'\' doesn\'t exist!');
        }
        if ($this->inxobj) {
            if ($id == $this->xobjid) {
                // Close current template.
                $this->endtemplate();
            } else {
                // Use the template as resource for the template currently opened.
                $this->xobjects[$this->xobjid]['xobjects'][$id] = $this->xobjects[$id];
            }
        }
        // Set default values.
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        $ow = $this->xobjects[$id]['w'];
        $oh = $this->xobjects[$id]['h'];
        // Calculate template width and height on document.
        if (($w <= 0) AND ($h <= 0)) {
            $w = $ow;
            $h = $oh;
        } else if ($w <= 0) {
            $w = $h * $ow / $oh;
        } else if ($h <= 0) {
            $h = $w * $oh / $ow;
        }
        // Fit the template on available space.
        list($w, $h, $x, $y) = $this->fitblock($w, $h, $x, $y, $fitonpage);
        // Set page alignment.
        $rby = $y + $h;
        // Set alignment.
        if ($this->rtl) {
            if ($palign == 'L') {
                $xt = $this->lmargin;
            } else if ($palign == 'C') {
                $xt = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $xt = $this->w - $this->rmargin - $w;
            } else {
                $xt = $x - $w;
            }
            $rbx = $xt;
        } else {
            if ($palign == 'L') {
                $xt = $this->lmargin;
            } else if ($palign == 'C') {
                $xt = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $xt = $this->w - $this->rmargin - $w;
            } else {
                $xt = $x;
            }
            $rbx = $xt + $w;
        }
        // Print XObject Template + transformation matrix.
        $this->starttransform();
        // Translate and scale.
        $sx = ($w / $this->xobjects[$id]['w']);
        $sy = ($h / $this->xobjects[$id]['h']);
        $tm = array();
        $tm[0] = $sx;
        $tm[1] = 0;
        $tm[2] = 0;
        $tm[3] = $sy;
        $tm[4] = $xt * $this->k;
        $tm[5] = ($this->h - $h - $y) * $this->k;
        $this->transform($tm);
        // Set object.
        $this->_out('/'.$id.' Do');
        $this->stoptransform();
        // Add annotations.
        if (!empty($this->xobjects[$id]['annotations'])) {
            foreach ($this->xobjects[$id]['annotations'] as $annot) {
                // Transform original coordinates.
                $coordlt = $this->gettransformationmatrixproduct($tm, array(1, 0, 0, 1, ($annot['x'] * $this->k),
                                                                (-$annot['y'] * $this->k)));
                $ax = ($coordlt[4] / $this->k);
                $ay = ($this->h - $h - ($coordlt[5] / $this->k));
                $coordrb = $this->gettransformationmatrixproduct($tm, array(1, 0, 0, 1, (($annot['x'] + $annot['w']) *
                           $this->k), ((-$annot['y'] - $annot['h']) * $this->k)));
                $aw = ($coordrb[4] / $this->k) - $ax;
                $ah = ($this->h - $h - ($coordrb[5] / $this->k)) - $ay;
                $this->annotation($ax, $ay, $aw, $ah, $annot['text'], $annot['opt'], $annot['spaces']);
            }
        }
        // Set pointer to align the next text/objects.
        switch($align) {
            case 'T': {
                $this->y = $y;
                $this->x = $rbx;
                break;
            }
            case 'M': {
                $this->y = $y + round($h / 2);
                $this->x = $rbx;
                break;
            }
            case 'B': {
                $this->y = $rby;
                $this->x = $rbx;
                break;
            }
            case 'N': {
                $this->sety($rby);
                break;
            }
            default:{
                break;
            }
        }
    }

    /**
     * Set the percentage of character stretching.
     */
    public function setfontstretching($perc = 100) {
        $this->fontstretching = $perc;
    }

    /**
     * Get the percentage of character stretching.
     */
    public function getfontstretching() {
        return $this->fontstretching;
    }

    /**
     * Set the amount to increase or decrease the space between characters in a text.
     */
    public function setfontspacing($spacing = 0) {
        $this->fontspacing = $spacing;
    }

    /**
     * Get the amount to increase or decrease the space between characters in a text.
     */
    public function getfontspacing() {
        return $this->fontspacing;
    }

    /**
     * Return an array of no-write page regions
     * @see setpageregions(), addpageregion()
     */
    public function getpageregions() {
        return $this->pageregions;
    }

    /**
     * Set no-write regions on page.
     * @see addpageregion(), getpageregions()
     */
    public function setpageregions($regions = array()) {
        // Empty current regions array.
        $this->pageregions = array();
        // Add regions.
        foreach ($regions as $data) {
            $this->addpageregion($data);
        }
    }

    /**
     * Add a single no-write region on selected page.
     * @see setpageregions(), getpageregions()
     */
    public function addpageregion($region) {
        if (!isset($region['page']) OR empty($region['page'])) {
            $region['page'] = $this->page;
        }
        if (isset($region['xt']) AND isset($region['xb']) AND ($region['xt'] > 0) AND ($region['xb'] > 0)
            AND isset($region['yt'])  AND isset($region['yb']) AND ($region['yt'] >= 0) AND ($region['yt'] < $region['yb'])
            AND isset($region['side']) AND (($region['side'] == 'L') OR ($region['side'] == 'R'))) {
            $this->pageregions[] = $region;
        }
    }

    /**
     * Remove a single no-write region.
     */
    public function removepageregion($key) {
        if (isset($this->pageregions[$key])) {
            unset($this->pageregions[$key]);
        }
    }

    /**
     * Check page for no-write regions and adapt current coordinates and page margins if necessary.
     * A no-write region is a portion of the page with a rectangular or trapezium shape that will not
       be covered when writing text or html code.
     * A region is always aligned on the left or right side of the page ad is defined using a vertical segment.
     */
    protected function checkpageregions($h, $x, $y) {
        // Set default values.
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        if (empty($this->pageregions)) {
            // No page regions defined.
            return array($x, $y);
        }
        if (empty($h)) {
            $h = ($this->fontsize * $this->cellheightratio) + $this->cellpadding['T'] + $this->cellpadding['B'];
        }
        // Check for page break.
        if ($this->checkpagebreak($h, $y)) {
            // The content will be printed on a new page.
            $x = $this->x;
            $y = $this->y;
        }
        if ($this->numcolumns > 1) {
            if ($this->rtl) {
                $this->lmargin = $this->columns[$this->currentcolumn]['x'] - $this->columns[$this->currentcolumn]['w'];
            } else {
                $this->rmargin = $this->w - $this->columns[$this->currentcolumn]['x'] -
                $this->columns[$this->currentcolumn]['w'];
            }
        } else {
            if ($this->rtl) {
                $this->lmargin = $this->originallmargin;
            } else {
                $this->rmargin = $this->originalrmargin;
            }
        }
        // Adjust coordinates and page margins.
        foreach ($this->pageregions as $regid => $regdata) {
            if ($regdata['page'] == $this->page) {
                // Check region boundaries.
                if (($y > ($regdata['yt'] - $h)) AND ($y <= $regdata['yb'])) {
                    // Y is inside the region.
                    $minv = ($regdata['xb'] - $regdata['xt']) / ($regdata['yb'] - $regdata['yt']);
                    // Inverse of angular coefficient.
                    $yt = max($y, $regdata['yt']);
                    $yb = min(($yt + $h), $regdata['yb']);
                    $xt = (($yt - $regdata['yt']) * $minv) + $regdata['xt'];
                    $xb = (($yb - $regdata['yt']) * $minv) + $regdata['xt'];
                    if ($regdata['side'] == 'L') { // Left side.
                        $newmargin = max($xt, $xb);
                        if ($this->lmargin < $newmargin) {
                            if ($this->rtl) {
                                // Adjust left page margin.
                                $this->lmargin = $newmargin;
                            }
                            if ($x < $newmargin) {
                                // Adjust x position.
                                $x = $newmargin;
                                if ($newmargin > ($this->w - $this->rmargin)) {
                                    // Adjust y position.
                                    $y = $regdata['yb'] - $h;
                                }
                            }
                        }
                    } else if ($regdata['side'] == 'R') { // Right side.
                        $newmargin = min($xt, $xb);
                        if (($this->w - $this->rmargin) > $newmargin) {
                            if (!$this->rtl) {
                                // Adjust right page margin.
                                $this->rmargin = ($this->w - $newmargin);
                            }
                            if ($x > $newmargin) {
                                // Adjust x position.
                                $x = $newmargin;
                                if ($newmargin > $this->lmargin) {
                                    // Adjust y position.
                                    $y = $regdata['yb'] - $h;
                                }
                            }
                        }
                    }
                }
            }
        }
        return array($x, $y);
    }

    // SVG METHODS.
    /**
     * Embedd a Scalable Vector Graphics (SVG) image.
     */
    public function imagesvg($file, $x = '', $y = '', $w = 0, $h = 0, $link = '', $align = '', $palign = '', $border = 0,
                             $fitonpage = false) {
        if ($this->rasterizevectorimages AND ($w > 0) AND ($h > 0)) {
            // Convert SVG to raster image using GD or ImageMagick libraries.
            return $this->imageq($file, $x, $y, $w, $h, 'SVG', $link, $align, true, 300, $palign, false, false, $border, false,
                                false, false);
        }
        if ($file{0} === '@') { // Image from string.
            $this->svgdir = '';
            $svgdata = substr($file, 1);
        } else { // SVG file.
            $this->svgdir = dirname($file);
            $svgdata = file_get_contents($file);
        }
        if ($svgdata === false) {
            $this->errord('SVG file not found: '.$file);
        }
        if ($x === '') {
            $x = $this->x;
        }
        if ($y === '') {
            $y = $this->y;
        }
        // Check page for no-write regions and adapt page margins if necessary.
        list($x, $y) = $this->checkpageregions($h, $x, $y);
        $k = $this->k;
        $ox = 0;
        $oy = 0;
        $ow = $w;
        $oh = $h;
        $aspectratioalign = 'xMidYMid';
        $aspectratioms = 'meet';
        $regs = array();
        // Get original image width and height.
        preg_match('/<svg([^\>]*)>/si', $svgdata, $regs);
        if (isset($regs[1]) AND !empty($regs[1])) {
            $tmp = array();
            if (preg_match('/[\s]+x[\s]*=[\s]*"([^"]*)"/si', $regs[1], $tmp)) {
                $ox = $this->gethtmlunittounits($tmp[1], 0, $this->svgunit, false);
            }
            $tmp = array();
            if (preg_match('/[\s]+y[\s]*=[\s]*"([^"]*)"/si', $regs[1], $tmp)) {
                $oy = $this->gethtmlunittounits($tmp[1], 0, $this->svgunit, false);
            }
            $tmp = array();
            if (preg_match('/[\s]+width[\s]*=[\s]*"([^"]*)"/si', $regs[1], $tmp)) {
                $ow = $this->gethtmlunittounits($tmp[1], 1, $this->svgunit, false);
            }
            $tmp = array();
            if (preg_match('/[\s]+height[\s]*=[\s]*"([^"]*)"/si', $regs[1], $tmp)) {
                $oh = $this->gethtmlunittounits($tmp[1], 1, $this->svgunit, false);
            }
            $tmp = array();
            $viewbox = array();
            if (preg_match('/[\s]+viewBox[\s]*=[\s]*"[\s]*([0-9\.\-]+)[\s]+([0-9\.\-]+)[\s]+([0-9\.]+)[\s]+([0-9\.]+)[\s]*"/si',
                           $regs[1], $tmp)) {
                if (count($tmp) == 5) {
                    array_shift($tmp);
                    foreach ($tmp as $key => $val) {
                        $viewbox[$key] = $this->gethtmlunittounits($val, 0, $this->svgunit, false);
                    }
                    $ox = $viewbox[0];
                    $oy = $viewbox[1];
                }
                // Get aspect ratio.
                $tmp = array();
                if (preg_match('/[\s]+preserveAspectRatio[\s]*=[\s]*"([^"]*)"/si', $regs[1], $tmp)) {
                    $aspectratio = preg_split('/[\s]+/si', $tmp[1]);
                    switch (count($aspectratio)) {
                        case 3: {
                            $aspectratioalign = $aspectratio[1];
                            $aspectratioms = $aspectratio[2];
                            break;
                        }
                        case 2: {
                            $aspectratioalign = $aspectratio[0];
                            $aspectratioms = $aspectratio[1];
                            break;
                        }
                        case 1: {
                            $aspectratioalign = $aspectratio[0];
                            $aspectratioms = 'meet';
                            break;
                        }
                    }
                }
            }
        }
        // Calculate image width and height on document.
        if (($w <= 0) AND ($h <= 0)) {
            // Convert image size to document unit.
            $w = $ow;
            $h = $oh;
        } else if ($w <= 0) {
            $w = $h * $ow / $oh;
        } else if ($h <= 0) {
            $h = $w * $oh / $ow;
        }
        // Fit the image on available space.
        list($w, $h, $x, $y) = $this->fitblock($w, $h, $x, $y, $fitonpage);
        if ($this->rasterizevectorimages) {
            // Convert SVG to raster image u.sing GD or ImageMagick libraries.
            return $this->imageq($file, $x, $y, $w, $h, 'SVG', $link, $align, true, 300, $palign, false, false, $border,
                                false, false, false);
        }
        // Set alignment.
        $this->imgrby = $y + $h;
        // Set alignment.
        if ($this->rtl) {
            if ($palign == 'L') {
                $ximg = $this->lmargin;
            } else if ($palign == 'C') {
                $ximg = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $ximg = $this->w - $this->rmargin - $w;
            } else {
                $ximg = $x - $w;
            }
            $this->imgrbx = $ximg;
        } else {
            if ($palign == 'L') {
                $ximg = $this->lmargin;
            } else if ($palign == 'C') {
                $ximg = ($this->w + $this->lmargin - $this->rmargin - $w) / 2;
            } else if ($palign == 'R') {
                $ximg = $this->w - $this->rmargin - $w;
            } else {
                $ximg = $x;
            }
            $this->imgrbx = $ximg + $w;
        }
        // Store current graphic vars.
        $gvars = $this->getgraphicvars();
        // Store SVG position and scale factors.
        $svgoffsetx = ($ximg - $ox) * $this->k;
        $svgoffsety = -($y - $oy) * $this->k;
        if (isset($viewbox[2]) AND ($viewbox[2] > 0) AND ($viewbox[3] > 0)) {
            $ow = $viewbox[2];
            $oh = $viewbox[3];
        } else {
            if ($ow <= 0) {
                $ow = $w;
            }
            if ($oh <= 0) {
                $oh = $h;
            }
        }
        $svgscalex = $w / $ow;
        $svgscaley = $h / $oh;
        // Ccaling and alignment.
        if ($aspectratioalign != 'none') {
            // Store current scaling values.
            $svgscaleoldx = $svgscalex;
            $svgscaleoldy = $svgscaley;
            // Force uniform scaling.
            if ($aspectratioms == 'slice') {
                // The entire viewport is covered by the viewBox.
                if ($svgscalex > $svgscaley) {
                    $svgscaley = $svgscalex;
                } else if ($svgscalex < $svgscaley) {
                    $svgscalex = $svgscaley;
                }
            } else { // Meet.
                // The entire viewBox is visible within the viewport.
                if ($svgscalex < $svgscaley) {
                    $svgscaley = $svgscalex;
                } else if ($svgscalex > $svgscaley) {
                    $svgscalex = $svgscaley;
                }
            }
            // Correct X alignment.
            switch (substr($aspectratioalign, 1, 3)) {
                case 'Min': {
                    // Do nothing.
                    break;
                }
                case 'Max': {
                    $svgoffsetx += (($w * $this->k) - ($ow * $this->k * $svgscalex));
                    break;
                }
                case 'Mid': {
                    $svgoffsetx += ((($w * $this->k) - ($ow * $this->k * $svgscalex)) / 2);
                    break;
                }
            }
            // Correct Y alignment.
            switch (substr($aspectratioalign, 5)) {
                case 'Min': {
                    // Do nothing.
                    break;
                }
                case 'Max': {
                    $svgoffsety -= (($h * $this->k) - ($oh * $this->k * $svgscaley));
                    break;
                }
                case 'Mid': {
                    $svgoffsety -= ((($h * $this->k) - ($oh * $this->k * $svgscaley)) / 2);
                    break;
                }
            }
        }
        // Store current page break mode.
        $pagebreakmode = $this->autopagebreak;
        $pagebreakmargin = $this->getbreakmargin();
        $cellpadding = $this->cellpadding;
        $this->setcellpadding(0);
        $this->setautopagebreak(false);
        // Save the current graphic state.
        $this->_out('q'.$this->epsmarker);
        // Set initial clipping mask.
        $this->rect($x, $y, $w, $h, 'CNZ', array(), array());
        // Scale and translate.
        $e = $ox * $this->k * (1 - $svgscalex);
        $f = ($this->h - $oy) * $this->k * (1 - $svgscaley);
        $this->_out(sprintf('%F %F %F %F %F %F cm', $svgscalex, 0, 0, $svgscaley, ($e + $svgoffsetx), ($f + $svgoffsety)));
        // Creates a new XML parser to be used by the other XML functions.
        $this->parser = xml_parser_create('UTF-8');
        // The following function allows to use parser inside object.
        xml_set_object($this->parser, $this);
        // Disable case-folding for this XML parser.
        xml_parser_set_option($this->parser, XML_OPTION_CASE_FOLDING, 0);
        // Sets the element handler functions for the XML parser.
        xml_set_element_handler($this->parser, 'startsvgelementhandler', 'endsvgelementhandler');
        // Sets the character data handler function for the XML parser.
        xml_set_character_data_handler($this->parser, 'segsvgcontenthandler');
        // Start parsing an XML document.
        if (!xml_parse($this->parser, $svgdata)) {
            $errormessage = sprintf('SVG errord: %s at line %d', xml_error_string(xml_get_error_code($this->parser)),
                                      xml_get_current_linenumber($this->parser));
            $this->errord($errormessage);
        }
        // Free this XML parser.
        xml_parser_free($this->parser);
        // Restore previous graphic state.
        $this->_out($this->epsmarker.'Q');
        // Restore graphic vars.
        $this->setgraphicvars($gvars);
        $this->lasth = $gvars['lasth'];
        if (!empty($border)) {
            $bx = $this->x;
            $by = $this->y;
            $this->x = $ximg;
            if ($this->rtl) {
                $this->x += $w;
            }
            $this->y = $y;
            $this->cell($w, $h, '', $border, 0, '', 0, '', 0, true);
            $this->x = $bx;
            $this->y = $by;
        }
        if ($link) {
            $this->link($ximg, $y, $w, $h, $link, 0);
        }
        // Set pointer to align the next text/objects.
        switch($align) {
            case 'T':{
                $this->y = $y;
                $this->x = $this->imgrbx;
                break;
            }
            case 'M':{
                $this->y = $y + round($h / 2);
                $this->x = $this->imgrbx;
                break;
            }
            case 'B':{
                $this->y = $this->imgrby;
                $this->x = $this->imgrbx;
                break;
            }
            case 'N':{
                $this->sety($this->imgrby);
                break;
            }
            default:{
                // Restore pointer to starting position.
                $this->x = $gvars['x'];
                $this->y = $gvars['y'];
                $this->page = $gvars['page'];
                $this->currentcolumn = $gvars['currentcolumn'];
                $this->tmargin = $gvars['tmargin'];
                $this->bmargin = $gvars['bmargin'];
                $this->w = $gvars['w'];
                $this->h = $gvars['h'];
                $this->wpt = $gvars['wpt'];
                $this->hpt = $gvars['hpt'];
                $this->fwpt = $gvars['fwpt'];
                $this->fhpt = $gvars['fhpt'];
                break;
            }
        }
        $this->endlinex = $this->imgrbx;
        // Restore page break.
        $this->setautopagebreak($pagebreakmode, $pagebreakmargin);
        $this->cellpadding = $cellpadding;
    }

    /**
     * Get the tranformation matrix from SVG transform attribute
     */
    protected function getsvgtransformmatrix($attribute) {
        // Identity matrix.
        $tm = array(1, 0, 0, 1, 0, 0);
        $transform = array();
        if (preg_match_all('/(matrix|translate|scale|rotate|skewX|skewY)[\s]*\(([^\)]+)\)/si', $attribute, $transform,
                            PREG_SET_ORDER) > 0) {
            foreach ($transform as $key => $data) {
                if (!empty($data[2])) {
                    $a = 1;
                    $b = 0;
                    $c = 0;
                    $d = 1;
                    $e = 0;
                    $f = 0;
                    $regs = array();
                    switch ($data[1]) {
                        case 'matrix': {
                            if (preg_match('/([a-z0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)[\,\s]+
                                          ([a-z0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)/si', $data[2],
                                          $regs)) {
                                $a = $regs[1];
                                $b = $regs[2];
                                $c = $regs[3];
                                $d = $regs[4];
                                $e = $regs[5];
                                $f = $regs[6];
                            }
                            break;
                        }
                        case 'translate': {
                            if (preg_match('/([a-z0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)/si', $data[2], $regs)) {
                                $e = $regs[1];
                                $f = $regs[2];
                            } else if (preg_match('/([a-z0-9\-\.]+)/si', $data[2], $regs)) {
                                $e = $regs[1];
                            }
                            break;
                        }
                        case 'scale': {
                            if (preg_match('/([a-z0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)/si', $data[2], $regs)) {
                                $a = $regs[1];
                                $d = $regs[2];
                            } else if (preg_match('/([a-z0-9\-\.]+)/si', $data[2], $regs)) {
                                $a = $regs[1];
                                $d = $a;
                            }
                            break;
                        }
                        case 'rotate': {
                            if (preg_match('/([0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)[\,\s]+([a-z0-9\-\.]+)/si', $data[2], $regs)) {
                                $ang = deg2rad($regs[1]);
                                $x = $regs[2];
                                $y = $regs[3];
                                $a = cos($ang);
                                $b = sin($ang);
                                $c = -$b;
                                $d = $a;
                                $e = ($x * (1 - $a)) - ($y * $c);
                                $f = ($y * (1 - $d)) - ($x * $b);
                            } else if (preg_match('/([0-9\-\.]+)/si', $data[2], $regs)) {
                                $ang = deg2rad($regs[1]);
                                $a = cos($ang);
                                $b = sin($ang);
                                $c = -$b;
                                $d = $a;
                                $e = 0;
                                $f = 0;
                            }
                            break;
                        }
                        case 'skewX': {
                            if (preg_match('/([0-9\-\.]+)/si', $data[2], $regs)) {
                                $c = tan(deg2rad($regs[1]));
                            }
                            break;
                        }
                        case 'skewY': {
                            if (preg_match('/([0-9\-\.]+)/si', $data[2], $regs)) {
                                $b = tan(deg2rad($regs[1]));
                            }
                            break;
                        }
                    }
                    $tm = $this->gettransformationmatrixproduct($tm, array($a, $b, $c, $d, $e, $f));
                }
            }
        }
        return $tm;
    }

    /**
     * Get the product of two SVG tranformation matrices
     */
    protected function gettransformationmatrixproduct($ta, $tb) {
        $tm = array();
        $tm[0] = ($ta[0] * $tb[0]) + ($ta[2] * $tb[1]);
        $tm[1] = ($ta[1] * $tb[0]) + ($ta[3] * $tb[1]);
        $tm[2] = ($ta[0] * $tb[2]) + ($ta[2] * $tb[3]);
        $tm[3] = ($ta[1] * $tb[2]) + ($ta[3] * $tb[3]);
        $tm[4] = ($ta[0] * $tb[4]) + ($ta[2] * $tb[5]) + $ta[4];
        $tm[5] = ($ta[1] * $tb[4]) + ($ta[3] * $tb[5]) + $ta[5];
        return $tm;
    }

    /**
     * Convert SVG transformation matrix to PDF.
     */
    protected function convertsvgtmatrix($tm) {
        $a = $tm[0];
        $b = -$tm[1];
        $c = -$tm[2];
        $d = $tm[3];
        $e = $this->gethtmlunittounits($tm[4], 1, $this->svgunit, false) * $this->k;
        $f = -$this->gethtmlunittounits($tm[5], 1, $this->svgunit, false) * $this->k;
        $x = 0;
        $y = $this->h * $this->k;
        $e = ($x * (1 - $a)) - ($y * $c) + $e;
        $f = ($y * (1 - $d)) - ($x * $b) + $f;
        return array($a, $b, $c, $d, $e, $f);
    }

    /**
     * Apply SVG graphic transformation matrix.
     */
    protected function svgtransform($tm) {
        $this->transform($this->convertsvgtmatrix($tm));
    }

    /**
     * Apply the requested SVG styles (*** TO BE COMPLETED ***)
     */
    protected function setsvgstyles($svgstyle, $prevsvgstyle, $x = 0, $y = 0, $w = 1, $h = 1, $clipfunction = '',
                                    $clipparams = array()) {
        $objstyle = '';
        $minlen = (0.01 / $this->k); // Minimum acceptable length (3 point).
        if (!isset($svgstyle['opacity'])) {
            return $objstyle;
        }
        // Clip-path.
        $regs = array();
        if (preg_match('/url\([\s]*\#([^\)]*)\)/si', $svgstyle['clip-path'], $regs)) {
            $clippath = $this->svgclippaths[$regs[1]];
            foreach ($clippath as $cp) {
                $this->startsvgelementhandler('clip-path', $cp['name'], $cp['attribs'], $cp['tm']);
            }
        }
        // Opacity.
        if ($svgstyle['opacity'] != 1) {
            $this->setalpha($svgstyle['opacity'], 'Normal', $svgstyle['opacity'], false);
        }
        // Color.
        $fillcolor = $this->converthtmlcolortodec($svgstyle['color']);
        $this->setfillcolorarray($fillcolor);
        // Text color.
        $textcolor = $this->converthtmlcolortodec($svgstyle['text-color']);
        $this->settextcolorarray($textcolor);
        // Clip.
        if (preg_match('/rect\(([a-z0-9\-\.]*)[\s]*([a-z0-9\-\.]*)[\s]*([a-z0-9\-\.]*)[\s]*([a-z0-9\-\.]*)\)/si',
                       $svgstyle['clip'], $regs)) {
            $top = (isset($regs[1]) ? $this->gethtmlunittounits($regs[1], 0, $this->svgunit, false) : 0);
            $right = (isset($regs[2]) ? $this->gethtmlunittounits($regs[2], 0, $this->svgunit, false) : 0);
            $bottom = (isset($regs[3]) ? $this->gethtmlunittounits($regs[3], 0, $this->svgunit, false) : 0);
            $left = (isset($regs[4]) ? $this->gethtmlunittounits($regs[4], 0, $this->svgunit, false) : 0);
            $cx = $x + $left;
            $cy = $y + $top;
            $cw = $w - $left - $right;
            $ch = $h - $top - $bottom;
            if ($svgstyle['clip-rule'] == 'evenodd') {
                $cliprule = 'CNZ';
            } else {
                $cliprule = 'CEO';
            }
            $this->rect($cx, $cy, $cw, $ch, $cliprule, array(), array());
        }
        // Fill.
        $regs = array();
        if (preg_match('/url\([\s]*\#([^\)]*)\)/si', $svgstyle['fill'], $regs)) {
            // Gradient.
            $gradient = $this->svggradients[$regs[1]];
            if (isset($gradient['xref'])) {
                // Reference to another gradient definition.
                $newgradient = $this->svggradients[$gradient['xref']];
                $newgradient['coords'] = $gradient['coords'];
                $newgradient['mode'] = $gradient['mode'];
                $newgradient['gradientUnits'] = $gradient['gradientUnits'];
                if (isset($gradient['gradienttransform'])) {
                    $newgradient['gradienttransform'] = $gradient['gradienttransform'];
                }
                $gradient = $newgradient;
            }
            // Save current Graphic State.
            $this->_out('q');
            // Set clipping area.
            if (!empty($clipfunction) AND method_exists($this, $clipfunction)) {
                $bbox = call_user_func_array(array($this, $clipfunction), $clipparams);
                if (is_array($bbox) AND (count($bbox) == 4)) {
                    list($x, $y, $w, $h) = $bbox;
                }
            }
            if ($gradient['mode'] == 'measure') {
                if (isset($gradient['gradienttransform']) AND !empty($gradient['gradienttransform'])) {
                    $gtm = $gradient['gradienttransform'];
                    // Apply transformation matrix.
                    $xa = ($gtm[0] * $gradient['coords'][0]) + ($gtm[2] * $gradient['coords'][1]) + $gtm[4];
                    $ya = ($gtm[1] * $gradient['coords'][0]) + ($gtm[3] * $gradient['coords'][1]) + $gtm[5];
                    $xb = ($gtm[0] * $gradient['coords'][2]) + ($gtm[2] * $gradient['coords'][3]) + $gtm[4];
                    $yb = ($gtm[1] * $gradient['coords'][2]) + ($gtm[3] * $gradient['coords'][3]) + $gtm[5];
                    if (isset($gradient['coords'][4])) {
                        $gradient['coords'][4] = sqrt(pow(($gtm[0] * $gradient['coords'][4]), 2) + pow(($gtm[1] *
                        $gradient['coords'][4]), 2));
                    }
                    $gradient['coords'][0] = $xa;
                    $gradient['coords'][1] = $ya;
                    $gradient['coords'][2] = $xb;
                    $gradient['coords'][3] = $yb;
                }
                // Convert SVG coordinates to user units.
                $gradient['coords'][0] = $this->gethtmlunittounits($gradient['coords'][0], 0, $this->svgunit, false);
                $gradient['coords'][1] = $this->gethtmlunittounits($gradient['coords'][1], 0, $this->svgunit, false);
                $gradient['coords'][2] = $this->gethtmlunittounits($gradient['coords'][2], 0, $this->svgunit, false);
                $gradient['coords'][3] = $this->gethtmlunittounits($gradient['coords'][3], 0, $this->svgunit, false);
                if (isset($gradient['coords'][4])) {
                    $gradient['coords'][4] = $this->gethtmlunittounits($gradient['coords'][4], 0, $this->svgunit, false);
                }
                if ($w <= $minlen) {
                    $w = $minlen;
                }
                if ($h <= $minlen) {
                    $h = $minlen;
                }
                // Shift units.
                if ($gradient['gradientUnits'] == 'objectBoundingBox') {
                    // Convert to SVG coordinate system.
                    $gradient['coords'][0] += $x;
                    $gradient['coords'][1] += $y;
                    $gradient['coords'][2] += $x;
                    $gradient['coords'][3] += $y;
                }
                // Calculate percentages.
                $gradient['coords'][0] = (($gradient['coords'][0] - $x) / $w);
                $gradient['coords'][1] = (($gradient['coords'][1] - $y) / $h);
                $gradient['coords'][2] = (($gradient['coords'][2] - $x) / $w);
                $gradient['coords'][3] = (($gradient['coords'][3] - $y) / $h);
                if (isset($gradient['coords'][4])) {
                    $gradient['coords'][4] /= $w;
                }
            } else if ($gradient['mode'] == 'percentage') {
                foreach ($gradient['coords'] as $key => $val) {
                    $gradient['coords'][$key] = (intval($val) / 100);
                    if ($val < 0) {
                        $gradient['coords'][$key] = 0;
                    } else if ($val > 1) {
                        $gradient['coords'][$key] = 1;
                    }
                }
            }
            if (($gradient['type'] == 2) AND ($gradient['coords'][0] == $gradient['coords'][2]) AND
                ($gradient['coords'][1] == $gradient['coords'][3])) {
                // Single color (no shading).
                $gradient['coords'][0] = 1;
                $gradient['coords'][1] = 0;
                $gradient['coords'][2] = 0.999;
                $gradient['coords'][3] = 0;
            }
            // Swap Y coordinates.
            $tmp = $gradient['coords'][1];
            $gradient['coords'][1] = $gradient['coords'][3];
            $gradient['coords'][3] = $tmp;
            // Set transformation map for gradient.
            if ($gradient['type'] == 3) {
                // Circular gradient.
                $cy = $this->h - $y - ($gradient['coords'][1] * ($w + $h));
                $this->_out(sprintf('%F 0 0 %F %F %F cm', ($w * $this->k), ($w * $this->k), ($x * $this->k),
                            ($cy * $this->k)));
            } else {
                $this->_out(sprintf('%F 0 0 %F %F %F cm', ($w * $this->k), ($h * $this->k), ($x * $this->k),
                            (($this->h - ($y + $h)) * $this->k)));
            }
            if (count($gradient['stops']) > 1) {
                $this->gradient($gradient['type'], $gradient['coords'], $gradient['stops'], array(), false);
            }
        } else if ($svgstyle['fill'] != 'none') {
            $fillcolor = $this->converthtmlcolortodec($svgstyle['fill']);
            if ($svgstyle['fill-opacity'] != 1) {
                $this->setalpha($this->alpha['CA'], 'Normal', $svgstyle['fill-opacity'], false);
            }
            $this->setfillcolorarray($fillcolor);
            if ($svgstyle['fill-rule'] == 'evenodd') {
                $objstyle .= 'F*';
            } else {
                $objstyle .= 'F';
            }
        }
        // Stroke.
        if ($svgstyle['stroke'] != 'none') {
            if ($svgstyle['stroke-opacity'] != 1) {
                $this->setalpha($svgstyle['stroke-opacity'], 'Normal', $this->alpha['ca'], false);
            }
            $strokestyle = array(
                'color' => $this->converthtmlcolortodec($svgstyle['stroke']),
                'width' => $this->gethtmlunittounits($svgstyle['stroke-width'], 0, $this->svgunit, false),
                'cap' => $svgstyle['stroke-linecap'],
                'join' => $svgstyle['stroke-linejoin']
                );
            if (isset($svgstyle['stroke-dasharray']) AND !empty($svgstyle['stroke-dasharray']) AND
                     ($svgstyle['stroke-dasharray'] != 'none')) {
                $strokestyle['dash'] = $svgstyle['stroke-dasharray'];
            }
            $this->setlinestyle($strokestyle);
            $objstyle .= 'D';
        }
        // Font.
        $regs = array();
        if (!empty($svgstyle['font'])) {
            if (preg_match('/font-family[\s]*:[\s]*([^\;\"]*)/si', $svgstyle['font'], $regs)) {
                $fontfamily = $this->getfontfamilyname($regs[1]);
            } else {
                $fontfamily = $svgstyle['font-family'];
            }
            if (preg_match('/font-size[\s]*:[\s]*([^\s\;\"]*)/si', $svgstyle['font'], $regs)) {
                $fontsize = trim($regs[1]);
            } else {
                $fontsize = $svgstyle['font-size'];
            }
            if (preg_match('/font-style[\s]*:[\s]*([^\s\;\"]*)/si', $svgstyle['font'], $regs)) {
                $fontstyle = trim($regs[1]);
            } else {
                $fontstyle = $svgstyle['font-style'];
            }
            if (preg_match('/font-weight[\s]*:[\s]*([^\s\;\"]*)/si', $svgstyle['font'], $regs)) {
                $fontweight = trim($regs[1]);
            } else {
                $fontweight = $svgstyle['font-weight'];
            }
            if (preg_match('/font-stretch[\s]*:[\s]*([^\s\;\"]*)/si', $svgstyle['font'], $regs)) {
                $fontstretch = trim($regs[1]);
            } else {
                $fontstretch = $svgstyle['font-stretch'];
            }
            if (preg_match('/letter-spacing[\s]*:[\s]*([^\s\;\"]*)/si', $svgstyle['font'], $regs)) {
                $fontspacing = trim($regs[1]);
            } else {
                $fontspacing = $svgstyle['letter-spacing'];
            }
        } else {
            $fontfamily = $this->getfontfamilyname($svgstyle['font-family']);
            $fontsize = $svgstyle['font-size'];
            $fontstyle = $svgstyle['font-style'];
            $fontweight = $svgstyle['font-weight'];
            $fontstretch = $svgstyle['font-stretch'];
            $fontspacing = $svgstyle['letter-spacing'];
        }
        $fontsize = $this->gethtmlunittounits($fontsize, $prevsvgstyle['font-size'], $this->svgunit, false) * $this->k;
        $fontstretch = $this->getcssfontstretching($fontstretch, $svgstyle['font-stretch']);
        $fontspacing = $this->getcssfontspacing($fontspacing, $svgstyle['letter-spacing']);
        switch ($fontstyle) {
            case 'italic': {
                $fontstyle = 'I';
                break;
            }
            case 'oblique': {
                $fontstyle = 'I';
                break;
            }
            case 'normal': {
                $fontstyle = '';
                break;
            }
        }
        switch ($fontweight) {
            case 'bold':
            case 'bolder': {
                $fontstyle .= 'B';
                break;
            }
        }
        switch ($svgstyle['text-decoration']) {
            case 'underline': {
                $fontstyle .= 'U';
                break;
            }
            case 'overline': {
                $fontstyle .= 'O';
                break;
            }
            case 'line-through': {
                $fontstyle .= 'D';
                break;
            }
            case 'none': {
                break;
            }
        }
        $this->setfont($fontfamily, $fontstyle, $fontsize);
        $this->setfontstretching($fontstretch);
        $this->setfontspacing($fontspacing);
        return $objstyle;
    }

    /**
     * Draws an SVG path
     */
    protected function svgpath($d, $style = '') {
        // Set fill/stroke style.
        $op = $this->getpathpaintoperator($style, '');
        if (empty($op)) {
            return;
        }
        $paths = array();
        $d = preg_replace('/([0-9ACHLMQSTVZ])([\-\+])/si', '\\1 \\2', $d);
        preg_match_all('/([ACHLMQSTVZ])[\s]*([^ACHLMQSTVZ\"]*)/si', $d, $paths, PREG_SET_ORDER);
        $x = 0;
        $y = 0;
        $x1 = 0;
        $y1 = 0;
        $x2 = 0;
        $y2 = 0;
        $xmin = 2147483647;
        $xmax = 0;
        $ymin = 2147483647;
        $ymax = 0;
        $relcoord = false;
        $minlen = (0.01 / $this->k); // Minimum acceptable length (3 point).
        $firstcmd = true; // Used to print first point.
        // Draw curve pieces.
        foreach ($paths as $key => $val) {
            // Get curve type.
            $cmd = trim($val[1]);
            if (strtolower($cmd) == $cmd) {
                // Use relative coordinated instead of absolute.
                $relcoord = true;
                $xoffset = $x;
                $yoffset = $y;
            } else {
                $relcoord = false;
                $xoffset = 0;
                $yoffset = 0;
            }
            $params = array();
            if (isset($val[2])) {
                // Get curve parameters.
                $rawparams = preg_split('/([\,\s]+)/si', trim($val[2]));
                $params = array();
                foreach ($rawparams as $ck => $cp) {
                    $params[$ck] = $this->gethtmlunittounits($cp, 0, $this->svgunit, false);
                    if (abs($params[$ck]) < $minlen) {
                        // Aproximate little values to zero.
                        $params[$ck] = 0;
                    }
                }
            }
            // Store current origin point.
            $x0 = $x;
            $y0 = $y;
            switch (strtoupper($cmd)) {
                case 'M': { // Move to.
                    foreach ($params as $ck => $cp) {
                        if (($ck % 2) == 0) {
                            $x = $cp + $xoffset;
                        } else {
                            $y = $cp + $yoffset;
                            if ($firstcmd OR (abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
                                if ($ck == 1) {
                                    $this->_outpoint($x, $y);
                                    $firstcmd = false;
                                } else {
                                    $this->_outline($x, $y);
                                }
                                $x0 = $x;
                                $y0 = $y;
                            }
                            $xmin = min($xmin, $x);
                            $ymin = min($ymin, $y);
                            $xmax = max($xmax, $x);
                            $ymax = max($ymax, $y);
                            if ($relcoord) {
                                $xoffset = $x;
                                $yoffset = $y;
                            }
                        }
                    }
                    break;
                }
                case 'L': { // Lineto.
                    foreach ($params as $ck => $cp) {
                        if (($ck % 2) == 0) {
                            $x = $cp + $xoffset;
                        } else {
                            $y = $cp + $yoffset;
                            if ((abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
                                $this->_outline($x, $y);
                                $x0 = $x;
                                $y0 = $y;
                            }
                            $xmin = min($xmin, $x);
                            $ymin = min($ymin, $y);
                            $xmax = max($xmax, $x);
                            $ymax = max($ymax, $y);
                            if ($relcoord) {
                                $xoffset = $x;
                                $yoffset = $y;
                            }
                        }
                    }
                    break;
                }
                case 'H': { // Horizontal line to.
                    foreach ($params as $ck => $cp) {
                        $x = $cp + $xoffset;
                        if ((abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
                            $this->_outline($x, $y);
                            $x0 = $x;
                            $y0 = $y;
                        }
                        $xmin = min($xmin, $x);
                        $xmax = max($xmax, $x);
                        if ($relcoord) {
                            $xoffset = $x;
                        }
                    }
                    break;
                }
                case 'V': { // Vertical line to.
                    foreach ($params as $ck => $cp) {
                        $y = $cp + $yoffset;
                        if ((abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
                            $this->_outline($x, $y);
                            $x0 = $x;
                            $y0 = $y;
                        }
                        $ymin = min($ymin, $y);
                        $ymax = max($ymax, $y);
                        if ($relcoord) {
                            $yoffset = $y;
                        }
                    }
                    break;
                }
                case 'C': { // Curve to.
                    foreach ($params as $ck => $cp) {
                        $params[$ck] = $cp;
                        if ((($ck + 1) % 6) == 0) {
                            $x1 = $params[($ck - 5)] + $xoffset;
                            $y1 = $params[($ck - 4)] + $yoffset;
                            $x2 = $params[($ck - 3)] + $xoffset;
                            $y2 = $params[($ck - 2)] + $yoffset;
                            $x = $params[($ck - 1)] + $xoffset;
                            $y = $params[($ck)] + $yoffset;
                            $this->_outcurve($x1, $y1, $x2, $y2, $x, $y);
                            $xmin = min($xmin, $x, $x1, $x2);
                            $ymin = min($ymin, $y, $y1, $y2);
                            $xmax = max($xmax, $x, $x1, $x2);
                            $ymax = max($ymax, $y, $y1, $y2);
                            if ($relcoord) {
                                $xoffset = $x;
                                $yoffset = $y;
                            }
                        }
                    }
                    break;
                }
                case 'S': { // Shorthand/smooth curveto.
                    foreach ($params as $ck => $cp) {
                        $params[$ck] = $cp;
                        if ((($ck + 1) % 4) == 0) {
                            if (($key > 0) AND ((strtoupper($paths[($key - 1)][1]) == 'C') OR
                                 (strtoupper($paths[($key - 1)][1]) == 'S'))) {
                                $x1 = (2 * $x) - $x2;
                                $y1 = (2 * $y) - $y2;
                            } else {
                                $x1 = $x;
                                $y1 = $y;
                            }
                            $x2 = $params[($ck - 3)] + $xoffset;
                            $y2 = $params[($ck - 2)] + $yoffset;
                            $x = $params[($ck - 1)] + $xoffset;
                            $y = $params[($ck)] + $yoffset;
                            $this->_outcurve($x1, $y1, $x2, $y2, $x, $y);
                            $xmin = min($xmin, $x, $x1, $x2);
                            $ymin = min($ymin, $y, $y1, $y2);
                            $xmax = max($xmax, $x, $x1, $x2);
                            $ymax = max($ymax, $y, $y1, $y2);
                            if ($relcoord) {
                                $xoffset = $x;
                                $yoffset = $y;
                            }
                        }
                    }
                    break;
                }
                case 'Q': { // Quadratic Bzier curveto.
                    foreach ($params as $ck => $cp) {
                        $params[$ck] = $cp;
                        if ((($ck + 1) % 4) == 0) {
                            // Convert quadratic points to cubic points.
                            $x1 = $params[($ck - 3)] + $xoffset;
                            $y1 = $params[($ck - 2)] + $yoffset;
                            $xa = ($x + (2 * $x1)) / 3;
                            $ya = ($y + (2 * $y1)) / 3;
                            $x = $params[($ck - 1)] + $xoffset;
                            $y = $params[($ck)] + $yoffset;
                            $xb = ($x + (2 * $x1)) / 3;
                            $yb = ($y + (2 * $y1)) / 3;
                            $this->_outcurve($xa, $ya, $xb, $yb, $x, $y);
                            $xmin = min($xmin, $x, $xa, $xb);
                            $ymin = min($ymin, $y, $ya, $yb);
                            $xmax = max($xmax, $x, $xa, $xb);
                            $ymax = max($ymax, $y, $ya, $yb);
                            if ($relcoord) {
                                $xoffset = $x;
                                $yoffset = $y;
                            }
                        }
                    }
                    break;
                }
                case 'T': { // Shorthand/smooth quadratic Bzier curveto.
                    foreach ($params as $ck => $cp) {
                        $params[$ck] = $cp;
                        if (($ck % 2) != 0) {
                            if (($key > 0) AND ((strtoupper($paths[($key - 1)][1]) == 'Q') OR
                                (strtoupper($paths[($key - 1)][1]) == 'T'))) {
                                $x1 = (2 * $x) - $x1;
                                $y1 = (2 * $y) - $y1;
                            } else {
                                $x1 = $x;
                                $y1 = $y;
                            }
                            // Convert quadratic points to cubic points.
                            $xa = ($x + (2 * $x1)) / 3;
                            $ya = ($y + (2 * $y1)) / 3;
                            $x = $params[($ck - 1)] + $xoffset;
                            $y = $params[($ck)] + $yoffset;
                            $xb = ($x + (2 * $x1)) / 3;
                            $yb = ($y + (2 * $y1)) / 3;
                            $this->_outcurve($xa, $ya, $xb, $yb, $x, $y);
                            $xmin = min($xmin, $x, $xa, $xb);
                            $ymin = min($ymin, $y, $ya, $yb);
                            $xmax = max($xmax, $x, $xa, $xb);
                            $ymax = max($ymax, $y, $ya, $yb);
                            if ($relcoord) {
                                $xoffset = $x;
                                $yoffset = $y;
                            }
                        }
                    }
                    break;
                }
                case 'A': { // Elliptical arc.
                    foreach ($params as $ck => $cp) {
                        $params[$ck] = $cp;
                        if ((($ck + 1) % 7) == 0) {
                            $x0 = $x;
                            $y0 = $y;
                            $rx = abs($params[($ck - 6)]);
                            $ry = abs($params[($ck - 5)]);
                            $ang = -$rawparams[($ck - 4)];
                            $angle = deg2rad($ang);
                            $fa = $rawparams[($ck - 3)]; // Large-arc-flag.
                            $fs = $rawparams[($ck - 2)]; // Sweep-flag.
                            $x = $params[($ck - 1)] + $xoffset;
                            $y = $params[$ck] + $yoffset;
                            if ((abs($x0 - $x) < $minlen) AND (abs($y0 - $y) < $minlen)) {
                                // Endpoints are almost identical.
                                $xmin = min($xmin, $x);
                                $ymin = min($ymin, $y);
                                $xmax = max($xmax, $x);
                                $ymax = max($ymax, $y);
                            } else {
                                $cosang = cos($angle);
                                $sinang = sin($angle);
                                $a = (($x0 - $x) / 2);
                                $b = (($y0 - $y) / 2);
                                $xa = ($a * $cosang) - ($b * $sinang);
                                $ya = ($a * $sinang) + ($b * $cosang);
                                $rx2 = $rx * $rx;
                                $ry2 = $ry * $ry;
                                $xa2 = $xa * $xa;
                                $ya2 = $ya * $ya;
                                $delta = ($xa2 / $rx2) + ($ya2 / $ry2);
                                if ($delta > 1) {
                                    $rx *= sqrt($delta);
                                    $ry *= sqrt($delta);
                                    $rx2 = $rx * $rx;
                                    $ry2 = $ry * $ry;
                                }
                                $numerator = (($rx2 * $ry2) - ($rx2 * $ya2) - ($ry2 * $xa2));
                                if ($numerator < 0) {
                                    $root = 0;
                                } else {
                                    $root = sqrt($numerator / (($rx2 * $ya2) + ($ry2 * $xa2)));
                                }
                                if ($fa == $fs) {
                                    $root *= -1;
                                }
                                $cax = $root * (($rx * $ya) / $ry);
                                $cay = -$root * (($ry * $xa) / $rx);
                                // Coordinates of ellipse center.
                                $cx = ($cax * $cosang) - ($cay * $sinang) + (($x0 + $x) / 2);
                                $cy = ($cax * $sinang) + ($cay * $cosang) + (($y0 + $y) / 2);
                                // Get angles.
                                $angs = $this->getvectorsangle(1, 0, (($xa - $cax) / $rx), (($cay - $ya) / $ry));
                                $dang = $this->getvectorsangle((($xa - $cax) / $rx), (($ya - $cay) / $ry),
                                                               ((-$xa - $cax) / $rx), ((-$ya - $cay) / $ry));
                                if (($fs == 0) AND ($dang > 0)) {
                                    $dang -= (2 * M_PI);
                                } else if (($fs == 1) AND ($dang < 0)) {
                                    $dang += (2 * M_PI);
                                }
                                $angf = $angs - $dang;
                                if ((($fs == 0) AND ($angs > $angf)) OR (($fs == 1) AND ($angs < $angf))) {
                                    // Reverse angles.
                                    $tmp = $angs;
                                    $angs = $angf;
                                    $angf = $tmp;
                                }
                                $angs = round(rad2deg($angs), 6);
                                $angf = round(rad2deg($angf), 6);
                                // Convert angles to positive values.
                                if (($angs < 0) AND ($angf < 0)) {
                                    $angs += 360;
                                    $angf += 360;
                                }
                                $pie = false;
                                if (($key == 0) AND (isset($paths[($key + 1)][1])) AND (trim($paths[($key + 1)][1]) == 'z')) {
                                    $pie = true;
                                }
                                list($axmin, $aymin, $axmax, $aymax) = $this->_outellipticalarc($cx, $cy, $rx, $ry, $ang, $angs,
                                                                       $angf, $pie, 2, false, ($fs == 0), true);
                                $xmin = min($xmin, $x, $axmin);
                                $ymin = min($ymin, $y, $aymin);
                                $xmax = max($xmax, $x, $axmax);
                                $ymax = max($ymax, $y, $aymax);
                            }
                            if ($relcoord) {
                                $xoffset = $x;
                                $yoffset = $y;
                            }
                        }
                    }
                    break;
                }
                case 'Z': {
                    $this->_out('h');
                    break;
                }
            }
            $firstcmd = false;
        } // End foreach.
        if (!empty($op)) {
            $this->_out($op);
        }
        return array($xmin, $ymin, ($xmax - $xmin), ($ymax - $ymin));
    }

    /**
     * Returns the angle in radiants between two vectors
     */
    protected function getvectorsangle($x1, $y1, $x2, $y2) {
        $dprod = ($x1 * $x2) + ($y1 * $y2);
        $dist1 = sqrt(($x1 * $x1) + ($y1 * $y1));
        $dist2 = sqrt(($x2 * $x2) + ($y2 * $y2));
        $angle = acos($dprod / ($dist1 * $dist2));
        if (is_nan($angle)) {
            $angle = M_PI;
        }
        if ((($x1 * $y2) - ($x2 * $y1)) < 0) {
            $angle *= -1;
        }
        return $angle;
    }

    /**
     * Sets the opening SVG element handler function for the XML parser.
     */
    protected function startsvgelementhandler($parser, $name, $attribs, $ctm = array()) {
        // Check if we are in clip mode.
        if ($this->svgclipmode) {
            $this->svgclippaths[$this->svgclipid][] = array('name' => $name, 'attribs' => $attribs,
                               'tm' => $this->svgcliptm[$this->svgclipid]);
            return;
        }
        if ($this->svgdefsmode AND !in_array($name, array('clipPath', 'lineargradient', 'radialgradient', 'stop'))) {
            if (!isset($attribs['id'])) {
                $attribs['id'] = 'DF_'.(count($this->svgdefs) + 1);
            }
            $this->svgdefs[$attribs['id']] = array('name' => $name, 'attribs' => $attribs);
            return;
        }
        $clipping = false;
        if ($parser == 'clip-path') {
            // Set clipping mode.
            $clipping = true;
        }
        // Get styling properties.
        $prevsvgstyle = $this->svgstyles[(count($this->svgstyles) - 1)]; // Previous style.
        $svgstyle = $this->svgstyles[0]; // Set default style.
        if ($clipping AND !isset($attribs['fill']) AND (!isset($attribs['style']) OR
        (!preg_match('/[;\"\s]{1}fill[\s]*:[\s]*([^;\"]*)/si', $attribs['style'], $attrval)))) {
            // Default fill attribute for clipping.
            $attribs['fill'] = 'none';
        }
        if (isset($attribs['style']) AND !$this->empty_string($attribs['style'])) {
            // Fix style for regular expression.
            $attribs['style'] = ';'.$attribs['style'];
        }
        foreach ($prevsvgstyle as $key => $val) {
            if (in_array($key, $this->svginheritprop)) {
                // Inherit previous value.
                $svgstyle[$key] = $val;
            }
            if (isset($attribs[$key]) AND !$this->empty_string($attribs[$key])) {
                // Specific attribute settings.
                if ($attribs[$key] == 'inherit') {
                    $svgstyle[$key] = $val;
                } else {
                    $svgstyle[$key] = $attribs[$key];
                }
            } else if (isset($attribs['style']) AND !$this->empty_string($attribs['style'])) {
                // CSS style syntax.
                $attrval = array();
                if (preg_match('/[;\"\s]{1}'.$key.'[\s]*:[\s]*([^;\"]*)/si', $attribs['style'], $attrval) AND
                    isset($attrval[1])) {
                    if ($attrval[1] == 'inherit') {
                        $svgstyle[$key] = $val;
                    } else {
                        $svgstyle[$key] = $attrval[1];
                    }
                }
            }
        }
        // Transformation matrix.
        if (!empty($ctm)) {
            $tm = $ctm;
        } else {
            $tm = array(1, 0, 0, 1, 0, 0);
        }
        if (isset($attribs['transform']) AND !empty($attribs['transform'])) {
            $tm = $this->gettransformationmatrixproduct($tm, $this->getsvgtransformmatrix($attribs['transform']));
        }
        $svgstyle['transfmatrix'] = $tm;
        $invisible = false;
        if (($svgstyle['visibility'] == 'hidden') OR ($svgstyle['visibility'] == 'collapse') OR
            ($svgstyle['display'] == 'none')) {
            // The current graphics element is invisible (nothing is painted).
            $invisible = true;
        }
        // Process tag.
        switch($name) {
            case 'defs': {
                $this->svgdefsmode = true;
                break;
            }
            // ClipPath.
            case 'clipPath': {
                if ($invisible) {
                    break;
                }
                $this->svgclipmode = true;
                if (!isset($attribs['id'])) {
                    $attribs['id'] = 'CP_'.(count($this->svgcliptm) + 1);
                }
                $this->svgclipid = $attribs['id'];
                $this->svgclippaths[$this->svgclipid] = array();
                $this->svgcliptm[$this->svgclipid] = $tm;
                break;
            }
            case 'svg': {
                // Start of SVG object.
                break;
            }
            case 'g': {
                // Group together related graphics elements.
                array_push($this->svgstyles, $svgstyle);
                $this->starttransform();
                $this->svgtransform($tm);
                $this->setsvgstyles($svgstyle, $prevsvgstyle);
                break;
            }
            case 'lineargradient': {
                if ($this->pdfamode) {
                    break;
                }
                if (!isset($attribs['id'])) {
                    $attribs['id'] = 'GR_'.(count($this->svggradients) + 1);
                }
                $this->svggradientid = $attribs['id'];
                $this->svggradients[$this->svggradientid] = array();
                $this->svggradients[$this->svggradientid]['type'] = 2;
                $this->svggradients[$this->svggradientid]['stops'] = array();
                if (isset($attribs['gradientUnits'])) {
                    $this->svggradients[$this->svggradientid]['gradientUnits'] = $attribs['gradientUnits'];
                } else {
                    $this->svggradients[$this->svggradientid]['gradientUnits'] = 'objectBoundingBox';
                }
                if (((!isset($attribs['x1'])) AND (!isset($attribs['y1'])) AND (!isset($attribs['x2'])) AND
                    (!isset($attribs['y2'])))
                    OR ((isset($attribs['x1']) AND (substr($attribs['x1'], -1) == '%'))
                        OR (isset($attribs['y1']) AND (substr($attribs['y1'], -1) == '%'))
                        OR (isset($attribs['x2']) AND (substr($attribs['x2'], -1) == '%'))
                        OR (isset($attribs['y2']) AND (substr($attribs['y2'], -1) == '%')))) {
                    $this->svggradients[$this->svggradientid]['mode'] = 'percentage';
                } else {
                    $this->svggradients[$this->svggradientid]['mode'] = 'measure';
                }
                $x1 = (isset($attribs['x1']) ? $attribs['x1'] : '0');
                $y1 = (isset($attribs['y1']) ? $attribs['y1'] : '0');
                $x2 = (isset($attribs['x2']) ? $attribs['x2'] : '100');
                $y2 = (isset($attribs['y2']) ? $attribs['y2'] : '0');
                if (isset($attribs['gradienttransform'])) {
                    $this->svggradients[$this->svggradientid]['gradienttransform'] =
                    $this->getsvgtransformmatrix($attribs['gradienttransform']);
                }
                $this->svggradients[$this->svggradientid]['coords'] = array($x1, $y1, $x2, $y2);
                if (isset($attribs['xlink:href']) AND !empty($attribs['xlink:href'])) {
                    // Gradient is defined on another place.
                    $this->svggradients[$this->svggradientid]['xref'] = substr($attribs['xlink:href'], 1);
                }
                break;
            }
            case 'radialgradient': {
                if ($this->pdfamode) {
                    break;
                }
                if (!isset($attribs['id'])) {
                    $attribs['id'] = 'GR_'.(count($this->svggradients) + 1);
                }
                $this->svggradientid = $attribs['id'];
                $this->svggradients[$this->svggradientid] = array();
                $this->svggradients[$this->svggradientid]['type'] = 3;
                $this->svggradients[$this->svggradientid]['stops'] = array();
                if (isset($attribs['gradientUnits'])) {
                    $this->svggradients[$this->svggradientid]['gradientUnits'] = $attribs['gradientUnits'];
                } else {
                    $this->svggradients[$this->svggradientid]['gradientUnits'] = 'objectBoundingBox';
                }
                if (((!isset($attribs['cx'])) AND (!isset($attribs['cy'])))
                    OR ((isset($attribs['cx']) AND (substr($attribs['cx'], -1) == '%'))
                        OR (isset($attribs['cy']) AND (substr($attribs['cy'], -1) == '%')) )) {
                    $this->svggradients[$this->svggradientid]['mode'] = 'percentage';
                } else {
                    $this->svggradients[$this->svggradientid]['mode'] = 'measure';
                }
                $cx = (isset($attribs['cx']) ? $attribs['cx'] : 0.5);
                $cy = (isset($attribs['cy']) ? $attribs['cy'] : 0.5);
                $fx = (isset($attribs['fx']) ? $attribs['fx'] : $cx);
                $fy = (isset($attribs['fy']) ? $attribs['fy'] : $cy);
                $r = (isset($attribs['r']) ? $attribs['r'] : 0.5);
                if (isset($attribs['gradienttransform'])) {
                    $this->svggradients[$this->svggradientid]['gradienttransform'] =
                    $this->getsvgtransformmatrix($attribs['gradienttransform']);
                }
                $this->svggradients[$this->svggradientid]['coords'] = array($cx, $cy, $fx, $fy, $r);
                if (isset($attribs['xlink:href']) AND !empty($attribs['xlink:href'])) {
                    // Gradient is defined on another place.
                    $this->svggradients[$this->svggradientid]['xref'] = substr($attribs['xlink:href'], 1);
                }
                break;
            }
            case 'stop': {
                // Gradient stops.
                if (substr($attribs['offset'], -1) == '%') {
                    $offset = floatval(substr($attribs['offset'], -1)) / 100;
                } else {
                    $offset = floatval($attribs['offset']);
                    if ($offset > 1) {
                        $offset /= 100;
                    }
                }
                $stopcolor = isset($svgstyle['stop-color']) ? $this->converthtmlcolortodec($svgstyle['stop-color']) :
                                   'black';
                $opacity = isset($svgstyle['stop-opacity']) ? $svgstyle['stop-opacity'] : 1;
                $this->svggradients[$this->svggradientid]['stops'][] = array('offset' => $offset, 'color' => $stopcolor,
                                    'opacity' => $opacity);
                break;
            }
            // Paths.
            case 'path': {
                if ($invisible) {
                    break;
                }
                if (isset($attribs['d'])) {
                    $d = trim($attribs['d']);
                    if (!empty($d)) {
                        if ($clipping) {
                            $this->svgtransform($tm);
                            $this->svgpath($d, 'CNZ');
                        } else {
                            $this->starttransform();
                            $this->svgtransform($tm);
                            $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, 0, 0, 1, 1, 'svgpath',
                                                           array($d, 'CNZ'));
                            if (!empty($obstyle)) {
                                $this->svgpath($d, $obstyle);
                            }
                            $this->stoptransform();
                        }
                    }
                }
                break;
            }
            // Shapes.
            case 'rect': {
                if ($invisible) {
                    break;
                }
                $x = (isset($attribs['x']) ? $this->gethtmlunittounits($attribs['x'], 0, $this->svgunit, false) : 0);
                $y = (isset($attribs['y']) ? $this->gethtmlunittounits($attribs['y'], 0, $this->svgunit, false) : 0);
                $w = (isset($attribs['width']) ? $this->gethtmlunittounits($attribs['width'], 0, $this->svgunit, false) : 0);
                $h = (isset($attribs['height']) ? $this->gethtmlunittounits($attribs['height'], 0, $this->svgunit, false) : 0);
                $rx = (isset($attribs['rx']) ? $this->gethtmlunittounits($attribs['rx'], 0, $this->svgunit, false) : 0);
                $ry = (isset($attribs['ry']) ? $this->gethtmlunittounits($attribs['ry'], 0, $this->svgunit, false) : $rx);
                if ($clipping) {
                    $this->svgtransform($tm);
                    $this->roundedrectxy($x, $y, $w, $h, $rx, $ry, '1111', 'CNZ', array(), array());
                } else {
                    $this->starttransform();
                    $this->svgtransform($tm);
                    $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, $w, $h, 'roundedrectxy',
                    array($x, $y, $w, $h, $rx, $ry, '1111', 'CNZ'));
                    if (!empty($obstyle)) {
                        $this->roundedrectxy($x, $y, $w, $h, $rx, $ry, '1111', $obstyle, array(), array());
                    }
                    $this->stoptransform();
                }
                break;
            }
            case 'circle': {
                if ($invisible) {
                    break;
                }
                $cx = (isset($attribs['cx']) ? $this->gethtmlunittounits($attribs['cx'], 0, $this->svgunit, false) : 0);
                $cy = (isset($attribs['cy']) ? $this->gethtmlunittounits($attribs['cy'], 0, $this->svgunit, false) : 0);
                $r = (isset($attribs['r']) ? $this->gethtmlunittounits($attribs['r'], 0, $this->svgunit, false) : 0);
                $x = $cx - $r;
                $y = $cy - $r;
                $w = 2 * $r;
                $h = $w;
                if ($clipping) {
                    $this->svgtransform($tm);
                    $this->circle($cx, $cy, $r, 0, 360, 'CNZ', array(), array(), 8);
                } else {
                    $this->starttransform();
                    $this->svgtransform($tm);
                    $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, $w, $h, 'circle',
                               array($cx, $cy, $r, 0, 360, 'CNZ'));
                    if (!empty($obstyle)) {
                        $this->circle($cx, $cy, $r, 0, 360, $obstyle, array(), array(), 8);
                    }
                    $this->stoptransform();
                }
                break;
            }
            case 'ellipse': {
                if ($invisible) {
                    break;
                }
                $cx = (isset($attribs['cx']) ? $this->gethtmlunittounits($attribs['cx'], 0, $this->svgunit, false) : 0);
                $cy = (isset($attribs['cy']) ? $this->gethtmlunittounits($attribs['cy'], 0, $this->svgunit, false) : 0);
                $rx = (isset($attribs['rx']) ? $this->gethtmlunittounits($attribs['rx'], 0, $this->svgunit, false) : 0);
                $ry = (isset($attribs['ry']) ? $this->gethtmlunittounits($attribs['ry'], 0, $this->svgunit, false) : 0);
                $x = $cx - $rx;
                $y = $cy - $ry;
                $w = 2 * $rx;
                $h = 2 * $ry;
                if ($clipping) {
                    $this->svgtransform($tm);
                    $this->ellipse($cx, $cy, $rx, $ry, 0, 0, 360, 'CNZ', array(), array(), 8);
                } else {
                    $this->starttransform();
                    $this->svgtransform($tm);
                    $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, $w, $h, 'ellipse',
                    array($cx, $cy, $rx, $ry, 0, 0, 360, 'CNZ'));
                    if (!empty($obstyle)) {
                        $this->ellipse($cx, $cy, $rx, $ry, 0, 0, 360, $obstyle, array(), array(), 8);
                    }
                    $this->stoptransform();
                }
                break;
            }
            case 'line': {
                if ($invisible) {
                    break;
                }
                $x1 = (isset($attribs['x1']) ? $this->gethtmlunittounits($attribs['x1'], 0, $this->svgunit, false) : 0);
                $y1 = (isset($attribs['y1']) ? $this->gethtmlunittounits($attribs['y1'], 0, $this->svgunit, false) : 0);
                $x2 = (isset($attribs['x2']) ? $this->gethtmlunittounits($attribs['x2'], 0, $this->svgunit, false) : 0);
                $y2 = (isset($attribs['y2']) ? $this->gethtmlunittounits($attribs['y2'], 0, $this->svgunit, false) : 0);
                $x = $x1;
                $y = $y1;
                $w = abs($x2 - $x1);
                $h = abs($y2 - $y1);
                if (!$clipping) {
                    $this->starttransform();
                    $this->svgtransform($tm);
                    $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, $w, $h, 'line',
                               array($x1, $y1, $x2, $y2));
                    $this->line($x1, $y1, $x2, $y2);
                    $this->stoptransform();
                }
                break;
            }
            case 'polyline':
            case 'polygon': {
                if ($invisible) {
                    break;
                }
                $points = (isset($attribs['points']) ? $attribs['points'] : '0 0');
                $points = trim($points);
                // Note that point may use a complex syntax not covered here.
                $points = preg_split('/[\,\s]+/si', $points);
                if (count($points) < 4) {
                    break;
                }
                $p = array();
                $xmin = 2147483647;
                $xmax = 0;
                $ymin = 2147483647;
                $ymax = 0;
                foreach ($points as $key => $val) {
                    $p[$key] = $this->gethtmlunittounits($val, 0, $this->svgunit, false);
                    if (($key % 2) == 0) {
                        // X coordinate.
                        $xmin = min($xmin, $p[$key]);
                        $xmax = max($xmax, $p[$key]);
                    } else {
                        // Y coordinate.
                        $ymin = min($ymin, $p[$key]);
                        $ymax = max($ymax, $p[$key]);
                    }
                }
                $x = $xmin;
                $y = $ymin;
                $w = ($xmax - $xmin);
                $h = ($ymax - $ymin);
                if ($name == 'polyline') {
                    $this->starttransform();
                    $this->svgtransform($tm);
                    $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, $w, $h, 'polyline', array($p, 'CNZ'));
                    if (!empty($obstyle)) {
                        $this->polyline($p, $obstyle, array(), array());
                    }
                    $this->stoptransform();
                } else { // Polygon.
                    if ($clipping) {
                        $this->svgtransform($tm);
                        $this->polygon($p, 'CNZ', array(), array(), true);
                    } else {
                        $this->starttransform();
                        $this->svgtransform($tm);
                        $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, $w, $h, 'polygon',
                        array($p, 'CNZ'));
                        if (!empty($obstyle)) {
                            $this->polygon($p, $obstyle, array(), array(), true);
                        }
                        $this->stoptransform();
                    }
                }
                break;
            }
            // Image.
            case 'image': {
                if ($invisible) {
                    break;
                }
                if (!isset($attribs['xlink:href']) OR empty($attribs['xlink:href'])) {
                    break;
                }
                $x = (isset($attribs['x']) ? $this->gethtmlunittounits($attribs['x'], 0, $this->svgunit, false) : 0);
                $y = (isset($attribs['y']) ? $this->gethtmlunittounits($attribs['y'], 0, $this->svgunit, false) : 0);
                $w = (isset($attribs['width']) ? $this->gethtmlunittounits($attribs['width'], 0,
                            $this->svgunit, false) : 0);
                $h = (isset($attribs['height']) ? $this->gethtmlunittounits($attribs['height'], 0, $this->svgunit,
                      false) : 0);
                $img = $attribs['xlink:href'];
                if (!$clipping) {
                    $this->starttransform();
                    $this->svgtransform($tm);
                    $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, $w, $h);
                    if (preg_match('/^data:image\/[^;]+;base64,/', $img, $m) > 0) {
                        // Embedded image encoded as base64.
                        $img = '@'.base64_decode(substr($img, strlen($m[0])));
                    } else {
                        // Fix image path.
                        if (!$this->empty_string($this->svgdir) AND (($img{0} == '.') OR (basename($img) == $img))) {
                            // Replace relative path with full server path.
                            $img = $this->svgdir.'/'.$img;
                        }
                        if (($img[0] == '/') AND !empty($_SERVER['DOCUMENT_ROOT']) AND
                              ($_SERVER['DOCUMENT_ROOT'] != '/')) {
                            $findroot = strpos($img, $_SERVER['DOCUMENT_ROOT']);
                            if (($findroot === false) OR ($findroot > 1)) {
                                if (substr($_SERVER['DOCUMENT_ROOT'], -1) == '/') {
                                    $img = substr($_SERVER['DOCUMENT_ROOT'], 0, -1).$img;
                                } else {
                                    $img = $_SERVER['DOCUMENT_ROOT'].$img;
                                }
                            }
                        }
                        $img = urldecode($img);
                        $testscrtype = @parse_url($img);
                        if (!isset($testscrtype['query']) OR empty($testscrtype['query'])) {
                            // Convert URL to server path.
                            $img = str_replace(K_PATH_URL, K_PATH_MAIN, $img);
                        }
                    }
                    $this->imageq($img, $x, $y, $w, $h);
                    $this->stoptransform();
                }
                break;
            }
            // Text.
            case 'text':
            case 'tspan': {
                // Only basic support - advanced features must be implemented.
                $this->svgtextmode['invisible'] = $invisible;
                if ($invisible) {
                    break;
                }
                array_push($this->svgstyles, $svgstyle);
                if (isset($attribs['x'])) {
                    $x = $this->gethtmlunittounits($attribs['x'], 0, $this->svgunit, false);
                } else if ($name == 'tspan') {
                    $x = $this->x;
                } else {
                    $x = 0;
                }
                if (isset($attribs['y'])) {
                    $y = $this->gethtmlunittounits($attribs['y'], 0, $this->svgunit, false);
                } else if ($name == 'tspan') {
                    $y = $this->y;
                } else {
                    $y = 0;
                }
                $svgstyle['text-color'] = $svgstyle['fill'];
                $this->svgtext = '';
                if (isset($svgstyle['text-anchor'])) {
                    $this->svgtextmode['text-anchor'] = $svgstyle['text-anchor'];
                } else {
                    $this->svgtextmode['text-anchor'] = 'start';
                }
                if (isset($svgstyle['direction'])) {
                    if ($svgstyle['direction'] == 'rtl') {
                        $this->svgtextmode['rtl'] = true;
                    } else {
                        $this->svgtextmode['rtl'] = false;
                    }
                } else {
                    $this->svgtextmode['rtl'] = false;
                }
                if (isset($svgstyle['stroke']) AND ($svgstyle['stroke'] != 'none') AND
                isset($svgstyle['stroke-width']) AND ($svgstyle['stroke-width'] > 0)) {
                    $this->svgtextmode['stroke'] = $this->gethtmlunittounits($svgstyle['stroke-width'], 0,
                                                   $this->svgunit, false);
                } else {
                    $this->svgtextmode['stroke'] = false;
                }
                $this->starttransform();
                $this->svgtransform($tm);
                $obstyle = $this->setsvgstyles($svgstyle, $prevsvgstyle, $x, $y, 1, 1);
                $this->x = $x;
                $this->y = $y;
                break;
            }
            // Use.
            case 'use': {
                if (isset($attribs['xlink:href']) AND !empty($attribs['xlink:href'])) {
                    $svgdefid = substr($attribs['xlink:href'], 1);
                    if (isset($this->svgdefs[$svgdefid])) {
                        $use = $this->svgdefs[$svgdefid];
                        if (isset($attribs['xlink:href'])) {
                            unset($attribs['xlink:href']);
                        }
                        if (isset($attribs['id'])) {
                            unset($attribs['id']);
                        }
                        $attribs = array_merge($attribs, $use['attribs']);
                        $this->startsvgelementhandler($parser, $use['name'], $attribs);
                    }
                }
                break;
            }
            default: {
                break;
            }
        } // End of switch.
    }

    /**
     * Sets the closing SVG element handler function for the XML parser.
     */
    protected function endsvgelementhandler($parser, $name) {
        switch($name) {
            case 'defs': {
                $this->svgdefsmode = false;
                break;
            }
            // ClipPath.
            case 'clipPath': {
                $this->svgclipmode = false;
                break;
            }
            case 'g': {
                // Ungroup: remove last style from array.
                array_pop($this->svgstyles);
                $this->stoptransform();
                break;
            }
            case 'text':
            case 'tspan': {
                if ($this->svgtextmode['invisible']) {
                    // This implementation must be fixed to following the rule.
                    break;
                }
                // Print text.
                $text = $this->svgtext;
                $textlen = $this->getstringwidth($text);
                if ($this->svgtextmode['text-anchor'] != 'start') {
                    // Check if string is RTL text.
                    if ($this->svgtextmode['text-anchor'] == 'end') {
                        if ($this->svgtextmode['rtl']) {
                            $this->x += $textlen;
                        } else {
                            $this->x -= $textlen;
                        }
                    } else if ($this->svgtextmode['text-anchor'] == 'middle') {
                        if ($this->svgtextmode['rtl']) {
                            $this->x += ($textlen / 2);
                        } else {
                            $this->x -= ($textlen / 2);
                        }
                    }
                }
                $textrendermode = $this->textrendermode;
                $textstrokewidth = $this->textstrokewidth;
                $this->settextrenderingmode($this->svgtextmode['stroke'], true, false);
                if ($name == 'text') {
                    // Store current coordinates.
                    $tmpx = $this->x;
                    $tmpy = $this->y;
                }
                $this->cell($textlen, 0, $text, 0, 0, '', false, '', 0, false, 'L', 'T');
                if ($name == 'text') {
                    // Restore coordinates.
                    $this->x = $tmpx;
                    $this->y = $tmpy;
                }
                // Restore previous rendering mode.
                $this->textrendermode = $textrendermode;
                $this->textstrokewidth = $textstrokewidth;
                $this->svgtext = '';
                $this->stoptransform();
                array_pop($this->svgstyles);
                break;
            }
            default: {
                break;
            }
        }
    }

    /**
     * Sets the character data handler function for the XML parser.
     */
    protected function segsvgcontenthandler($parser, $data) {
        $this->svgtext .= $data;
    }
}
